// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/mollie/mollie-api-golang/internal/utils"
	"github.com/mollie/mollie-api-golang/models/components"
)

// CreateSubscriptionAmountRequest - The amount for each individual payment that is charged with this subscription. For example, for a monthly
// subscription of €10, the subscription amount should be set to €10.
type CreateSubscriptionAmountRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateSubscriptionAmountRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateSubscriptionAmountRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateSubscriptionMethodRequest - The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
type CreateSubscriptionMethodRequest string

const (
	CreateSubscriptionMethodRequestCreditcard  CreateSubscriptionMethodRequest = "creditcard"
	CreateSubscriptionMethodRequestDirectdebit CreateSubscriptionMethodRequest = "directdebit"
	CreateSubscriptionMethodRequestPaypal      CreateSubscriptionMethodRequest = "paypal"
)

func (e CreateSubscriptionMethodRequest) ToPointer() *CreateSubscriptionMethodRequest {
	return &e
}
func (e *CreateSubscriptionMethodRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "creditcard":
		fallthrough
	case "directdebit":
		fallthrough
	case "paypal":
		*e = CreateSubscriptionMethodRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateSubscriptionMethodRequest: %v", v)
	}
}

// CreateSubscriptionApplicationFeeAmountRequest - In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
type CreateSubscriptionApplicationFeeAmountRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateSubscriptionApplicationFeeAmountRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateSubscriptionApplicationFeeAmountRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateSubscriptionApplicationFeeRequest - With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
// merchants.
//
// Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
//
// Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
// information.
type CreateSubscriptionApplicationFeeRequest struct {
	// In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
	Amount      CreateSubscriptionApplicationFeeAmountRequest `json:"amount"`
	Description string                                        `json:"description"`
}

func (o *CreateSubscriptionApplicationFeeRequest) GetAmount() CreateSubscriptionApplicationFeeAmountRequest {
	if o == nil {
		return CreateSubscriptionApplicationFeeAmountRequest{}
	}
	return o.Amount
}

func (o *CreateSubscriptionApplicationFeeRequest) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

type CreateSubscriptionMetadataRequestType string

const (
	CreateSubscriptionMetadataRequestTypeStr        CreateSubscriptionMetadataRequestType = "str"
	CreateSubscriptionMetadataRequestTypeMapOfAny   CreateSubscriptionMetadataRequestType = "mapOfAny"
	CreateSubscriptionMetadataRequestTypeArrayOfStr CreateSubscriptionMetadataRequestType = "arrayOfStr"
)

// CreateSubscriptionMetadataRequest - Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
// Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
// 1kB.
//
// Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
type CreateSubscriptionMetadataRequest struct {
	Str        *string        `queryParam:"inline" name:"metadata"`
	MapOfAny   map[string]any `queryParam:"inline" name:"metadata"`
	ArrayOfStr []string       `queryParam:"inline" name:"metadata"`

	Type CreateSubscriptionMetadataRequestType
}

func CreateCreateSubscriptionMetadataRequestStr(str string) CreateSubscriptionMetadataRequest {
	typ := CreateSubscriptionMetadataRequestTypeStr

	return CreateSubscriptionMetadataRequest{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateSubscriptionMetadataRequestMapOfAny(mapOfAny map[string]any) CreateSubscriptionMetadataRequest {
	typ := CreateSubscriptionMetadataRequestTypeMapOfAny

	return CreateSubscriptionMetadataRequest{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreateCreateSubscriptionMetadataRequestArrayOfStr(arrayOfStr []string) CreateSubscriptionMetadataRequest {
	typ := CreateSubscriptionMetadataRequestTypeArrayOfStr

	return CreateSubscriptionMetadataRequest{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *CreateSubscriptionMetadataRequest) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateSubscriptionMetadataRequestTypeStr
		return nil
	}

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = CreateSubscriptionMetadataRequestTypeMapOfAny
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = CreateSubscriptionMetadataRequestTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateSubscriptionMetadataRequest", string(data))
}

func (u CreateSubscriptionMetadataRequest) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type CreateSubscriptionMetadataRequest: all fields are null")
}

type CreateSubscriptionRequestBody struct {
	// The amount for each individual payment that is charged with this subscription. For example, for a monthly
	// subscription of €10, the subscription amount should be set to €10.
	Amount CreateSubscriptionAmountRequest `json:"amount"`
	// Total number of payments for the subscription. Once this number of payments is reached, the subscription is
	// considered completed.
	//
	// Test mode subscriptions will get canceled automatically after 10 payments.
	Times *int64 `json:"times,omitempty"`
	// Interval to wait between payments, for example `1 month` or `14 days`.
	//
	// The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
	//
	// Possible values: `... days`, `... weeks`, `... months`.
	Interval string `json:"interval"`
	// The start date of the subscription in `YYYY-MM-DD` format.
	StartDate *string `json:"startDate,omitempty"`
	// The subscription's description will be used as the description of the resulting individual payments and so showing
	// up on the bank statement of the consumer.
	//
	// **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
	Description string `json:"description"`
	// The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
	Method *CreateSubscriptionMethodRequest `json:"method,omitempty"`
	// With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
	// merchants.
	//
	// Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
	//
	// Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
	// information.
	ApplicationFee *CreateSubscriptionApplicationFeeRequest `json:"applicationFee,omitempty"`
	// Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
	// Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
	// 1kB.
	//
	// Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
	Metadata *CreateSubscriptionMetadataRequest `json:"metadata,omitempty"`
	// We will call this URL for any payment status changes of payments resulting from this subscription.
	//
	// This webhook will receive **all** events for the subscription's payments. This may include payment failures as
	// well. Be sure to verify the payment's subscription ID and its status.
	WebhookURL *string `json:"webhookUrl,omitempty"`
	// The mandate used for this subscription, if any.
	MandateID *string `json:"mandateId,omitempty"`
	// Whether to create the entity in test mode or live mode.
	//
	// Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
	// omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
	// `testmode` to `true`.
	Testmode *bool `json:"testmode,omitempty"`
}

func (o *CreateSubscriptionRequestBody) GetAmount() CreateSubscriptionAmountRequest {
	if o == nil {
		return CreateSubscriptionAmountRequest{}
	}
	return o.Amount
}

func (o *CreateSubscriptionRequestBody) GetTimes() *int64 {
	if o == nil {
		return nil
	}
	return o.Times
}

func (o *CreateSubscriptionRequestBody) GetInterval() string {
	if o == nil {
		return ""
	}
	return o.Interval
}

func (o *CreateSubscriptionRequestBody) GetStartDate() *string {
	if o == nil {
		return nil
	}
	return o.StartDate
}

func (o *CreateSubscriptionRequestBody) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *CreateSubscriptionRequestBody) GetMethod() *CreateSubscriptionMethodRequest {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *CreateSubscriptionRequestBody) GetApplicationFee() *CreateSubscriptionApplicationFeeRequest {
	if o == nil {
		return nil
	}
	return o.ApplicationFee
}

func (o *CreateSubscriptionRequestBody) GetMetadata() *CreateSubscriptionMetadataRequest {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *CreateSubscriptionRequestBody) GetWebhookURL() *string {
	if o == nil {
		return nil
	}
	return o.WebhookURL
}

func (o *CreateSubscriptionRequestBody) GetMandateID() *string {
	if o == nil {
		return nil
	}
	return o.MandateID
}

func (o *CreateSubscriptionRequestBody) GetTestmode() *bool {
	if o == nil {
		return nil
	}
	return o.Testmode
}

type CreateSubscriptionRequest struct {
	// Provide the ID of the related customer.
	CustomerID  string                         `pathParam:"style=simple,explode=false,name=customerId"`
	RequestBody *CreateSubscriptionRequestBody `request:"mediaType=application/json"`
}

func (o *CreateSubscriptionRequest) GetCustomerID() string {
	if o == nil {
		return ""
	}
	return o.CustomerID
}

func (o *CreateSubscriptionRequest) GetRequestBody() *CreateSubscriptionRequestBody {
	if o == nil {
		return nil
	}
	return o.RequestBody
}

// CreateSubscriptionNotFoundDocumentation - The URL to the generic Mollie API error handling guide.
type CreateSubscriptionNotFoundDocumentation struct {
	Href string `json:"href"`
	Type string `json:"type"`
}

func (o *CreateSubscriptionNotFoundDocumentation) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateSubscriptionNotFoundDocumentation) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

type CreateSubscriptionNotFoundLinks struct {
	// The URL to the generic Mollie API error handling guide.
	Documentation CreateSubscriptionNotFoundDocumentation `json:"documentation"`
}

func (o *CreateSubscriptionNotFoundLinks) GetDocumentation() CreateSubscriptionNotFoundDocumentation {
	if o == nil {
		return CreateSubscriptionNotFoundDocumentation{}
	}
	return o.Documentation
}

// CreateSubscriptionMode - Whether this entity was created in live mode or in test mode.
type CreateSubscriptionMode string

const (
	CreateSubscriptionModeLive CreateSubscriptionMode = "live"
	CreateSubscriptionModeTest CreateSubscriptionMode = "test"
)

func (e CreateSubscriptionMode) ToPointer() *CreateSubscriptionMode {
	return &e
}
func (e *CreateSubscriptionMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "live":
		fallthrough
	case "test":
		*e = CreateSubscriptionMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateSubscriptionMode: %v", v)
	}
}

// CreateSubscriptionStatus - The subscription's current status is directly related to the status of the underlying customer or mandate that is
// enabling the subscription.
type CreateSubscriptionStatus string

const (
	CreateSubscriptionStatusPending   CreateSubscriptionStatus = "pending"
	CreateSubscriptionStatusActive    CreateSubscriptionStatus = "active"
	CreateSubscriptionStatusCanceled  CreateSubscriptionStatus = "canceled"
	CreateSubscriptionStatusSuspended CreateSubscriptionStatus = "suspended"
	CreateSubscriptionStatusCompleted CreateSubscriptionStatus = "completed"
)

func (e CreateSubscriptionStatus) ToPointer() *CreateSubscriptionStatus {
	return &e
}
func (e *CreateSubscriptionStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pending":
		fallthrough
	case "active":
		fallthrough
	case "canceled":
		fallthrough
	case "suspended":
		fallthrough
	case "completed":
		*e = CreateSubscriptionStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateSubscriptionStatus: %v", v)
	}
}

// CreateSubscriptionAmountResponse - The amount for each individual payment that is charged with this subscription. For example, for a monthly
// subscription of €10, the subscription amount should be set to €10.
type CreateSubscriptionAmountResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateSubscriptionAmountResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateSubscriptionAmountResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateSubscriptionMethodResponse - The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
type CreateSubscriptionMethodResponse string

const (
	CreateSubscriptionMethodResponseCreditcard  CreateSubscriptionMethodResponse = "creditcard"
	CreateSubscriptionMethodResponseDirectdebit CreateSubscriptionMethodResponse = "directdebit"
	CreateSubscriptionMethodResponsePaypal      CreateSubscriptionMethodResponse = "paypal"
)

func (e CreateSubscriptionMethodResponse) ToPointer() *CreateSubscriptionMethodResponse {
	return &e
}
func (e *CreateSubscriptionMethodResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "creditcard":
		fallthrough
	case "directdebit":
		fallthrough
	case "paypal":
		*e = CreateSubscriptionMethodResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateSubscriptionMethodResponse: %v", v)
	}
}

// CreateSubscriptionApplicationFeeAmountResponse - In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
type CreateSubscriptionApplicationFeeAmountResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateSubscriptionApplicationFeeAmountResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateSubscriptionApplicationFeeAmountResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateSubscriptionApplicationFeeResponse - With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
// merchants.
//
// Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
//
// Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
// information.
type CreateSubscriptionApplicationFeeResponse struct {
	// In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
	Amount      CreateSubscriptionApplicationFeeAmountResponse `json:"amount"`
	Description string                                         `json:"description"`
}

func (o *CreateSubscriptionApplicationFeeResponse) GetAmount() CreateSubscriptionApplicationFeeAmountResponse {
	if o == nil {
		return CreateSubscriptionApplicationFeeAmountResponse{}
	}
	return o.Amount
}

func (o *CreateSubscriptionApplicationFeeResponse) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

type CreateSubscriptionMetadataResponseType string

const (
	CreateSubscriptionMetadataResponseTypeStr        CreateSubscriptionMetadataResponseType = "str"
	CreateSubscriptionMetadataResponseTypeMapOfAny   CreateSubscriptionMetadataResponseType = "mapOfAny"
	CreateSubscriptionMetadataResponseTypeArrayOfStr CreateSubscriptionMetadataResponseType = "arrayOfStr"
)

// CreateSubscriptionMetadataResponse - Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
// Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
// 1kB.
//
// Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
type CreateSubscriptionMetadataResponse struct {
	Str        *string        `queryParam:"inline" name:"metadata"`
	MapOfAny   map[string]any `queryParam:"inline" name:"metadata"`
	ArrayOfStr []string       `queryParam:"inline" name:"metadata"`

	Type CreateSubscriptionMetadataResponseType
}

func CreateCreateSubscriptionMetadataResponseStr(str string) CreateSubscriptionMetadataResponse {
	typ := CreateSubscriptionMetadataResponseTypeStr

	return CreateSubscriptionMetadataResponse{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateSubscriptionMetadataResponseMapOfAny(mapOfAny map[string]any) CreateSubscriptionMetadataResponse {
	typ := CreateSubscriptionMetadataResponseTypeMapOfAny

	return CreateSubscriptionMetadataResponse{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreateCreateSubscriptionMetadataResponseArrayOfStr(arrayOfStr []string) CreateSubscriptionMetadataResponse {
	typ := CreateSubscriptionMetadataResponseTypeArrayOfStr

	return CreateSubscriptionMetadataResponse{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *CreateSubscriptionMetadataResponse) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateSubscriptionMetadataResponseTypeStr
		return nil
	}

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = CreateSubscriptionMetadataResponseTypeMapOfAny
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = CreateSubscriptionMetadataResponseTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateSubscriptionMetadataResponse", string(data))
}

func (u CreateSubscriptionMetadataResponse) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type CreateSubscriptionMetadataResponse: all fields are null")
}

// CreateSubscriptionSelf - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type CreateSubscriptionSelf struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateSubscriptionSelf) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateSubscriptionSelf) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateSubscriptionCustomer - The API resource URL of the [customer](get-customer) this subscription was created for.
type CreateSubscriptionCustomer struct {
	// The actual URL string.
	Href *string `json:"href,omitempty"`
	// The content type of the page or endpoint the URL points to.
	Type *string `json:"type,omitempty"`
}

func (o *CreateSubscriptionCustomer) GetHref() *string {
	if o == nil {
		return nil
	}
	return o.Href
}

func (o *CreateSubscriptionCustomer) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// CreateSubscriptionMandate - The API resource URL of the [mandate](get-mandate) this subscription was created for.
type CreateSubscriptionMandate struct {
	// The actual URL string.
	Href *string `json:"href,omitempty"`
	// The content type of the page or endpoint the URL points to.
	Type *string `json:"type,omitempty"`
}

func (o *CreateSubscriptionMandate) GetHref() *string {
	if o == nil {
		return nil
	}
	return o.Href
}

func (o *CreateSubscriptionMandate) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// CreateSubscriptionProfile - The API resource URL of the [profile](get-profile) this subscription was created for.
type CreateSubscriptionProfile struct {
	// The actual URL string.
	Href *string `json:"href,omitempty"`
	// The content type of the page or endpoint the URL points to.
	Type *string `json:"type,omitempty"`
}

func (o *CreateSubscriptionProfile) GetHref() *string {
	if o == nil {
		return nil
	}
	return o.Href
}

func (o *CreateSubscriptionProfile) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// CreateSubscriptionPayments - The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
// payments exist (yet).
type CreateSubscriptionPayments struct {
	// The actual URL string.
	Href *string `json:"href,omitempty"`
	// The content type of the page or endpoint the URL points to.
	Type *string `json:"type,omitempty"`
}

func (o *CreateSubscriptionPayments) GetHref() *string {
	if o == nil {
		return nil
	}
	return o.Href
}

func (o *CreateSubscriptionPayments) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// CreateSubscriptionDocumentation - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type CreateSubscriptionDocumentation struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateSubscriptionDocumentation) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateSubscriptionDocumentation) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateSubscriptionLinks - An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
type CreateSubscriptionLinks struct {
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Self CreateSubscriptionSelf `json:"self"`
	// The API resource URL of the [customer](get-customer) this subscription was created for.
	Customer *CreateSubscriptionCustomer `json:"customer"`
	// The API resource URL of the [mandate](get-mandate) this subscription was created for.
	Mandate *CreateSubscriptionMandate `json:"mandate,omitempty"`
	// The API resource URL of the [profile](get-profile) this subscription was created for.
	Profile *CreateSubscriptionProfile `json:"profile"`
	// The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
	// payments exist (yet).
	Payments *CreateSubscriptionPayments `json:"payments,omitempty"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Documentation CreateSubscriptionDocumentation `json:"documentation"`
}

func (o *CreateSubscriptionLinks) GetSelf() CreateSubscriptionSelf {
	if o == nil {
		return CreateSubscriptionSelf{}
	}
	return o.Self
}

func (o *CreateSubscriptionLinks) GetCustomer() *CreateSubscriptionCustomer {
	if o == nil {
		return nil
	}
	return o.Customer
}

func (o *CreateSubscriptionLinks) GetMandate() *CreateSubscriptionMandate {
	if o == nil {
		return nil
	}
	return o.Mandate
}

func (o *CreateSubscriptionLinks) GetProfile() *CreateSubscriptionProfile {
	if o == nil {
		return nil
	}
	return o.Profile
}

func (o *CreateSubscriptionLinks) GetPayments() *CreateSubscriptionPayments {
	if o == nil {
		return nil
	}
	return o.Payments
}

func (o *CreateSubscriptionLinks) GetDocumentation() CreateSubscriptionDocumentation {
	if o == nil {
		return CreateSubscriptionDocumentation{}
	}
	return o.Documentation
}

// CreateSubscriptionResponseBody - The newly created subscription object.
type CreateSubscriptionResponseBody struct {
	// Indicates the response contains a subscription object. Will always contain the string `subscription` for this
	// endpoint.
	Resource string `json:"resource"`
	// The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
	ID string `json:"id"`
	// Whether this entity was created in live mode or in test mode.
	Mode CreateSubscriptionMode `json:"mode"`
	// The subscription's current status is directly related to the status of the underlying customer or mandate that is
	// enabling the subscription.
	Status CreateSubscriptionStatus `json:"status"`
	// The amount for each individual payment that is charged with this subscription. For example, for a monthly
	// subscription of €10, the subscription amount should be set to €10.
	Amount CreateSubscriptionAmountResponse `json:"amount"`
	// Total number of payments for the subscription. Once this number of payments is reached, the subscription is
	// considered completed.
	//
	// Test mode subscriptions will get canceled automatically after 10 payments.
	Times *int64 `json:"times"`
	// Number of payments left for the subscription.
	TimesRemaining *int64 `json:"timesRemaining"`
	// Interval to wait between payments, for example `1 month` or `14 days`.
	//
	// The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
	//
	// Possible values: `... days`, `... weeks`, `... months`.
	Interval string `json:"interval"`
	// The start date of the subscription in `YYYY-MM-DD` format.
	StartDate string `json:"startDate"`
	// The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
	// this parameter will not be returned.
	NextPaymentDate *string `json:"nextPaymentDate,omitempty"`
	// The subscription's description will be used as the description of the resulting individual payments and so showing
	// up on the bank statement of the consumer.
	//
	// **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
	Description string `json:"description"`
	// The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
	Method *CreateSubscriptionMethodResponse `json:"method"`
	// With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
	// merchants.
	//
	// Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
	//
	// Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
	// information.
	ApplicationFee *CreateSubscriptionApplicationFeeResponse `json:"applicationFee,omitempty"`
	// Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
	// Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
	// 1kB.
	//
	// Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
	Metadata *CreateSubscriptionMetadataResponse `json:"metadata"`
	// We will call this URL for any payment status changes of payments resulting from this subscription.
	//
	// This webhook will receive **all** events for the subscription's payments. This may include payment failures as
	// well. Be sure to verify the payment's subscription ID and its status.
	WebhookURL string `json:"webhookUrl"`
	// The customer this subscription belongs to.
	CustomerID string `json:"customerId"`
	// The mandate used for this subscription, if any.
	MandateID *string `json:"mandateId,omitempty"`
	// The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
	CreatedAt string `json:"createdAt"`
	// The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
	// subscription is not canceled (yet).
	CanceledAt *string `json:"canceledAt,omitempty"`
	// An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
	Links CreateSubscriptionLinks `json:"_links"`
}

func (o *CreateSubscriptionResponseBody) GetResource() string {
	if o == nil {
		return ""
	}
	return o.Resource
}

func (o *CreateSubscriptionResponseBody) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateSubscriptionResponseBody) GetMode() CreateSubscriptionMode {
	if o == nil {
		return CreateSubscriptionMode("")
	}
	return o.Mode
}

func (o *CreateSubscriptionResponseBody) GetStatus() CreateSubscriptionStatus {
	if o == nil {
		return CreateSubscriptionStatus("")
	}
	return o.Status
}

func (o *CreateSubscriptionResponseBody) GetAmount() CreateSubscriptionAmountResponse {
	if o == nil {
		return CreateSubscriptionAmountResponse{}
	}
	return o.Amount
}

func (o *CreateSubscriptionResponseBody) GetTimes() *int64 {
	if o == nil {
		return nil
	}
	return o.Times
}

func (o *CreateSubscriptionResponseBody) GetTimesRemaining() *int64 {
	if o == nil {
		return nil
	}
	return o.TimesRemaining
}

func (o *CreateSubscriptionResponseBody) GetInterval() string {
	if o == nil {
		return ""
	}
	return o.Interval
}

func (o *CreateSubscriptionResponseBody) GetStartDate() string {
	if o == nil {
		return ""
	}
	return o.StartDate
}

func (o *CreateSubscriptionResponseBody) GetNextPaymentDate() *string {
	if o == nil {
		return nil
	}
	return o.NextPaymentDate
}

func (o *CreateSubscriptionResponseBody) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *CreateSubscriptionResponseBody) GetMethod() *CreateSubscriptionMethodResponse {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *CreateSubscriptionResponseBody) GetApplicationFee() *CreateSubscriptionApplicationFeeResponse {
	if o == nil {
		return nil
	}
	return o.ApplicationFee
}

func (o *CreateSubscriptionResponseBody) GetMetadata() *CreateSubscriptionMetadataResponse {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *CreateSubscriptionResponseBody) GetWebhookURL() string {
	if o == nil {
		return ""
	}
	return o.WebhookURL
}

func (o *CreateSubscriptionResponseBody) GetCustomerID() string {
	if o == nil {
		return ""
	}
	return o.CustomerID
}

func (o *CreateSubscriptionResponseBody) GetMandateID() *string {
	if o == nil {
		return nil
	}
	return o.MandateID
}

func (o *CreateSubscriptionResponseBody) GetCreatedAt() string {
	if o == nil {
		return ""
	}
	return o.CreatedAt
}

func (o *CreateSubscriptionResponseBody) GetCanceledAt() *string {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *CreateSubscriptionResponseBody) GetLinks() CreateSubscriptionLinks {
	if o == nil {
		return CreateSubscriptionLinks{}
	}
	return o.Links
}

type CreateSubscriptionResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// The newly created subscription object.
	Object *CreateSubscriptionResponseBody
}

func (o *CreateSubscriptionResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *CreateSubscriptionResponse) GetObject() *CreateSubscriptionResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
