// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/mollie/mollie-api-golang/internal/utils"
	"github.com/mollie/mollie-api-golang/models/components"
	"github.com/mollie/mollie-api-golang/types"
)

// ListSubscriptionPaymentsSort - Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
// newest to oldest.
type ListSubscriptionPaymentsSort string

const (
	ListSubscriptionPaymentsSortAsc  ListSubscriptionPaymentsSort = "asc"
	ListSubscriptionPaymentsSortDesc ListSubscriptionPaymentsSort = "desc"
)

func (e ListSubscriptionPaymentsSort) ToPointer() *ListSubscriptionPaymentsSort {
	return &e
}
func (e *ListSubscriptionPaymentsSort) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = ListSubscriptionPaymentsSort(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListSubscriptionPaymentsSort: %v", v)
	}
}

type ListSubscriptionPaymentsRequest struct {
	// Provide the ID of the related customer.
	CustomerID string `pathParam:"style=simple,explode=false,name=customerId"`
	// Provide the ID of the related subscription.
	SubscriptionID string `pathParam:"style=simple,explode=false,name=subscriptionId"`
	// Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate
	// the result set.
	From *string `queryParam:"style=form,explode=true,name=from"`
	// The maximum number of items to return. Defaults to 50 items.
	Limit *int64 `queryParam:"style=form,explode=true,name=limit"`
	// Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
	// newest to oldest.
	Sort *ListSubscriptionPaymentsSort `queryParam:"style=form,explode=true,name=sort"`
	// The identifier referring to the [profile](get-profile) you wish to
	// retrieve the resources for.
	//
	// Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted. For
	// organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
	ProfileID *string `queryParam:"style=form,explode=true,name=profileId"`
	// Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
	// parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
	// setting the `testmode` query parameter to `true`.
	//
	// Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
	Testmode *bool `queryParam:"style=form,explode=true,name=testmode"`
}

func (o *ListSubscriptionPaymentsRequest) GetCustomerID() string {
	if o == nil {
		return ""
	}
	return o.CustomerID
}

func (o *ListSubscriptionPaymentsRequest) GetSubscriptionID() string {
	if o == nil {
		return ""
	}
	return o.SubscriptionID
}

func (o *ListSubscriptionPaymentsRequest) GetFrom() *string {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *ListSubscriptionPaymentsRequest) GetLimit() *int64 {
	if o == nil {
		return nil
	}
	return o.Limit
}

func (o *ListSubscriptionPaymentsRequest) GetSort() *ListSubscriptionPaymentsSort {
	if o == nil {
		return nil
	}
	return o.Sort
}

func (o *ListSubscriptionPaymentsRequest) GetProfileID() *string {
	if o == nil {
		return nil
	}
	return o.ProfileID
}

func (o *ListSubscriptionPaymentsRequest) GetTestmode() *bool {
	if o == nil {
		return nil
	}
	return o.Testmode
}

// ListSubscriptionPaymentsBadRequestDocumentation - The URL to the generic Mollie API error handling guide.
type ListSubscriptionPaymentsBadRequestDocumentation struct {
	Href string `json:"href"`
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsBadRequestDocumentation) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsBadRequestDocumentation) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

type ListSubscriptionPaymentsBadRequestLinks struct {
	// The URL to the generic Mollie API error handling guide.
	Documentation ListSubscriptionPaymentsBadRequestDocumentation `json:"documentation"`
}

func (o *ListSubscriptionPaymentsBadRequestLinks) GetDocumentation() ListSubscriptionPaymentsBadRequestDocumentation {
	if o == nil {
		return ListSubscriptionPaymentsBadRequestDocumentation{}
	}
	return o.Documentation
}

// ListSubscriptionPaymentsMode - Whether this entity was created in live mode or in test mode.
type ListSubscriptionPaymentsMode string

const (
	ListSubscriptionPaymentsModeLive ListSubscriptionPaymentsMode = "live"
	ListSubscriptionPaymentsModeTest ListSubscriptionPaymentsMode = "test"
)

func (e ListSubscriptionPaymentsMode) ToPointer() *ListSubscriptionPaymentsMode {
	return &e
}

// ListSubscriptionPaymentsAmount - The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge â‚¬1000.00.
//
// You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
// retrieved using the Get method endpoint.
//
// If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
// tip amount.
type ListSubscriptionPaymentsAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsAmountRefunded - The total amount that is already refunded. Only available when refunds are available for this payment. For some
// payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
// costs for a return shipment to the customer.
type ListSubscriptionPaymentsAmountRefunded struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsAmountRefunded) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsAmountRefunded) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsAmountRemaining - The remaining amount that can be refunded. Only available when refunds are available for this payment.
type ListSubscriptionPaymentsAmountRemaining struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsAmountRemaining) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsAmountRemaining) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsAmountCaptured - The total amount that is already captured for this payment. Only available when this payment supports captures.
type ListSubscriptionPaymentsAmountCaptured struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsAmountCaptured) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsAmountCaptured) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsAmountChargedBack - The total amount that was charged back for this payment. Only available when the total charged back amount is not
// zero.
type ListSubscriptionPaymentsAmountChargedBack struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsAmountChargedBack) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsAmountChargedBack) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsSettlementAmount - This optional field will contain the approximate amount that will be settled to your account, converted to the
// currency your account is settled in.
//
// Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
// settled by Mollie the `settlementAmount` is omitted from the response.
//
// Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
// using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
type ListSubscriptionPaymentsSettlementAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsSettlementAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsSettlementAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsLineType - The type of product purchased. For example, a physical or a digital product.
//
// The `tip` payment line type is not available when creating a payment.
type ListSubscriptionPaymentsLineType string

const (
	ListSubscriptionPaymentsLineTypePhysical    ListSubscriptionPaymentsLineType = "physical"
	ListSubscriptionPaymentsLineTypeDigital     ListSubscriptionPaymentsLineType = "digital"
	ListSubscriptionPaymentsLineTypeShippingFee ListSubscriptionPaymentsLineType = "shipping_fee"
	ListSubscriptionPaymentsLineTypeDiscount    ListSubscriptionPaymentsLineType = "discount"
	ListSubscriptionPaymentsLineTypeStoreCredit ListSubscriptionPaymentsLineType = "store_credit"
	ListSubscriptionPaymentsLineTypeGiftCard    ListSubscriptionPaymentsLineType = "gift_card"
	ListSubscriptionPaymentsLineTypeSurcharge   ListSubscriptionPaymentsLineType = "surcharge"
	ListSubscriptionPaymentsLineTypeTip         ListSubscriptionPaymentsLineType = "tip"
)

func (e ListSubscriptionPaymentsLineType) ToPointer() *ListSubscriptionPaymentsLineType {
	return &e
}

// ListSubscriptionPaymentsUnitPrice - The price of a single item including VAT.
//
// For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs â‚¬89.00 each.
//
// For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
//
// The unit price can be zero in case of free items.
type ListSubscriptionPaymentsUnitPrice struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsUnitPrice) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsUnitPrice) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsDiscountAmount - Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
// type.
type ListSubscriptionPaymentsDiscountAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsDiscountAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsDiscountAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsTotalAmount - The total amount of the line, including VAT and discounts.
//
// Should match the following formula: `(unitPrice Ã— quantity) - discountAmount`.
//
// The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
type ListSubscriptionPaymentsTotalAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsTotalAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsTotalAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsVatAmount - The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
// calculated with the formula `totalAmount Ã— (vatRate / (100 + vatRate))`.
//
// Any deviations from this will result in an error.
//
// For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
// `SEK 100.00 Ã— (25 / 125) = SEK 20.00`.
type ListSubscriptionPaymentsVatAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsVatAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsVatAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type ListSubscriptionPaymentsCategory string

const (
	ListSubscriptionPaymentsCategoryMeal         ListSubscriptionPaymentsCategory = "meal"
	ListSubscriptionPaymentsCategoryEco          ListSubscriptionPaymentsCategory = "eco"
	ListSubscriptionPaymentsCategoryGift         ListSubscriptionPaymentsCategory = "gift"
	ListSubscriptionPaymentsCategorySportCulture ListSubscriptionPaymentsCategory = "sport_culture"
)

func (e ListSubscriptionPaymentsCategory) ToPointer() *ListSubscriptionPaymentsCategory {
	return &e
}

// ListSubscriptionPaymentsRecurringAmount - Total amount and currency of the recurring item.
type ListSubscriptionPaymentsRecurringAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsRecurringAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsRecurringAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsRecurring - The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
// to inform the shopper of the details for recurring products in the payments.
type ListSubscriptionPaymentsRecurring struct {
	// A description of the recurring item. If not present, the main description of the item will be used.
	Description *string `json:"description,omitempty"`
	// Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
	//
	// Possible values: `... days`, `... weeks`, `... months`.
	Interval string `json:"interval"`
	// Total amount and currency of the recurring item.
	Amount *ListSubscriptionPaymentsRecurringAmount `json:"amount,omitempty"`
	// Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
	Times *int64 `json:"times,omitempty"`
	// The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
	StartDate *string `json:"startDate,omitempty"`
}

func (o *ListSubscriptionPaymentsRecurring) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *ListSubscriptionPaymentsRecurring) GetInterval() string {
	if o == nil {
		return ""
	}
	return o.Interval
}

func (o *ListSubscriptionPaymentsRecurring) GetAmount() *ListSubscriptionPaymentsRecurringAmount {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *ListSubscriptionPaymentsRecurring) GetTimes() *int64 {
	if o == nil {
		return nil
	}
	return o.Times
}

func (o *ListSubscriptionPaymentsRecurring) GetStartDate() *string {
	if o == nil {
		return nil
	}
	return o.StartDate
}

type ListSubscriptionPaymentsLine struct {
	// The type of product purchased. For example, a physical or a digital product.
	//
	// The `tip` payment line type is not available when creating a payment.
	Type *ListSubscriptionPaymentsLineType `json:"type,omitempty"`
	// A description of the line item. For example *LEGO 4440 Forest Police Station*.
	Description string `json:"description"`
	// The number of items.
	Quantity int64 `json:"quantity"`
	// The unit for the quantity. For example *pcs*, *kg*, or *cm*.
	QuantityUnit *string `json:"quantityUnit,omitempty"`
	// The price of a single item including VAT.
	//
	// For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs â‚¬89.00 each.
	//
	// For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
	//
	// The unit price can be zero in case of free items.
	UnitPrice ListSubscriptionPaymentsUnitPrice `json:"unitPrice"`
	// Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
	// type.
	DiscountAmount *ListSubscriptionPaymentsDiscountAmount `json:"discountAmount,omitempty"`
	// The total amount of the line, including VAT and discounts.
	//
	// Should match the following formula: `(unitPrice Ã— quantity) - discountAmount`.
	//
	// The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
	TotalAmount ListSubscriptionPaymentsTotalAmount `json:"totalAmount"`
	// The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
	// not as a float, to ensure the correct number of decimals are passed.
	VatRate *string `json:"vatRate,omitempty"`
	// The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
	// calculated with the formula `totalAmount Ã— (vatRate / (100 + vatRate))`.
	//
	// Any deviations from this will result in an error.
	//
	// For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
	// `SEK 100.00 Ã— (25 / 125) = SEK 20.00`.
	VatAmount *ListSubscriptionPaymentsVatAmount `json:"vatAmount,omitempty"`
	// The SKU, EAN, ISBN or UPC of the product sold.
	Sku *string `json:"sku,omitempty"`
	// An array with the voucher categories, in case of a line eligible for a voucher. See the
	// [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
	Categories []ListSubscriptionPaymentsCategory `json:"categories,omitempty"`
	// A link pointing to an image of the product sold.
	ImageURL *string `json:"imageUrl,omitempty"`
	// A link pointing to the product page in your web shop of the product sold.
	ProductURL *string `json:"productUrl,omitempty"`
	// The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
	// to inform the shopper of the details for recurring products in the payments.
	Recurring *ListSubscriptionPaymentsRecurring `json:"recurring,omitempty"`
}

func (o *ListSubscriptionPaymentsLine) GetType() *ListSubscriptionPaymentsLineType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *ListSubscriptionPaymentsLine) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *ListSubscriptionPaymentsLine) GetQuantity() int64 {
	if o == nil {
		return 0
	}
	return o.Quantity
}

func (o *ListSubscriptionPaymentsLine) GetQuantityUnit() *string {
	if o == nil {
		return nil
	}
	return o.QuantityUnit
}

func (o *ListSubscriptionPaymentsLine) GetUnitPrice() ListSubscriptionPaymentsUnitPrice {
	if o == nil {
		return ListSubscriptionPaymentsUnitPrice{}
	}
	return o.UnitPrice
}

func (o *ListSubscriptionPaymentsLine) GetDiscountAmount() *ListSubscriptionPaymentsDiscountAmount {
	if o == nil {
		return nil
	}
	return o.DiscountAmount
}

func (o *ListSubscriptionPaymentsLine) GetTotalAmount() ListSubscriptionPaymentsTotalAmount {
	if o == nil {
		return ListSubscriptionPaymentsTotalAmount{}
	}
	return o.TotalAmount
}

func (o *ListSubscriptionPaymentsLine) GetVatRate() *string {
	if o == nil {
		return nil
	}
	return o.VatRate
}

func (o *ListSubscriptionPaymentsLine) GetVatAmount() *ListSubscriptionPaymentsVatAmount {
	if o == nil {
		return nil
	}
	return o.VatAmount
}

func (o *ListSubscriptionPaymentsLine) GetSku() *string {
	if o == nil {
		return nil
	}
	return o.Sku
}

func (o *ListSubscriptionPaymentsLine) GetCategories() []ListSubscriptionPaymentsCategory {
	if o == nil {
		return nil
	}
	return o.Categories
}

func (o *ListSubscriptionPaymentsLine) GetImageURL() *string {
	if o == nil {
		return nil
	}
	return o.ImageURL
}

func (o *ListSubscriptionPaymentsLine) GetProductURL() *string {
	if o == nil {
		return nil
	}
	return o.ProductURL
}

func (o *ListSubscriptionPaymentsLine) GetRecurring() *ListSubscriptionPaymentsRecurring {
	if o == nil {
		return nil
	}
	return o.Recurring
}

// ListSubscriptionPaymentsBillingAddress - The customer's billing address details. We advise to provide these details to improve fraud protection and
// conversion.
//
// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
// `country`.
//
// Required for payment method `in3`, `klarna`, `billie` and `riverty`.
type ListSubscriptionPaymentsBillingAddress struct {
	// The title of the person, for example *Mr.* or *Mrs.*.
	Title *string `json:"title,omitempty"`
	// The given name (first name) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	GivenName *string `json:"givenName,omitempty"`
	// The given family name (surname) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	FamilyName *string `json:"familyName,omitempty"`
	// The name of the organization, in case the addressee is an organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// A street and street number.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	StreetAndNumber *string `json:"streetAndNumber,omitempty"`
	// Any additional addressing details, for example an apartment number.
	StreetAdditional *string `json:"streetAdditional,omitempty"`
	// A postal code. This field may be required if the provided country has a postal code system.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	PostalCode *string `json:"postalCode,omitempty"`
	// A valid e-mail address.
	//
	// If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
	// email upon payment creation. The language of the email will follow the locale parameter of the payment.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Email *string `json:"email,omitempty"`
	// If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
	Phone *string `json:"phone,omitempty"`
	// A city name.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	City *string `json:"city,omitempty"`
	// The top-level administrative subdivision of the country. For example: Noord-Holland.
	Region *string `json:"region,omitempty"`
	// A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Country *string `json:"country,omitempty"`
}

func (o *ListSubscriptionPaymentsBillingAddress) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *ListSubscriptionPaymentsBillingAddress) GetGivenName() *string {
	if o == nil {
		return nil
	}
	return o.GivenName
}

func (o *ListSubscriptionPaymentsBillingAddress) GetFamilyName() *string {
	if o == nil {
		return nil
	}
	return o.FamilyName
}

func (o *ListSubscriptionPaymentsBillingAddress) GetOrganizationName() *string {
	if o == nil {
		return nil
	}
	return o.OrganizationName
}

func (o *ListSubscriptionPaymentsBillingAddress) GetStreetAndNumber() *string {
	if o == nil {
		return nil
	}
	return o.StreetAndNumber
}

func (o *ListSubscriptionPaymentsBillingAddress) GetStreetAdditional() *string {
	if o == nil {
		return nil
	}
	return o.StreetAdditional
}

func (o *ListSubscriptionPaymentsBillingAddress) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *ListSubscriptionPaymentsBillingAddress) GetEmail() *string {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *ListSubscriptionPaymentsBillingAddress) GetPhone() *string {
	if o == nil {
		return nil
	}
	return o.Phone
}

func (o *ListSubscriptionPaymentsBillingAddress) GetCity() *string {
	if o == nil {
		return nil
	}
	return o.City
}

func (o *ListSubscriptionPaymentsBillingAddress) GetRegion() *string {
	if o == nil {
		return nil
	}
	return o.Region
}

func (o *ListSubscriptionPaymentsBillingAddress) GetCountry() *string {
	if o == nil {
		return nil
	}
	return o.Country
}

// ListSubscriptionPaymentsShippingAddress - The customer's shipping address details. We advise to provide these details to improve fraud protection and
// conversion.
//
// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
// `country`.
type ListSubscriptionPaymentsShippingAddress struct {
	// The title of the person, for example *Mr.* or *Mrs.*.
	Title *string `json:"title,omitempty"`
	// The given name (first name) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	GivenName *string `json:"givenName,omitempty"`
	// The given family name (surname) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	FamilyName *string `json:"familyName,omitempty"`
	// The name of the organization, in case the addressee is an organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// A street and street number.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	StreetAndNumber *string `json:"streetAndNumber,omitempty"`
	// Any additional addressing details, for example an apartment number.
	StreetAdditional *string `json:"streetAdditional,omitempty"`
	// A postal code. This field may be required if the provided country has a postal code system.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	PostalCode *string `json:"postalCode,omitempty"`
	// A valid e-mail address.
	//
	// If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
	// email upon payment creation. The language of the email will follow the locale parameter of the payment.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Email *string `json:"email,omitempty"`
	// If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
	Phone *string `json:"phone,omitempty"`
	// A city name.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	City *string `json:"city,omitempty"`
	// The top-level administrative subdivision of the country. For example: Noord-Holland.
	Region *string `json:"region,omitempty"`
	// A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Country *string `json:"country,omitempty"`
}

func (o *ListSubscriptionPaymentsShippingAddress) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *ListSubscriptionPaymentsShippingAddress) GetGivenName() *string {
	if o == nil {
		return nil
	}
	return o.GivenName
}

func (o *ListSubscriptionPaymentsShippingAddress) GetFamilyName() *string {
	if o == nil {
		return nil
	}
	return o.FamilyName
}

func (o *ListSubscriptionPaymentsShippingAddress) GetOrganizationName() *string {
	if o == nil {
		return nil
	}
	return o.OrganizationName
}

func (o *ListSubscriptionPaymentsShippingAddress) GetStreetAndNumber() *string {
	if o == nil {
		return nil
	}
	return o.StreetAndNumber
}

func (o *ListSubscriptionPaymentsShippingAddress) GetStreetAdditional() *string {
	if o == nil {
		return nil
	}
	return o.StreetAdditional
}

func (o *ListSubscriptionPaymentsShippingAddress) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *ListSubscriptionPaymentsShippingAddress) GetEmail() *string {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *ListSubscriptionPaymentsShippingAddress) GetPhone() *string {
	if o == nil {
		return nil
	}
	return o.Phone
}

func (o *ListSubscriptionPaymentsShippingAddress) GetCity() *string {
	if o == nil {
		return nil
	}
	return o.City
}

func (o *ListSubscriptionPaymentsShippingAddress) GetRegion() *string {
	if o == nil {
		return nil
	}
	return o.Region
}

func (o *ListSubscriptionPaymentsShippingAddress) GetCountry() *string {
	if o == nil {
		return nil
	}
	return o.Country
}

// ListSubscriptionPaymentsLocale - Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
// is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
// language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
// locale, but our hosted payment pages currently only support the specified languages.
//
// For bank transfer payments specifically, the locale will determine the target bank account the customer has to
// transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
// customer use a local bank account greatly increases the conversion and speed of payment.
type ListSubscriptionPaymentsLocale string

const (
	ListSubscriptionPaymentsLocaleEnUs ListSubscriptionPaymentsLocale = "en_US"
	ListSubscriptionPaymentsLocaleEnGb ListSubscriptionPaymentsLocale = "en_GB"
	ListSubscriptionPaymentsLocaleNlNl ListSubscriptionPaymentsLocale = "nl_NL"
	ListSubscriptionPaymentsLocaleNlBe ListSubscriptionPaymentsLocale = "nl_BE"
	ListSubscriptionPaymentsLocaleDeDe ListSubscriptionPaymentsLocale = "de_DE"
	ListSubscriptionPaymentsLocaleDeAt ListSubscriptionPaymentsLocale = "de_AT"
	ListSubscriptionPaymentsLocaleDeCh ListSubscriptionPaymentsLocale = "de_CH"
	ListSubscriptionPaymentsLocaleFrFr ListSubscriptionPaymentsLocale = "fr_FR"
	ListSubscriptionPaymentsLocaleFrBe ListSubscriptionPaymentsLocale = "fr_BE"
	ListSubscriptionPaymentsLocaleEsEs ListSubscriptionPaymentsLocale = "es_ES"
	ListSubscriptionPaymentsLocaleCaEs ListSubscriptionPaymentsLocale = "ca_ES"
	ListSubscriptionPaymentsLocalePtPt ListSubscriptionPaymentsLocale = "pt_PT"
	ListSubscriptionPaymentsLocaleItIt ListSubscriptionPaymentsLocale = "it_IT"
	ListSubscriptionPaymentsLocaleNbNo ListSubscriptionPaymentsLocale = "nb_NO"
	ListSubscriptionPaymentsLocaleSvSe ListSubscriptionPaymentsLocale = "sv_SE"
	ListSubscriptionPaymentsLocaleFiFi ListSubscriptionPaymentsLocale = "fi_FI"
	ListSubscriptionPaymentsLocaleDaDk ListSubscriptionPaymentsLocale = "da_DK"
	ListSubscriptionPaymentsLocaleIsIs ListSubscriptionPaymentsLocale = "is_IS"
	ListSubscriptionPaymentsLocaleHuHu ListSubscriptionPaymentsLocale = "hu_HU"
	ListSubscriptionPaymentsLocalePlPl ListSubscriptionPaymentsLocale = "pl_PL"
	ListSubscriptionPaymentsLocaleLvLv ListSubscriptionPaymentsLocale = "lv_LV"
	ListSubscriptionPaymentsLocaleLtLt ListSubscriptionPaymentsLocale = "lt_LT"
)

func (e ListSubscriptionPaymentsLocale) ToPointer() *ListSubscriptionPaymentsLocale {
	return &e
}

// ListSubscriptionPaymentsMethod - The payment method used for this transaction. If a specific method was selected during payment initialization,
// this field reflects that choice.
type ListSubscriptionPaymentsMethod string

const (
	ListSubscriptionPaymentsMethodAlma           ListSubscriptionPaymentsMethod = "alma"
	ListSubscriptionPaymentsMethodApplepay       ListSubscriptionPaymentsMethod = "applepay"
	ListSubscriptionPaymentsMethodBacs           ListSubscriptionPaymentsMethod = "bacs"
	ListSubscriptionPaymentsMethodBancomatpay    ListSubscriptionPaymentsMethod = "bancomatpay"
	ListSubscriptionPaymentsMethodBancontact     ListSubscriptionPaymentsMethod = "bancontact"
	ListSubscriptionPaymentsMethodBanktransfer   ListSubscriptionPaymentsMethod = "banktransfer"
	ListSubscriptionPaymentsMethodBelfius        ListSubscriptionPaymentsMethod = "belfius"
	ListSubscriptionPaymentsMethodBillie         ListSubscriptionPaymentsMethod = "billie"
	ListSubscriptionPaymentsMethodBizum          ListSubscriptionPaymentsMethod = "bizum"
	ListSubscriptionPaymentsMethodBlik           ListSubscriptionPaymentsMethod = "blik"
	ListSubscriptionPaymentsMethodCreditcard     ListSubscriptionPaymentsMethod = "creditcard"
	ListSubscriptionPaymentsMethodDirectdebit    ListSubscriptionPaymentsMethod = "directdebit"
	ListSubscriptionPaymentsMethodEps            ListSubscriptionPaymentsMethod = "eps"
	ListSubscriptionPaymentsMethodGiftcard       ListSubscriptionPaymentsMethod = "giftcard"
	ListSubscriptionPaymentsMethodIdeal          ListSubscriptionPaymentsMethod = "ideal"
	ListSubscriptionPaymentsMethodIn3            ListSubscriptionPaymentsMethod = "in3"
	ListSubscriptionPaymentsMethodKbc            ListSubscriptionPaymentsMethod = "kbc"
	ListSubscriptionPaymentsMethodKlarna         ListSubscriptionPaymentsMethod = "klarna"
	ListSubscriptionPaymentsMethodKlarnapaylater ListSubscriptionPaymentsMethod = "klarnapaylater"
	ListSubscriptionPaymentsMethodKlarnapaynow   ListSubscriptionPaymentsMethod = "klarnapaynow"
	ListSubscriptionPaymentsMethodKlarnasliceit  ListSubscriptionPaymentsMethod = "klarnasliceit"
	ListSubscriptionPaymentsMethodMbway          ListSubscriptionPaymentsMethod = "mbway"
	ListSubscriptionPaymentsMethodMultibanco     ListSubscriptionPaymentsMethod = "multibanco"
	ListSubscriptionPaymentsMethodMybank         ListSubscriptionPaymentsMethod = "mybank"
	ListSubscriptionPaymentsMethodPaybybank      ListSubscriptionPaymentsMethod = "paybybank"
	ListSubscriptionPaymentsMethodPayconiq       ListSubscriptionPaymentsMethod = "payconiq"
	ListSubscriptionPaymentsMethodPaypal         ListSubscriptionPaymentsMethod = "paypal"
	ListSubscriptionPaymentsMethodPaysafecard    ListSubscriptionPaymentsMethod = "paysafecard"
	ListSubscriptionPaymentsMethodPointofsale    ListSubscriptionPaymentsMethod = "pointofsale"
	ListSubscriptionPaymentsMethodPrzelewy24     ListSubscriptionPaymentsMethod = "przelewy24"
	ListSubscriptionPaymentsMethodRiverty        ListSubscriptionPaymentsMethod = "riverty"
	ListSubscriptionPaymentsMethodSatispay       ListSubscriptionPaymentsMethod = "satispay"
	ListSubscriptionPaymentsMethodSwish          ListSubscriptionPaymentsMethod = "swish"
	ListSubscriptionPaymentsMethodTrustly        ListSubscriptionPaymentsMethod = "trustly"
	ListSubscriptionPaymentsMethodTwint          ListSubscriptionPaymentsMethod = "twint"
	ListSubscriptionPaymentsMethodVoucher        ListSubscriptionPaymentsMethod = "voucher"
)

func (e ListSubscriptionPaymentsMethod) ToPointer() *ListSubscriptionPaymentsMethod {
	return &e
}

type ListSubscriptionPaymentsMetadataType string

const (
	ListSubscriptionPaymentsMetadataTypeStr        ListSubscriptionPaymentsMetadataType = "str"
	ListSubscriptionPaymentsMetadataTypeMapOfAny   ListSubscriptionPaymentsMetadataType = "mapOfAny"
	ListSubscriptionPaymentsMetadataTypeArrayOfStr ListSubscriptionPaymentsMetadataType = "arrayOfStr"
)

// ListSubscriptionPaymentsMetadata - Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
// you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
type ListSubscriptionPaymentsMetadata struct {
	Str        *string        `queryParam:"inline"`
	MapOfAny   map[string]any `queryParam:"inline"`
	ArrayOfStr []string       `queryParam:"inline"`

	Type ListSubscriptionPaymentsMetadataType
}

func CreateListSubscriptionPaymentsMetadataStr(str string) ListSubscriptionPaymentsMetadata {
	typ := ListSubscriptionPaymentsMetadataTypeStr

	return ListSubscriptionPaymentsMetadata{
		Str:  &str,
		Type: typ,
	}
}

func CreateListSubscriptionPaymentsMetadataMapOfAny(mapOfAny map[string]any) ListSubscriptionPaymentsMetadata {
	typ := ListSubscriptionPaymentsMetadataTypeMapOfAny

	return ListSubscriptionPaymentsMetadata{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreateListSubscriptionPaymentsMetadataArrayOfStr(arrayOfStr []string) ListSubscriptionPaymentsMetadata {
	typ := ListSubscriptionPaymentsMetadataTypeArrayOfStr

	return ListSubscriptionPaymentsMetadata{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *ListSubscriptionPaymentsMetadata) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ListSubscriptionPaymentsMetadataTypeStr
		return nil
	}

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = ListSubscriptionPaymentsMetadataTypeMapOfAny
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = ListSubscriptionPaymentsMetadataTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListSubscriptionPaymentsMetadata", string(data))
}

func (u ListSubscriptionPaymentsMetadata) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type ListSubscriptionPaymentsMetadata: all fields are null")
}

// ListSubscriptionPaymentsCaptureMode - Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
// and capture at a later time.
//
// This field needs to be set to `manual` for method `riverty`.
type ListSubscriptionPaymentsCaptureMode string

const (
	ListSubscriptionPaymentsCaptureModeAutomatic ListSubscriptionPaymentsCaptureMode = "automatic"
	ListSubscriptionPaymentsCaptureModeManual    ListSubscriptionPaymentsCaptureMode = "manual"
)

func (e ListSubscriptionPaymentsCaptureMode) ToPointer() *ListSubscriptionPaymentsCaptureMode {
	return &e
}

// ListSubscriptionPaymentsApplicationFeeAmount - The fee that you wish to charge.
//
// Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
// a â‚¬0.99 fee on a â‚¬1.00 payment.
type ListSubscriptionPaymentsApplicationFeeAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsApplicationFeeAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsApplicationFeeAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsApplicationFee - With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
// merchants.
//
// If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
// `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
// to your own account balance.
//
// If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
// `routing` parameter.
type ListSubscriptionPaymentsApplicationFee struct {
	// The fee that you wish to charge.
	//
	// Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
	// a â‚¬0.99 fee on a â‚¬1.00 payment.
	Amount *ListSubscriptionPaymentsApplicationFeeAmount `json:"amount,omitempty"`
	// The description of the application fee. This will appear on settlement reports towards both you and the
	// connected merchant.
	Description *string `json:"description,omitempty"`
}

func (o *ListSubscriptionPaymentsApplicationFee) GetAmount() *ListSubscriptionPaymentsApplicationFeeAmount {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *ListSubscriptionPaymentsApplicationFee) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

// ListSubscriptionPaymentsRoutingMode - Whether this entity was created in live mode or in test mode.
type ListSubscriptionPaymentsRoutingMode string

const (
	ListSubscriptionPaymentsRoutingModeLive ListSubscriptionPaymentsRoutingMode = "live"
	ListSubscriptionPaymentsRoutingModeTest ListSubscriptionPaymentsRoutingMode = "test"
)

func (e ListSubscriptionPaymentsRoutingMode) ToPointer() *ListSubscriptionPaymentsRoutingMode {
	return &e
}

// ListSubscriptionPaymentsRoutingAmount - The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
type ListSubscriptionPaymentsRoutingAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsRoutingAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsRoutingAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsDestinationType - The type of destination. Currently only the destination type `organization` is supported.
type ListSubscriptionPaymentsDestinationType string

const (
	ListSubscriptionPaymentsDestinationTypeOrganization ListSubscriptionPaymentsDestinationType = "organization"
)

func (e ListSubscriptionPaymentsDestinationType) ToPointer() *ListSubscriptionPaymentsDestinationType {
	return &e
}

// ListSubscriptionPaymentsDestination - The destination of this portion of the payment.
type ListSubscriptionPaymentsDestination struct {
	// The type of destination. Currently only the destination type `organization` is supported.
	Type ListSubscriptionPaymentsDestinationType `json:"type"`
	// Required for destination type `organization`. The ID of the connected organization the funds should be
	// routed to.
	OrganizationID string `json:"organizationId"`
}

func (o *ListSubscriptionPaymentsDestination) GetType() ListSubscriptionPaymentsDestinationType {
	if o == nil {
		return ListSubscriptionPaymentsDestinationType("")
	}
	return o.Type
}

func (o *ListSubscriptionPaymentsDestination) GetOrganizationID() string {
	if o == nil {
		return ""
	}
	return o.OrganizationID
}

// ListSubscriptionPaymentsRoutingSelf - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type ListSubscriptionPaymentsRoutingSelf struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsRoutingSelf) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsRoutingSelf) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsRoutingPayment - The API resource URL of the [payment](get-payment) that belong to this route.
type ListSubscriptionPaymentsRoutingPayment struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsRoutingPayment) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsRoutingPayment) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsRoutingLinks - An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
type ListSubscriptionPaymentsRoutingLinks struct {
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Self ListSubscriptionPaymentsRoutingSelf `json:"self"`
	// The API resource URL of the [payment](get-payment) that belong to this route.
	Payment ListSubscriptionPaymentsRoutingPayment `json:"payment"`
}

func (o *ListSubscriptionPaymentsRoutingLinks) GetSelf() ListSubscriptionPaymentsRoutingSelf {
	if o == nil {
		return ListSubscriptionPaymentsRoutingSelf{}
	}
	return o.Self
}

func (o *ListSubscriptionPaymentsRoutingLinks) GetPayment() ListSubscriptionPaymentsRoutingPayment {
	if o == nil {
		return ListSubscriptionPaymentsRoutingPayment{}
	}
	return o.Payment
}

type ListSubscriptionPaymentsRouting struct {
	// Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
	Resource string `json:"resource"`
	// The identifier uniquely referring to this route. Mollie will always refer to the route by this ID.
	// Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
	ID string `json:"id"`
	// Whether this entity was created in live mode or in test mode.
	Mode ListSubscriptionPaymentsRoutingMode `json:"mode"`
	// The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
	Amount ListSubscriptionPaymentsRoutingAmount `json:"amount"`
	// The destination of this portion of the payment.
	Destination ListSubscriptionPaymentsDestination `json:"destination"`
	// The date and time when the route was created. The date is given in ISO 8601 format.
	CreatedAt string `json:"createdAt"`
	// Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
	// date must be given in `YYYY-MM-DD` format.
	//
	// If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
	ReleaseDate *string `json:"releaseDate,omitempty"`
	// An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
	Links ListSubscriptionPaymentsRoutingLinks `json:"_links"`
}

func (o *ListSubscriptionPaymentsRouting) GetResource() string {
	if o == nil {
		return ""
	}
	return o.Resource
}

func (o *ListSubscriptionPaymentsRouting) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ListSubscriptionPaymentsRouting) GetMode() ListSubscriptionPaymentsRoutingMode {
	if o == nil {
		return ListSubscriptionPaymentsRoutingMode("")
	}
	return o.Mode
}

func (o *ListSubscriptionPaymentsRouting) GetAmount() ListSubscriptionPaymentsRoutingAmount {
	if o == nil {
		return ListSubscriptionPaymentsRoutingAmount{}
	}
	return o.Amount
}

func (o *ListSubscriptionPaymentsRouting) GetDestination() ListSubscriptionPaymentsDestination {
	if o == nil {
		return ListSubscriptionPaymentsDestination{}
	}
	return o.Destination
}

func (o *ListSubscriptionPaymentsRouting) GetCreatedAt() string {
	if o == nil {
		return ""
	}
	return o.CreatedAt
}

func (o *ListSubscriptionPaymentsRouting) GetReleaseDate() *string {
	if o == nil {
		return nil
	}
	return o.ReleaseDate
}

func (o *ListSubscriptionPaymentsRouting) GetLinks() ListSubscriptionPaymentsRoutingLinks {
	if o == nil {
		return ListSubscriptionPaymentsRoutingLinks{}
	}
	return o.Links
}

// ListSubscriptionPaymentsSequenceType - **Only relevant for recurring payments.**
//
// Indicate which part of a recurring sequence this payment is for.
//
// Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
// through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
// on their account in the future.
//
// If set to `recurring`, the customer's card is charged automatically.
//
// Defaults to `oneoff`, which is a regular non-recurring payment.
//
// For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
// [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
// are set up correctly for recurring payments.
type ListSubscriptionPaymentsSequenceType string

const (
	ListSubscriptionPaymentsSequenceTypeOneoff    ListSubscriptionPaymentsSequenceType = "oneoff"
	ListSubscriptionPaymentsSequenceTypeFirst     ListSubscriptionPaymentsSequenceType = "first"
	ListSubscriptionPaymentsSequenceTypeRecurring ListSubscriptionPaymentsSequenceType = "recurring"
)

func (e ListSubscriptionPaymentsSequenceType) ToPointer() *ListSubscriptionPaymentsSequenceType {
	return &e
}

// ListSubscriptionPaymentsStatusEnum - The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
// statuses occur at what point.
type ListSubscriptionPaymentsStatusEnum string

const (
	ListSubscriptionPaymentsStatusEnumOpen       ListSubscriptionPaymentsStatusEnum = "open"
	ListSubscriptionPaymentsStatusEnumPending    ListSubscriptionPaymentsStatusEnum = "pending"
	ListSubscriptionPaymentsStatusEnumAuthorized ListSubscriptionPaymentsStatusEnum = "authorized"
	ListSubscriptionPaymentsStatusEnumPaid       ListSubscriptionPaymentsStatusEnum = "paid"
	ListSubscriptionPaymentsStatusEnumCanceled   ListSubscriptionPaymentsStatusEnum = "canceled"
	ListSubscriptionPaymentsStatusEnumExpired    ListSubscriptionPaymentsStatusEnum = "expired"
	ListSubscriptionPaymentsStatusEnumFailed     ListSubscriptionPaymentsStatusEnum = "failed"
)

func (e ListSubscriptionPaymentsStatusEnum) ToPointer() *ListSubscriptionPaymentsStatusEnum {
	return &e
}

// ListSubscriptionPaymentsCode - A machine-readable code that indicates the reason for the payment's status.
type ListSubscriptionPaymentsCode string

const (
	ListSubscriptionPaymentsCodeApprovedOrCompletedSuccessfully             ListSubscriptionPaymentsCode = "approved_or_completed_successfully"
	ListSubscriptionPaymentsCodeReferToCardIssuer                           ListSubscriptionPaymentsCode = "refer_to_card_issuer"
	ListSubscriptionPaymentsCodeInvalidMerchant                             ListSubscriptionPaymentsCode = "invalid_merchant"
	ListSubscriptionPaymentsCodeCaptureCard                                 ListSubscriptionPaymentsCode = "capture_card"
	ListSubscriptionPaymentsCodeDoNotHonor                                  ListSubscriptionPaymentsCode = "do_not_honor"
	ListSubscriptionPaymentsCodeError                                       ListSubscriptionPaymentsCode = "error"
	ListSubscriptionPaymentsCodePartialApproval                             ListSubscriptionPaymentsCode = "partial_approval"
	ListSubscriptionPaymentsCodeInvalidTransaction                          ListSubscriptionPaymentsCode = "invalid_transaction"
	ListSubscriptionPaymentsCodeInvalidAmount                               ListSubscriptionPaymentsCode = "invalid_amount"
	ListSubscriptionPaymentsCodeInvalidIssuer                               ListSubscriptionPaymentsCode = "invalid_issuer"
	ListSubscriptionPaymentsCodeLostCard                                    ListSubscriptionPaymentsCode = "lost_card"
	ListSubscriptionPaymentsCodeStolenCard                                  ListSubscriptionPaymentsCode = "stolen_card"
	ListSubscriptionPaymentsCodeInsufficientFunds                           ListSubscriptionPaymentsCode = "insufficient_funds"
	ListSubscriptionPaymentsCodeExpiredCard                                 ListSubscriptionPaymentsCode = "expired_card"
	ListSubscriptionPaymentsCodeInvalidPin                                  ListSubscriptionPaymentsCode = "invalid_pin"
	ListSubscriptionPaymentsCodeTransactionNotPermittedToCardholder         ListSubscriptionPaymentsCode = "transaction_not_permitted_to_cardholder"
	ListSubscriptionPaymentsCodeTransactionNotAllowedAtTerminal             ListSubscriptionPaymentsCode = "transaction_not_allowed_at_terminal"
	ListSubscriptionPaymentsCodeExceedsWithdrawalAmountLimit                ListSubscriptionPaymentsCode = "exceeds_withdrawal_amount_limit"
	ListSubscriptionPaymentsCodeRestrictedCard                              ListSubscriptionPaymentsCode = "restricted_card"
	ListSubscriptionPaymentsCodeSecurityViolation                           ListSubscriptionPaymentsCode = "security_violation"
	ListSubscriptionPaymentsCodeExceedsWithdrawalCountLimit                 ListSubscriptionPaymentsCode = "exceeds_withdrawal_count_limit"
	ListSubscriptionPaymentsCodeAllowableNumberOfPinTriesExceeded           ListSubscriptionPaymentsCode = "allowable_number_of_pin_tries_exceeded"
	ListSubscriptionPaymentsCodeNoReasonToDecline                           ListSubscriptionPaymentsCode = "no_reason_to_decline"
	ListSubscriptionPaymentsCodeCannotVerifyPin                             ListSubscriptionPaymentsCode = "cannot_verify_pin"
	ListSubscriptionPaymentsCodeIssuerUnavailable                           ListSubscriptionPaymentsCode = "issuer_unavailable"
	ListSubscriptionPaymentsCodeUnableToRouteTransaction                    ListSubscriptionPaymentsCode = "unable_to_route_transaction"
	ListSubscriptionPaymentsCodeDuplicateTransaction                        ListSubscriptionPaymentsCode = "duplicate_transaction"
	ListSubscriptionPaymentsCodeSystemMalfunction                           ListSubscriptionPaymentsCode = "system_malfunction"
	ListSubscriptionPaymentsCodeHonorWithID                                 ListSubscriptionPaymentsCode = "honor_with_id"
	ListSubscriptionPaymentsCodeInvalidCardNumber                           ListSubscriptionPaymentsCode = "invalid_card_number"
	ListSubscriptionPaymentsCodeFormatError                                 ListSubscriptionPaymentsCode = "format_error"
	ListSubscriptionPaymentsCodeContactCardIssuer                           ListSubscriptionPaymentsCode = "contact_card_issuer"
	ListSubscriptionPaymentsCodePinNotChanged                               ListSubscriptionPaymentsCode = "pin_not_changed"
	ListSubscriptionPaymentsCodeInvalidNonexistentToAccountSpecified        ListSubscriptionPaymentsCode = "invalid_nonexistent_to_account_specified"
	ListSubscriptionPaymentsCodeInvalidNonexistentFromAccountSpecified      ListSubscriptionPaymentsCode = "invalid_nonexistent_from_account_specified"
	ListSubscriptionPaymentsCodeInvalidNonexistentAccountSpecified          ListSubscriptionPaymentsCode = "invalid_nonexistent_account_specified"
	ListSubscriptionPaymentsCodeLifecycleRelated                            ListSubscriptionPaymentsCode = "lifecycle_related"
	ListSubscriptionPaymentsCodeDomesticDebitTransactionNotAllowed          ListSubscriptionPaymentsCode = "domestic_debit_transaction_not_allowed"
	ListSubscriptionPaymentsCodePolicyRelated                               ListSubscriptionPaymentsCode = "policy_related"
	ListSubscriptionPaymentsCodeFraudSecurityRelated                        ListSubscriptionPaymentsCode = "fraud_security_related"
	ListSubscriptionPaymentsCodeInvalidAuthorizationLifeCycle               ListSubscriptionPaymentsCode = "invalid_authorization_life_cycle"
	ListSubscriptionPaymentsCodePurchaseAmountOnlyNoCashBackAllowed         ListSubscriptionPaymentsCode = "purchase_amount_only_no_cash_back_allowed"
	ListSubscriptionPaymentsCodeCryptographicFailure                        ListSubscriptionPaymentsCode = "cryptographic_failure"
	ListSubscriptionPaymentsCodeUnacceptablePin                             ListSubscriptionPaymentsCode = "unacceptable_pin"
	ListSubscriptionPaymentsCodeReferToCardIssuerSpecialCondition           ListSubscriptionPaymentsCode = "refer_to_card_issuer_special_condition"
	ListSubscriptionPaymentsCodePickUpCardSpecialCondition                  ListSubscriptionPaymentsCode = "pick_up_card_special_condition"
	ListSubscriptionPaymentsCodeVipApproval                                 ListSubscriptionPaymentsCode = "vip_approval"
	ListSubscriptionPaymentsCodeInvalidAccountNumber                        ListSubscriptionPaymentsCode = "invalid_account_number"
	ListSubscriptionPaymentsCodeReEnterTransaction                          ListSubscriptionPaymentsCode = "re_enter_transaction"
	ListSubscriptionPaymentsCodeNoActionTaken                               ListSubscriptionPaymentsCode = "no_action_taken"
	ListSubscriptionPaymentsCodeUnableToLocateRecord                        ListSubscriptionPaymentsCode = "unable_to_locate_record"
	ListSubscriptionPaymentsCodeFileTemporarilyUnavailable                  ListSubscriptionPaymentsCode = "file_temporarily_unavailable"
	ListSubscriptionPaymentsCodeNoCreditAccount                             ListSubscriptionPaymentsCode = "no_credit_account"
	ListSubscriptionPaymentsCodeClosedAccount                               ListSubscriptionPaymentsCode = "closed_account"
	ListSubscriptionPaymentsCodeNoCheckingAccount                           ListSubscriptionPaymentsCode = "no_checking_account"
	ListSubscriptionPaymentsCodeNoSavingsAccount                            ListSubscriptionPaymentsCode = "no_savings_account"
	ListSubscriptionPaymentsCodeSuspectedFraud                              ListSubscriptionPaymentsCode = "suspected_fraud"
	ListSubscriptionPaymentsCodeTransactionDoesNotFulfillAmlRequirement     ListSubscriptionPaymentsCode = "transaction_does_not_fulfill_aml_requirement"
	ListSubscriptionPaymentsCodePinDataRequired                             ListSubscriptionPaymentsCode = "pin_data_required"
	ListSubscriptionPaymentsCodeUnableToLocatePreviousMessage               ListSubscriptionPaymentsCode = "unable_to_locate_previous_message"
	ListSubscriptionPaymentsCodePreviousMessageLocatedInconsistentData      ListSubscriptionPaymentsCode = "previous_message_located_inconsistent_data"
	ListSubscriptionPaymentsCodeBlockedFirstUsed                            ListSubscriptionPaymentsCode = "blocked_first_used"
	ListSubscriptionPaymentsCodeTransactionReversed                         ListSubscriptionPaymentsCode = "transaction_reversed"
	ListSubscriptionPaymentsCodeCreditIssuerUnavailable                     ListSubscriptionPaymentsCode = "credit_issuer_unavailable"
	ListSubscriptionPaymentsCodePinCryptographicErrorFound                  ListSubscriptionPaymentsCode = "pin_cryptographic_error_found"
	ListSubscriptionPaymentsCodeNegativeOnlineCamResult                     ListSubscriptionPaymentsCode = "negative_online_cam_result"
	ListSubscriptionPaymentsCodeViolationOfLaw                              ListSubscriptionPaymentsCode = "violation_of_law"
	ListSubscriptionPaymentsCodeForceStip                                   ListSubscriptionPaymentsCode = "force_stip"
	ListSubscriptionPaymentsCodeCashServiceNotAvailable                     ListSubscriptionPaymentsCode = "cash_service_not_available"
	ListSubscriptionPaymentsCodeCashbackRequestExceedsIssuerLimit           ListSubscriptionPaymentsCode = "cashback_request_exceeds_issuer_limit"
	ListSubscriptionPaymentsCodeDeclineForCvv2Failure                       ListSubscriptionPaymentsCode = "decline_for_cvv2_failure"
	ListSubscriptionPaymentsCodeTransactionAmountExceedsPreAuthorizedAmount ListSubscriptionPaymentsCode = "transaction_amount_exceeds_pre_authorized_amount"
	ListSubscriptionPaymentsCodeInvalidBillerInformation                    ListSubscriptionPaymentsCode = "invalid_biller_information"
	ListSubscriptionPaymentsCodePinChangeUnblockRequestDeclined             ListSubscriptionPaymentsCode = "pin_change_unblock_request_declined"
	ListSubscriptionPaymentsCodeUnsafePin                                   ListSubscriptionPaymentsCode = "unsafe_pin"
	ListSubscriptionPaymentsCodeCardAuthenticationFailed                    ListSubscriptionPaymentsCode = "card_authentication_failed"
	ListSubscriptionPaymentsCodeStopPaymentOrder                            ListSubscriptionPaymentsCode = "stop_payment_order"
	ListSubscriptionPaymentsCodeRevocationOfAuthorization                   ListSubscriptionPaymentsCode = "revocation_of_authorization"
	ListSubscriptionPaymentsCodeRevocationOfAllAuthorizations               ListSubscriptionPaymentsCode = "revocation_of_all_authorizations"
	ListSubscriptionPaymentsCodeForwardToIssuerXa                           ListSubscriptionPaymentsCode = "forward_to_issuer_xa"
	ListSubscriptionPaymentsCodeForwardToIssuerXd                           ListSubscriptionPaymentsCode = "forward_to_issuer_xd"
	ListSubscriptionPaymentsCodeUnableToGoOnline                            ListSubscriptionPaymentsCode = "unable_to_go_online"
	ListSubscriptionPaymentsCodeAdditionalCustomerAuthenticationRequired    ListSubscriptionPaymentsCode = "additional_customer_authentication_required"
	ListSubscriptionPaymentsCodeMerchantIDNotFound                          ListSubscriptionPaymentsCode = "merchant_id_not_found"
	ListSubscriptionPaymentsCodeMerchantAccountClosed                       ListSubscriptionPaymentsCode = "merchant_account_closed"
	ListSubscriptionPaymentsCodeTerminalIDNotFound                          ListSubscriptionPaymentsCode = "terminal_id_not_found"
	ListSubscriptionPaymentsCodeTerminalClosed                              ListSubscriptionPaymentsCode = "terminal_closed"
	ListSubscriptionPaymentsCodeInvalidCategoryCode                         ListSubscriptionPaymentsCode = "invalid_category_code"
	ListSubscriptionPaymentsCodeInvalidCurrency                             ListSubscriptionPaymentsCode = "invalid_currency"
	ListSubscriptionPaymentsCodeMissingCvv2Cvc2                             ListSubscriptionPaymentsCode = "missing_cvv2_cvc2"
	ListSubscriptionPaymentsCodeCvv2NotAllowed                              ListSubscriptionPaymentsCode = "cvv2_not_allowed"
	ListSubscriptionPaymentsCodeMerchantNotRegisteredVbv                    ListSubscriptionPaymentsCode = "merchant_not_registered_vbv"
	ListSubscriptionPaymentsCodeMerchantNotRegisteredForAmex                ListSubscriptionPaymentsCode = "merchant_not_registered_for_amex"
	ListSubscriptionPaymentsCodeTransactionNotPermittedAtTerminal           ListSubscriptionPaymentsCode = "transaction_not_permitted_at_terminal"
	ListSubscriptionPaymentsCodeAgreementTerminalNotRelated                 ListSubscriptionPaymentsCode = "agreement_terminal_not_related"
	ListSubscriptionPaymentsCodeInvalidProcessorID                          ListSubscriptionPaymentsCode = "invalid_processor_id"
	ListSubscriptionPaymentsCodeInvalidMerchantData                         ListSubscriptionPaymentsCode = "invalid_merchant_data"
	ListSubscriptionPaymentsCodeSubMerchantAccountClosed                    ListSubscriptionPaymentsCode = "sub_merchant_account_closed"
	ListSubscriptionPaymentsCodeTerminalBusy                                ListSubscriptionPaymentsCode = "terminal_busy"
	ListSubscriptionPaymentsCodeTerminalUnreachable                         ListSubscriptionPaymentsCode = "terminal_unreachable"
	ListSubscriptionPaymentsCodeServiceFailed                               ListSubscriptionPaymentsCode = "service_failed"
	ListSubscriptionPaymentsCodeInvalidOperation                            ListSubscriptionPaymentsCode = "invalid_operation"
	ListSubscriptionPaymentsCodeAuthorizationError                          ListSubscriptionPaymentsCode = "authorization_error"
	ListSubscriptionPaymentsCodeLoginFailedWithoutReason                    ListSubscriptionPaymentsCode = "login_failed_without_reason"
	ListSubscriptionPaymentsCodeInvalidRetailer                             ListSubscriptionPaymentsCode = "invalid_retailer"
	ListSubscriptionPaymentsCodeCardDoesNotExist                            ListSubscriptionPaymentsCode = "card_does_not_exist"
	ListSubscriptionPaymentsCodeCardIsBlocked                               ListSubscriptionPaymentsCode = "card_is_blocked"
	ListSubscriptionPaymentsCodeInvalidCardID                               ListSubscriptionPaymentsCode = "invalid_card_id"
	ListSubscriptionPaymentsCodeCardIsTransferred                           ListSubscriptionPaymentsCode = "card_is_transferred"
	ListSubscriptionPaymentsCodeCardIsNotActive                             ListSubscriptionPaymentsCode = "card_is_not_active"
	ListSubscriptionPaymentsCodeIncorrectPurchaseValue                      ListSubscriptionPaymentsCode = "incorrect_purchase_value"
	ListSubscriptionPaymentsCodeCardNotAvailable                            ListSubscriptionPaymentsCode = "card_not_available"
	ListSubscriptionPaymentsCodeWrongCurrency                               ListSubscriptionPaymentsCode = "wrong_currency"
	ListSubscriptionPaymentsCodeLoginFailedUnknownUser                      ListSubscriptionPaymentsCode = "login_failed_unknown_user"
	ListSubscriptionPaymentsCodeLoginFailedInvalidPassword                  ListSubscriptionPaymentsCode = "login_failed_invalid_password"
	ListSubscriptionPaymentsCodeInvalidEanCode                              ListSubscriptionPaymentsCode = "invalid_ean_code"
)

func (e ListSubscriptionPaymentsCode) ToPointer() *ListSubscriptionPaymentsCode {
	return &e
}

// ListSubscriptionPaymentsStatusReason - This object offers details about the status of a payment. Currently it is only available for point-of-sale
// payments.
//
// You can find more information about the possible values of this object on
// [this page](status-reasons).**
type ListSubscriptionPaymentsStatusReason struct {
	Code ListSubscriptionPaymentsCode `json:"code"`
	// A description of the status reason, localized according to the payment `locale`.
	Message string `json:"message"`
}

func (o *ListSubscriptionPaymentsStatusReason) GetCode() ListSubscriptionPaymentsCode {
	if o == nil {
		return ListSubscriptionPaymentsCode("")
	}
	return o.Code
}

func (o *ListSubscriptionPaymentsStatusReason) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

// ListSubscriptionPaymentsCardAudition - The card's target audience, if known.
type ListSubscriptionPaymentsCardAudition string

const (
	ListSubscriptionPaymentsCardAuditionConsumer ListSubscriptionPaymentsCardAudition = "consumer"
	ListSubscriptionPaymentsCardAuditionBusiness ListSubscriptionPaymentsCardAudition = "business"
)

func (e ListSubscriptionPaymentsCardAudition) ToPointer() *ListSubscriptionPaymentsCardAudition {
	return &e
}

// ListSubscriptionPaymentsCardLabel - The card's label, if known.
type ListSubscriptionPaymentsCardLabel string

const (
	ListSubscriptionPaymentsCardLabelAmericanExpress ListSubscriptionPaymentsCardLabel = "American Express"
	ListSubscriptionPaymentsCardLabelCartaSi         ListSubscriptionPaymentsCardLabel = "Carta Si"
	ListSubscriptionPaymentsCardLabelCarteBleue      ListSubscriptionPaymentsCardLabel = "Carte Bleue"
	ListSubscriptionPaymentsCardLabelDankort         ListSubscriptionPaymentsCardLabel = "Dankort"
	ListSubscriptionPaymentsCardLabelDinersClub      ListSubscriptionPaymentsCardLabel = "Diners Club"
	ListSubscriptionPaymentsCardLabelDiscover        ListSubscriptionPaymentsCardLabel = "Discover"
	ListSubscriptionPaymentsCardLabelJcb             ListSubscriptionPaymentsCardLabel = "JCB"
	ListSubscriptionPaymentsCardLabelLaser           ListSubscriptionPaymentsCardLabel = "Laser"
	ListSubscriptionPaymentsCardLabelMaestro         ListSubscriptionPaymentsCardLabel = "Maestro"
	ListSubscriptionPaymentsCardLabelMastercard      ListSubscriptionPaymentsCardLabel = "Mastercard"
	ListSubscriptionPaymentsCardLabelUnionpay        ListSubscriptionPaymentsCardLabel = "Unionpay"
	ListSubscriptionPaymentsCardLabelVisa            ListSubscriptionPaymentsCardLabel = "Visa"
	ListSubscriptionPaymentsCardLabelVpay            ListSubscriptionPaymentsCardLabel = "Vpay"
)

func (e ListSubscriptionPaymentsCardLabel) ToPointer() *ListSubscriptionPaymentsCardLabel {
	return &e
}

// ListSubscriptionPaymentsCardFunding - The card type.
type ListSubscriptionPaymentsCardFunding string

const (
	ListSubscriptionPaymentsCardFundingDebit         ListSubscriptionPaymentsCardFunding = "debit"
	ListSubscriptionPaymentsCardFundingCredit        ListSubscriptionPaymentsCardFunding = "credit"
	ListSubscriptionPaymentsCardFundingPrepaid       ListSubscriptionPaymentsCardFunding = "prepaid"
	ListSubscriptionPaymentsCardFundingDeferredDebit ListSubscriptionPaymentsCardFunding = "deferred-debit"
)

func (e ListSubscriptionPaymentsCardFunding) ToPointer() *ListSubscriptionPaymentsCardFunding {
	return &e
}

// ListSubscriptionPaymentsCardSecurity - The level of security applied during card processing.
type ListSubscriptionPaymentsCardSecurity string

const (
	ListSubscriptionPaymentsCardSecurityNormal       ListSubscriptionPaymentsCardSecurity = "normal"
	ListSubscriptionPaymentsCardSecurityThreedsecure ListSubscriptionPaymentsCardSecurity = "3dsecure"
)

func (e ListSubscriptionPaymentsCardSecurity) ToPointer() *ListSubscriptionPaymentsCardSecurity {
	return &e
}

// ListSubscriptionPaymentsFeeRegion - The applicable card fee region.
type ListSubscriptionPaymentsFeeRegion string

const (
	ListSubscriptionPaymentsFeeRegionAmericanExpress  ListSubscriptionPaymentsFeeRegion = "american-express"
	ListSubscriptionPaymentsFeeRegionAmexIntraEea     ListSubscriptionPaymentsFeeRegion = "amex-intra-eea"
	ListSubscriptionPaymentsFeeRegionCarteBancaire    ListSubscriptionPaymentsFeeRegion = "carte-bancaire"
	ListSubscriptionPaymentsFeeRegionIntraEu          ListSubscriptionPaymentsFeeRegion = "intra-eu"
	ListSubscriptionPaymentsFeeRegionIntraEuCorporate ListSubscriptionPaymentsFeeRegion = "intra-eu-corporate"
	ListSubscriptionPaymentsFeeRegionDomestic         ListSubscriptionPaymentsFeeRegion = "domestic"
	ListSubscriptionPaymentsFeeRegionMaestro          ListSubscriptionPaymentsFeeRegion = "maestro"
	ListSubscriptionPaymentsFeeRegionOther            ListSubscriptionPaymentsFeeRegion = "other"
	ListSubscriptionPaymentsFeeRegionInter            ListSubscriptionPaymentsFeeRegion = "inter"
	ListSubscriptionPaymentsFeeRegionIntraEea         ListSubscriptionPaymentsFeeRegion = "intra_eea"
)

func (e ListSubscriptionPaymentsFeeRegion) ToPointer() *ListSubscriptionPaymentsFeeRegion {
	return &e
}

// ListSubscriptionPaymentsFailureReason - A failure code to help understand why the payment failed.
type ListSubscriptionPaymentsFailureReason string

const (
	ListSubscriptionPaymentsFailureReasonAuthenticationAbandoned      ListSubscriptionPaymentsFailureReason = "authentication_abandoned"
	ListSubscriptionPaymentsFailureReasonAuthenticationFailed         ListSubscriptionPaymentsFailureReason = "authentication_failed"
	ListSubscriptionPaymentsFailureReasonAuthenticationRequired       ListSubscriptionPaymentsFailureReason = "authentication_required"
	ListSubscriptionPaymentsFailureReasonAuthenticationUnavailableAcs ListSubscriptionPaymentsFailureReason = "authentication_unavailable_acs"
	ListSubscriptionPaymentsFailureReasonCardDeclined                 ListSubscriptionPaymentsFailureReason = "card_declined"
	ListSubscriptionPaymentsFailureReasonCardExpired                  ListSubscriptionPaymentsFailureReason = "card_expired"
	ListSubscriptionPaymentsFailureReasonInactiveCard                 ListSubscriptionPaymentsFailureReason = "inactive_card"
	ListSubscriptionPaymentsFailureReasonInsufficientFunds            ListSubscriptionPaymentsFailureReason = "insufficient_funds"
	ListSubscriptionPaymentsFailureReasonInvalidCvv                   ListSubscriptionPaymentsFailureReason = "invalid_cvv"
	ListSubscriptionPaymentsFailureReasonInvalidCardHolderName        ListSubscriptionPaymentsFailureReason = "invalid_card_holder_name"
	ListSubscriptionPaymentsFailureReasonInvalidCardNumber            ListSubscriptionPaymentsFailureReason = "invalid_card_number"
	ListSubscriptionPaymentsFailureReasonInvalidCardType              ListSubscriptionPaymentsFailureReason = "invalid_card_type"
	ListSubscriptionPaymentsFailureReasonPossibleFraud                ListSubscriptionPaymentsFailureReason = "possible_fraud"
	ListSubscriptionPaymentsFailureReasonRefusedByIssuer              ListSubscriptionPaymentsFailureReason = "refused_by_issuer"
	ListSubscriptionPaymentsFailureReasonUnknownReason                ListSubscriptionPaymentsFailureReason = "unknown_reason"
)

func (e ListSubscriptionPaymentsFailureReason) ToPointer() *ListSubscriptionPaymentsFailureReason {
	return &e
}

// ListSubscriptionPaymentsWallet - The wallet used when creating the payment.
type ListSubscriptionPaymentsWallet string

const (
	ListSubscriptionPaymentsWalletApplepay ListSubscriptionPaymentsWallet = "applepay"
)

func (e ListSubscriptionPaymentsWallet) ToPointer() *ListSubscriptionPaymentsWallet {
	return &e
}

// ListSubscriptionPaymentsSellerProtection - Indicates to what extent the payment is eligible for PayPal's Seller Protection. Only available for PayPal
// payments, and if the information is made available by PayPal.
type ListSubscriptionPaymentsSellerProtection string

const (
	ListSubscriptionPaymentsSellerProtectionEligible                          ListSubscriptionPaymentsSellerProtection = "Eligible"
	ListSubscriptionPaymentsSellerProtectionIneligible                        ListSubscriptionPaymentsSellerProtection = "Ineligible"
	ListSubscriptionPaymentsSellerProtectionPartiallyEligibleInrOnly          ListSubscriptionPaymentsSellerProtection = "Partially Eligible - INR Only"
	ListSubscriptionPaymentsSellerProtectionPartiallyEligibleUnauthOnly       ListSubscriptionPaymentsSellerProtection = "Partially Eligible - Unauth Only"
	ListSubscriptionPaymentsSellerProtectionPartiallyEligible                 ListSubscriptionPaymentsSellerProtection = "Partially Eligible"
	ListSubscriptionPaymentsSellerProtectionNone                              ListSubscriptionPaymentsSellerProtection = "None"
	ListSubscriptionPaymentsSellerProtectionActive                            ListSubscriptionPaymentsSellerProtection = "Active"
	ListSubscriptionPaymentsSellerProtectionFraudControlUnauthPremiumEligible ListSubscriptionPaymentsSellerProtection = "Fraud Control - Unauth Premium Eligible"
)

func (e ListSubscriptionPaymentsSellerProtection) ToPointer() *ListSubscriptionPaymentsSellerProtection {
	return &e
}

// ListSubscriptionPaymentsPaypalFee - An amount object containing the fee PayPal will charge for this transaction. The field may be omitted if
// PayPal will not charge a fee for this transaction.
type ListSubscriptionPaymentsPaypalFee struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsPaypalFee) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsPaypalFee) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsCardReadMethod - The method by which the card was read by the terminal.
type ListSubscriptionPaymentsCardReadMethod string

const (
	ListSubscriptionPaymentsCardReadMethodChip                   ListSubscriptionPaymentsCardReadMethod = "chip"
	ListSubscriptionPaymentsCardReadMethodMagneticStripe         ListSubscriptionPaymentsCardReadMethod = "magnetic-stripe"
	ListSubscriptionPaymentsCardReadMethodNearFieldCommunication ListSubscriptionPaymentsCardReadMethod = "near-field-communication"
	ListSubscriptionPaymentsCardReadMethodContactless            ListSubscriptionPaymentsCardReadMethod = "contactless"
	ListSubscriptionPaymentsCardReadMethodMoto                   ListSubscriptionPaymentsCardReadMethod = "moto"
)

func (e ListSubscriptionPaymentsCardReadMethod) ToPointer() *ListSubscriptionPaymentsCardReadMethod {
	return &e
}

// ListSubscriptionPaymentsCardVerificationMethod - The method used to verify the cardholder's identity.
type ListSubscriptionPaymentsCardVerificationMethod string

const (
	ListSubscriptionPaymentsCardVerificationMethodNoCvmRequired         ListSubscriptionPaymentsCardVerificationMethod = "no-cvm-required"
	ListSubscriptionPaymentsCardVerificationMethodOnlinePin             ListSubscriptionPaymentsCardVerificationMethod = "online-pin"
	ListSubscriptionPaymentsCardVerificationMethodOfflinePin            ListSubscriptionPaymentsCardVerificationMethod = "offline-pin"
	ListSubscriptionPaymentsCardVerificationMethodConsumerDevice        ListSubscriptionPaymentsCardVerificationMethod = "consumer-device"
	ListSubscriptionPaymentsCardVerificationMethodSignature             ListSubscriptionPaymentsCardVerificationMethod = "signature"
	ListSubscriptionPaymentsCardVerificationMethodSignatureAndOnlinePin ListSubscriptionPaymentsCardVerificationMethod = "signature-and-online-pin"
	ListSubscriptionPaymentsCardVerificationMethodOnlinePinAndSignature ListSubscriptionPaymentsCardVerificationMethod = "online-pin-and-signature"
	ListSubscriptionPaymentsCardVerificationMethodNone                  ListSubscriptionPaymentsCardVerificationMethod = "none"
	ListSubscriptionPaymentsCardVerificationMethodFailed                ListSubscriptionPaymentsCardVerificationMethod = "failed"
)

func (e ListSubscriptionPaymentsCardVerificationMethod) ToPointer() *ListSubscriptionPaymentsCardVerificationMethod {
	return &e
}

// ListSubscriptionPaymentsReceipt - The Point of sale receipt object.
type ListSubscriptionPaymentsReceipt struct {
	// A unique code provided by the cardholderâ€™s bank to confirm that the transaction was successfully approved.
	AuthorizationCode *string `json:"authorizationCode,omitempty"`
	// The unique number that identifies a specific payment application on a chip card.
	ApplicationIdentifier *string `json:"applicationIdentifier,omitempty"`
	// The method by which the card was read by the terminal.
	CardReadMethod *ListSubscriptionPaymentsCardReadMethod `json:"cardReadMethod,omitempty"`
	// The method used to verify the cardholder's identity.
	CardVerificationMethod *ListSubscriptionPaymentsCardVerificationMethod `json:"cardVerificationMethod,omitempty"`
}

func (o *ListSubscriptionPaymentsReceipt) GetAuthorizationCode() *string {
	if o == nil {
		return nil
	}
	return o.AuthorizationCode
}

func (o *ListSubscriptionPaymentsReceipt) GetApplicationIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.ApplicationIdentifier
}

func (o *ListSubscriptionPaymentsReceipt) GetCardReadMethod() *ListSubscriptionPaymentsCardReadMethod {
	if o == nil {
		return nil
	}
	return o.CardReadMethod
}

func (o *ListSubscriptionPaymentsReceipt) GetCardVerificationMethod() *ListSubscriptionPaymentsCardVerificationMethod {
	if o == nil {
		return nil
	}
	return o.CardVerificationMethod
}

// ListSubscriptionPaymentsQrCode - Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
// the QR code details will be available in this object.
//
// The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
// Bancontact QR payments can be completed by the customer using the Bancontact app.
type ListSubscriptionPaymentsQrCode struct {
	// The height of the QR code image in pixels.
	Height *int64 `json:"height,omitempty"`
	// The width of the QR code image in pixels.
	Width *int64 `json:"width,omitempty"`
	// The URL to the QR code image. The image is a PNG file, and can be displayed directly in the browser or
	// downloaded.
	Src *string `json:"src,omitempty"`
}

func (o *ListSubscriptionPaymentsQrCode) GetHeight() *int64 {
	if o == nil {
		return nil
	}
	return o.Height
}

func (o *ListSubscriptionPaymentsQrCode) GetWidth() *int64 {
	if o == nil {
		return nil
	}
	return o.Width
}

func (o *ListSubscriptionPaymentsQrCode) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

// ListSubscriptionPaymentsRemainderAmount - An amount object for the amount that remained after all gift cards or vouchers were applied.
type ListSubscriptionPaymentsRemainderAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *ListSubscriptionPaymentsRemainderAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *ListSubscriptionPaymentsRemainderAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ListSubscriptionPaymentsDetails - An object containing payment details collected during the payment process. For example, details may include the
// customer's card or bank details and a payment reference. For the full list of details, please refer to the
// [method-specific parameters](extra-payment-parameters) guide.
type ListSubscriptionPaymentsDetails struct {
	// The customer's name, if made available by the payment method. For card payments, refer to details.cardHolder.
	ConsumerName *string `json:"consumerName,omitempty"`
	// The customer's account reference.
	//
	// For banking-based payment methods â€” such as iDEAL â€” this is normally either an IBAN or a domestic bank account
	// number.
	//
	// For PayPal, the account reference is an email address.
	//
	// For card and Bancontact payments, refer to details.cardNumber.
	ConsumerAccount *string `json:"consumerAccount,omitempty"`
	// The BIC of the customer's bank account, if applicable.
	ConsumerBic *string `json:"consumerBic,omitempty"`
	// For wallet payment methods â€” such as Apple Pay and PayPal â€” the shipping address is often already known by the
	// wallet provider. In these cases the shipping address may be available as a payment detail.
	ShippingAddress map[string]any `json:"shippingAddress,omitempty"`
	// For bancontact, it will be the customer's masked card number. For cards, it will be the last 4-digit of the
	// PAN. For Point-of-sale, it will be the the last 4 digits of the customer's masked card number.
	CardNumber *string `json:"cardNumber,omitempty"`
	// The name of the bank that the customer will need to make the bank transfer payment towards.
	BankName *string `json:"bankName,omitempty"`
	// The bank account number the customer will need to make the bank transfer payment towards.
	BankAccount *string `json:"bankAccount,omitempty"`
	// The BIC of the bank the customer will need to make the bank transfer payment towards.
	BankBic *string `json:"bankBic,omitempty"`
	// The Mollie-generated reference the customer needs to use when transfering the amount. Do not apply any
	// formatting here; show it to the customer as-is.
	TransferReference *string `json:"transferReference,omitempty"`
	// A unique fingerprint for a specific card. Can be used to identify returning customers.
	//
	// In the case of Point-of-sale payments, it's a unique identifier assigned to a cardholder's payment account,
	// linking multiple transactions from wallets and physical card to a single account, also across payment methods
	// or when the card is reissued.
	CardFingerprint *string `json:"cardFingerprint,omitempty"`
	// The customer's name as shown on their card.
	CardHolder *string `json:"cardHolder,omitempty"`
	// The card's target audience, if known.
	CardAudition *ListSubscriptionPaymentsCardAudition `json:"cardAudition,omitempty"`
	// The card's label, if known.
	CardLabel *ListSubscriptionPaymentsCardLabel `json:"cardLabel,omitempty"`
	// The ISO 3166-1 alpha-2 country code of the country the card was issued in.
	CardCountryCode *string `json:"cardCountryCode,omitempty"`
	// The expiry date (MM/YY) of the card as displayed on the card.
	CardExpiryDate *string `json:"cardExpiryDate,omitempty"`
	// The card type.
	CardFunding *ListSubscriptionPaymentsCardFunding `json:"cardFunding,omitempty"`
	// The level of security applied during card processing.
	CardSecurity *ListSubscriptionPaymentsCardSecurity `json:"cardSecurity,omitempty"`
	// The applicable card fee region.
	FeeRegion *ListSubscriptionPaymentsFeeRegion `json:"feeRegion,omitempty"`
	// The first 6 and last 4 digits of the card number.
	CardMaskedNumber *string `json:"cardMaskedNumber,omitempty"`
	// The outcome of authentication attempted on transactions enforced by 3DS (ie valid only for oneoff and first).
	Card3dsEci *string `json:"card3dsEci,omitempty"`
	// The first 6 digit of the card bank identification number.
	CardBin *string `json:"cardBin,omitempty"`
	// The issuer of the Card.
	CardIssuer *string `json:"cardIssuer,omitempty"`
	// A failure code to help understand why the payment failed.
	FailureReason *ListSubscriptionPaymentsFailureReason `json:"failureReason,omitempty"`
	// A human-friendly failure message that can be shown to the customer. The message is translated in accordance
	// with the payment's locale setting.
	FailureMessage *string `json:"failureMessage,omitempty"`
	// The wallet used when creating the payment.
	Wallet *ListSubscriptionPaymentsWallet `json:"wallet,omitempty"`
	// PayPal's reference for the payment.
	PaypalReference *string `json:"paypalReference,omitempty"`
	// ID of the customer's PayPal account.
	PaypalPayerID *string `json:"paypalPayerId,omitempty"`
	// Indicates to what extent the payment is eligible for PayPal's Seller Protection. Only available for PayPal
	// payments, and if the information is made available by PayPal.
	SellerProtection *ListSubscriptionPaymentsSellerProtection `json:"sellerProtection,omitempty"`
	// An amount object containing the fee PayPal will charge for this transaction. The field may be omitted if
	// PayPal will not charge a fee for this transaction.
	PaypalFee *ListSubscriptionPaymentsPaypalFee `json:"paypalFee,omitempty"`
	// The paysafecard customer reference either provided via the API or otherwise auto-generated by Mollie.
	CustomerReference *string `json:"customerReference,omitempty"`
	// The ID of the terminal device where the payment took place on.
	TerminalID *string `json:"terminalId,omitempty"`
	// The first 6 digits & last 4 digits of the customer's masked card number.
	MaskedNumber *string `json:"maskedNumber,omitempty"`
	// The Point of sale receipt object.
	Receipt *ListSubscriptionPaymentsReceipt `json:"receipt,omitempty"`
	// The creditor identifier indicates who is authorized to execute the payment. In this case, it is a
	// reference to Mollie.
	CreditorIdentifier *string `json:"creditorIdentifier,omitempty"`
	// Estimated date the payment is debited from the customer's bank account, in YYYY-MM-DD format.
	DueDate *types.Date `json:"dueDate,omitempty"`
	// Date the payment has been signed by the customer, in YYYY-MM-DD format. Only available if the payment
	// has been signed.
	SignatureDate *types.Date `json:"signatureDate,omitempty"`
	// The official reason why this payment has failed. A detailed description of each reason is available on the
	// website of the European Payments Council.
	BankReasonCode *string `json:"bankReasonCode,omitempty"`
	// A human-friendly description of the failure reason.
	BankReason *string `json:"bankReason,omitempty"`
	// The end-to-end identifier you provided in the batch file.
	EndToEndIdentifier *string `json:"endToEndIdentifier,omitempty"`
	// The mandate reference you provided in the batch file.
	MandateReference *string `json:"mandateReference,omitempty"`
	// The batch reference you provided in the batch file.
	BatchReference *string `json:"batchReference,omitempty"`
	// The file reference you provided in the batch file.
	FileReference *string `json:"fileReference,omitempty"`
	// Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
	// the QR code details will be available in this object.
	//
	// The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
	// Bancontact QR payments can be completed by the customer using the Bancontact app.
	QrCode *ListSubscriptionPaymentsQrCode `json:"qrCode,omitempty"`
	// For payments with gift cards: the masked gift card number of the first gift card applied to the payment.
	VoucherNumber *string `json:"voucherNumber,omitempty"`
	// An array of detail objects for each gift card that was used on this payment, if any.
	Giftcards []map[string]any `json:"giftcards,omitempty"`
	// For payments with vouchers: the brand name of the first voucher applied.
	Issuer *string `json:"issuer,omitempty"`
	// An array of detail objects for each voucher that was used on this payment, if any.
	Vouchers []map[string]any `json:"vouchers,omitempty"`
	// An amount object for the amount that remained after all gift cards or vouchers were applied.
	RemainderAmount *ListSubscriptionPaymentsRemainderAmount `json:"remainderAmount,omitempty"`
	// The payment method used to pay the remainder amount, after all gift cards or vouchers were applied.
	RemainderMethod *string `json:"remainderMethod,omitempty"`
	// Optional include. The full payment method details of the remainder payment.
	RemainderDetails map[string]any `json:"remainderDetails,omitempty"`
}

func (l ListSubscriptionPaymentsDetails) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListSubscriptionPaymentsDetails) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ListSubscriptionPaymentsDetails) GetConsumerName() *string {
	if o == nil {
		return nil
	}
	return o.ConsumerName
}

func (o *ListSubscriptionPaymentsDetails) GetConsumerAccount() *string {
	if o == nil {
		return nil
	}
	return o.ConsumerAccount
}

func (o *ListSubscriptionPaymentsDetails) GetConsumerBic() *string {
	if o == nil {
		return nil
	}
	return o.ConsumerBic
}

func (o *ListSubscriptionPaymentsDetails) GetShippingAddress() map[string]any {
	if o == nil {
		return nil
	}
	return o.ShippingAddress
}

func (o *ListSubscriptionPaymentsDetails) GetCardNumber() *string {
	if o == nil {
		return nil
	}
	return o.CardNumber
}

func (o *ListSubscriptionPaymentsDetails) GetBankName() *string {
	if o == nil {
		return nil
	}
	return o.BankName
}

func (o *ListSubscriptionPaymentsDetails) GetBankAccount() *string {
	if o == nil {
		return nil
	}
	return o.BankAccount
}

func (o *ListSubscriptionPaymentsDetails) GetBankBic() *string {
	if o == nil {
		return nil
	}
	return o.BankBic
}

func (o *ListSubscriptionPaymentsDetails) GetTransferReference() *string {
	if o == nil {
		return nil
	}
	return o.TransferReference
}

func (o *ListSubscriptionPaymentsDetails) GetCardFingerprint() *string {
	if o == nil {
		return nil
	}
	return o.CardFingerprint
}

func (o *ListSubscriptionPaymentsDetails) GetCardHolder() *string {
	if o == nil {
		return nil
	}
	return o.CardHolder
}

func (o *ListSubscriptionPaymentsDetails) GetCardAudition() *ListSubscriptionPaymentsCardAudition {
	if o == nil {
		return nil
	}
	return o.CardAudition
}

func (o *ListSubscriptionPaymentsDetails) GetCardLabel() *ListSubscriptionPaymentsCardLabel {
	if o == nil {
		return nil
	}
	return o.CardLabel
}

func (o *ListSubscriptionPaymentsDetails) GetCardCountryCode() *string {
	if o == nil {
		return nil
	}
	return o.CardCountryCode
}

func (o *ListSubscriptionPaymentsDetails) GetCardExpiryDate() *string {
	if o == nil {
		return nil
	}
	return o.CardExpiryDate
}

func (o *ListSubscriptionPaymentsDetails) GetCardFunding() *ListSubscriptionPaymentsCardFunding {
	if o == nil {
		return nil
	}
	return o.CardFunding
}

func (o *ListSubscriptionPaymentsDetails) GetCardSecurity() *ListSubscriptionPaymentsCardSecurity {
	if o == nil {
		return nil
	}
	return o.CardSecurity
}

func (o *ListSubscriptionPaymentsDetails) GetFeeRegion() *ListSubscriptionPaymentsFeeRegion {
	if o == nil {
		return nil
	}
	return o.FeeRegion
}

func (o *ListSubscriptionPaymentsDetails) GetCardMaskedNumber() *string {
	if o == nil {
		return nil
	}
	return o.CardMaskedNumber
}

func (o *ListSubscriptionPaymentsDetails) GetCard3dsEci() *string {
	if o == nil {
		return nil
	}
	return o.Card3dsEci
}

func (o *ListSubscriptionPaymentsDetails) GetCardBin() *string {
	if o == nil {
		return nil
	}
	return o.CardBin
}

func (o *ListSubscriptionPaymentsDetails) GetCardIssuer() *string {
	if o == nil {
		return nil
	}
	return o.CardIssuer
}

func (o *ListSubscriptionPaymentsDetails) GetFailureReason() *ListSubscriptionPaymentsFailureReason {
	if o == nil {
		return nil
	}
	return o.FailureReason
}

func (o *ListSubscriptionPaymentsDetails) GetFailureMessage() *string {
	if o == nil {
		return nil
	}
	return o.FailureMessage
}

func (o *ListSubscriptionPaymentsDetails) GetWallet() *ListSubscriptionPaymentsWallet {
	if o == nil {
		return nil
	}
	return o.Wallet
}

func (o *ListSubscriptionPaymentsDetails) GetPaypalReference() *string {
	if o == nil {
		return nil
	}
	return o.PaypalReference
}

func (o *ListSubscriptionPaymentsDetails) GetPaypalPayerID() *string {
	if o == nil {
		return nil
	}
	return o.PaypalPayerID
}

func (o *ListSubscriptionPaymentsDetails) GetSellerProtection() *ListSubscriptionPaymentsSellerProtection {
	if o == nil {
		return nil
	}
	return o.SellerProtection
}

func (o *ListSubscriptionPaymentsDetails) GetPaypalFee() *ListSubscriptionPaymentsPaypalFee {
	if o == nil {
		return nil
	}
	return o.PaypalFee
}

func (o *ListSubscriptionPaymentsDetails) GetCustomerReference() *string {
	if o == nil {
		return nil
	}
	return o.CustomerReference
}

func (o *ListSubscriptionPaymentsDetails) GetTerminalID() *string {
	if o == nil {
		return nil
	}
	return o.TerminalID
}

func (o *ListSubscriptionPaymentsDetails) GetMaskedNumber() *string {
	if o == nil {
		return nil
	}
	return o.MaskedNumber
}

func (o *ListSubscriptionPaymentsDetails) GetReceipt() *ListSubscriptionPaymentsReceipt {
	if o == nil {
		return nil
	}
	return o.Receipt
}

func (o *ListSubscriptionPaymentsDetails) GetCreditorIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.CreditorIdentifier
}

func (o *ListSubscriptionPaymentsDetails) GetDueDate() *types.Date {
	if o == nil {
		return nil
	}
	return o.DueDate
}

func (o *ListSubscriptionPaymentsDetails) GetSignatureDate() *types.Date {
	if o == nil {
		return nil
	}
	return o.SignatureDate
}

func (o *ListSubscriptionPaymentsDetails) GetBankReasonCode() *string {
	if o == nil {
		return nil
	}
	return o.BankReasonCode
}

func (o *ListSubscriptionPaymentsDetails) GetBankReason() *string {
	if o == nil {
		return nil
	}
	return o.BankReason
}

func (o *ListSubscriptionPaymentsDetails) GetEndToEndIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.EndToEndIdentifier
}

func (o *ListSubscriptionPaymentsDetails) GetMandateReference() *string {
	if o == nil {
		return nil
	}
	return o.MandateReference
}

func (o *ListSubscriptionPaymentsDetails) GetBatchReference() *string {
	if o == nil {
		return nil
	}
	return o.BatchReference
}

func (o *ListSubscriptionPaymentsDetails) GetFileReference() *string {
	if o == nil {
		return nil
	}
	return o.FileReference
}

func (o *ListSubscriptionPaymentsDetails) GetQrCode() *ListSubscriptionPaymentsQrCode {
	if o == nil {
		return nil
	}
	return o.QrCode
}

func (o *ListSubscriptionPaymentsDetails) GetVoucherNumber() *string {
	if o == nil {
		return nil
	}
	return o.VoucherNumber
}

func (o *ListSubscriptionPaymentsDetails) GetGiftcards() []map[string]any {
	if o == nil {
		return nil
	}
	return o.Giftcards
}

func (o *ListSubscriptionPaymentsDetails) GetIssuer() *string {
	if o == nil {
		return nil
	}
	return o.Issuer
}

func (o *ListSubscriptionPaymentsDetails) GetVouchers() []map[string]any {
	if o == nil {
		return nil
	}
	return o.Vouchers
}

func (o *ListSubscriptionPaymentsDetails) GetRemainderAmount() *ListSubscriptionPaymentsRemainderAmount {
	if o == nil {
		return nil
	}
	return o.RemainderAmount
}

func (o *ListSubscriptionPaymentsDetails) GetRemainderMethod() *string {
	if o == nil {
		return nil
	}
	return o.RemainderMethod
}

func (o *ListSubscriptionPaymentsDetails) GetRemainderDetails() map[string]any {
	if o == nil {
		return nil
	}
	return o.RemainderDetails
}

// ListSubscriptionPaymentsPaymentSelf - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type ListSubscriptionPaymentsPaymentSelf struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsPaymentSelf) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsPaymentSelf) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsCheckout - The URL your customer should visit to make the payment. This is where you should redirect the customer to.
type ListSubscriptionPaymentsCheckout struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsCheckout) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsCheckout) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsMobileAppCheckout - The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
type ListSubscriptionPaymentsMobileAppCheckout struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsMobileAppCheckout) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsMobileAppCheckout) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsChangePaymentState - For test mode payments in certain scenarios, a hosted interface is available to help you test different
// payment states.
//
// Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
// payments are executed without any user interaction.
//
// Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
// chargeback for the test payment.
type ListSubscriptionPaymentsChangePaymentState struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsChangePaymentState) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsChangePaymentState) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsDashboard - Direct link to the payment in the Mollie Dashboard.
type ListSubscriptionPaymentsDashboard struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsDashboard) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsDashboard) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsRefunds - The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
type ListSubscriptionPaymentsRefunds struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsRefunds) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsRefunds) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsChargebacks - The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
// payment.
type ListSubscriptionPaymentsChargebacks struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsChargebacks) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsChargebacks) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsCaptures - The API resource URL of the [captures](list-payment-captures) that belong to this payment.
type ListSubscriptionPaymentsCaptures struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsCaptures) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsCaptures) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsSettlement - The API resource URL of the [settlement](get-settlement) this payment has been settled with.
// Not present if not yet settled.
type ListSubscriptionPaymentsSettlement struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsSettlement) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsSettlement) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsCustomer - The API resource URL of the [customer](get-customer).
type ListSubscriptionPaymentsCustomer struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsCustomer) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsCustomer) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsMandate - The API resource URL of the [mandate](get-mandate).
type ListSubscriptionPaymentsMandate struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsMandate) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsMandate) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsSubscription - The API resource URL of the [subscription](get-subscription).
type ListSubscriptionPaymentsSubscription struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsSubscription) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsSubscription) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsOrder - The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
// order.
type ListSubscriptionPaymentsOrder struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsOrder) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsOrder) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsTerminal - The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
// point-of-sale payments.
type ListSubscriptionPaymentsTerminal struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsTerminal) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsTerminal) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsPaymentDocumentation - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type ListSubscriptionPaymentsPaymentDocumentation struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsPaymentDocumentation) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsPaymentDocumentation) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsLinksStatus - Link to customer-facing page showing the status of the bank transfer (to verify if the transaction was
// successful).
type ListSubscriptionPaymentsLinksStatus struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsLinksStatus) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsLinksStatus) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsPayOnline - Link to Mollie Checkout page allowing customers to select a different payment method instead of legacy
// bank transfer.
type ListSubscriptionPaymentsPayOnline struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsPayOnline) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsPayOnline) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsPaymentLinks - An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
type ListSubscriptionPaymentsPaymentLinks struct {
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Self ListSubscriptionPaymentsPaymentSelf `json:"self"`
	// The URL your customer should visit to make the payment. This is where you should redirect the customer to.
	Checkout *ListSubscriptionPaymentsCheckout `json:"checkout,omitempty"`
	// The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
	MobileAppCheckout *ListSubscriptionPaymentsMobileAppCheckout `json:"mobileAppCheckout,omitempty"`
	// For test mode payments in certain scenarios, a hosted interface is available to help you test different
	// payment states.
	//
	// Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
	// payments are executed without any user interaction.
	//
	// Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
	// chargeback for the test payment.
	ChangePaymentState *ListSubscriptionPaymentsChangePaymentState `json:"changePaymentState,omitempty"`
	// Direct link to the payment in the Mollie Dashboard.
	Dashboard ListSubscriptionPaymentsDashboard `json:"dashboard"`
	// The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
	Refunds *ListSubscriptionPaymentsRefunds `json:"refunds,omitempty"`
	// The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
	// payment.
	Chargebacks *ListSubscriptionPaymentsChargebacks `json:"chargebacks,omitempty"`
	// The API resource URL of the [captures](list-payment-captures) that belong to this payment.
	Captures *ListSubscriptionPaymentsCaptures `json:"captures,omitempty"`
	// The API resource URL of the [settlement](get-settlement) this payment has been settled with.
	// Not present if not yet settled.
	Settlement *ListSubscriptionPaymentsSettlement `json:"settlement,omitempty"`
	// The API resource URL of the [customer](get-customer).
	Customer *ListSubscriptionPaymentsCustomer `json:"customer,omitempty"`
	// The API resource URL of the [mandate](get-mandate).
	Mandate *ListSubscriptionPaymentsMandate `json:"mandate,omitempty"`
	// The API resource URL of the [subscription](get-subscription).
	Subscription *ListSubscriptionPaymentsSubscription `json:"subscription,omitempty"`
	// The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
	// order.
	Order *ListSubscriptionPaymentsOrder `json:"order,omitempty"`
	// The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
	// point-of-sale payments.
	Terminal *ListSubscriptionPaymentsTerminal `json:"terminal,omitempty"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Documentation *ListSubscriptionPaymentsPaymentDocumentation `json:"documentation,omitempty"`
	// Link to customer-facing page showing the status of the bank transfer (to verify if the transaction was
	// successful).
	Status *ListSubscriptionPaymentsLinksStatus `json:"status,omitempty"`
	// Link to Mollie Checkout page allowing customers to select a different payment method instead of legacy
	// bank transfer.
	PayOnline *ListSubscriptionPaymentsPayOnline `json:"payOnline,omitempty"`
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetSelf() ListSubscriptionPaymentsPaymentSelf {
	if o == nil {
		return ListSubscriptionPaymentsPaymentSelf{}
	}
	return o.Self
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetCheckout() *ListSubscriptionPaymentsCheckout {
	if o == nil {
		return nil
	}
	return o.Checkout
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetMobileAppCheckout() *ListSubscriptionPaymentsMobileAppCheckout {
	if o == nil {
		return nil
	}
	return o.MobileAppCheckout
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetChangePaymentState() *ListSubscriptionPaymentsChangePaymentState {
	if o == nil {
		return nil
	}
	return o.ChangePaymentState
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetDashboard() ListSubscriptionPaymentsDashboard {
	if o == nil {
		return ListSubscriptionPaymentsDashboard{}
	}
	return o.Dashboard
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetRefunds() *ListSubscriptionPaymentsRefunds {
	if o == nil {
		return nil
	}
	return o.Refunds
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetChargebacks() *ListSubscriptionPaymentsChargebacks {
	if o == nil {
		return nil
	}
	return o.Chargebacks
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetCaptures() *ListSubscriptionPaymentsCaptures {
	if o == nil {
		return nil
	}
	return o.Captures
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetSettlement() *ListSubscriptionPaymentsSettlement {
	if o == nil {
		return nil
	}
	return o.Settlement
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetCustomer() *ListSubscriptionPaymentsCustomer {
	if o == nil {
		return nil
	}
	return o.Customer
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetMandate() *ListSubscriptionPaymentsMandate {
	if o == nil {
		return nil
	}
	return o.Mandate
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetSubscription() *ListSubscriptionPaymentsSubscription {
	if o == nil {
		return nil
	}
	return o.Subscription
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetOrder() *ListSubscriptionPaymentsOrder {
	if o == nil {
		return nil
	}
	return o.Order
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetTerminal() *ListSubscriptionPaymentsTerminal {
	if o == nil {
		return nil
	}
	return o.Terminal
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetDocumentation() *ListSubscriptionPaymentsPaymentDocumentation {
	if o == nil {
		return nil
	}
	return o.Documentation
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetStatus() *ListSubscriptionPaymentsLinksStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *ListSubscriptionPaymentsPaymentLinks) GetPayOnline() *ListSubscriptionPaymentsPayOnline {
	if o == nil {
		return nil
	}
	return o.PayOnline
}

type ListSubscriptionPaymentsPaymentOutput struct {
	// Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
	Resource string `json:"resource"`
	// The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
	// will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
	ID string `json:"id"`
	// Whether this entity was created in live mode or in test mode.
	Mode ListSubscriptionPaymentsMode `json:"mode"`
	// The description of the payment. This will be shown to your customer on their card or bank statement when possible.
	// We truncate the description automatically according to the limits of the used payment method. The description is
	// also visible in any exports you generate.
	//
	// We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
	// This is particularly useful for bookkeeping.
	//
	// The maximum length of the description field differs per payment method, with the absolute maximum being 255
	// characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
	Description string `json:"description"`
	// The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge â‚¬1000.00.
	//
	// You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
	// retrieved using the Get method endpoint.
	//
	// If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
	// tip amount.
	Amount ListSubscriptionPaymentsAmount `json:"amount"`
	// The total amount that is already refunded. Only available when refunds are available for this payment. For some
	// payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
	// costs for a return shipment to the customer.
	AmountRefunded *ListSubscriptionPaymentsAmountRefunded `json:"amountRefunded,omitempty"`
	// The remaining amount that can be refunded. Only available when refunds are available for this payment.
	AmountRemaining *ListSubscriptionPaymentsAmountRemaining `json:"amountRemaining,omitempty"`
	// The total amount that is already captured for this payment. Only available when this payment supports captures.
	AmountCaptured *ListSubscriptionPaymentsAmountCaptured `json:"amountCaptured,omitempty"`
	// The total amount that was charged back for this payment. Only available when the total charged back amount is not
	// zero.
	AmountChargedBack *ListSubscriptionPaymentsAmountChargedBack `json:"amountChargedBack,omitempty"`
	// This optional field will contain the approximate amount that will be settled to your account, converted to the
	// currency your account is settled in.
	//
	// Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
	// settled by Mollie the `settlementAmount` is omitted from the response.
	//
	// Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
	// using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
	SettlementAmount *ListSubscriptionPaymentsSettlementAmount `json:"settlementAmount,omitempty"`
	// The URL your customer will be redirected to after the payment process.
	//
	// It could make sense for the redirectUrl to contain a unique identifier â€“ like your order ID â€“ so you can show the
	// right page referencing the order when your customer returns.
	//
	// The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
	// Apple Pay payments with an `applePayPaymentToken`.
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
	// provided, the customer will be redirected to the `redirectUrl` instead â€” see above.
	//
	// Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
	// therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
	// payment cancellations.
	CancelURL *string `json:"cancelUrl,omitempty"`
	// The webhook URL where we will send payment status updates to.
	//
	// The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
	//
	// The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
	// webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
	// local machine.
	WebhookURL *string `json:"webhookUrl,omitempty"`
	// Optionally provide the order lines for the payment. Each line contains details such as a description of the item
	// ordered and its price.
	//
	// All lines must have the same currency as the payment.
	//
	// Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
	Lines []ListSubscriptionPaymentsLine `json:"lines,omitempty"`
	// The customer's billing address details. We advise to provide these details to improve fraud protection and
	// conversion.
	//
	// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
	// `country`.
	//
	// Required for payment method `in3`, `klarna`, `billie` and `riverty`.
	BillingAddress *ListSubscriptionPaymentsBillingAddress `json:"billingAddress,omitempty"`
	// The customer's shipping address details. We advise to provide these details to improve fraud protection and
	// conversion.
	//
	// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
	// `country`.
	ShippingAddress *ListSubscriptionPaymentsShippingAddress `json:"shippingAddress,omitempty"`
	// Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
	// is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
	// language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
	// locale, but our hosted payment pages currently only support the specified languages.
	//
	// For bank transfer payments specifically, the locale will determine the target bank account the customer has to
	// transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
	// customer use a local bank account greatly increases the conversion and speed of payment.
	Locale *ListSubscriptionPaymentsLocale `json:"locale,omitempty"`
	// This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
	// field is omitted if the country code was not detected.
	CountryCode *string `json:"countryCode,omitempty"`
	// The payment method used for this transaction. If a specific method was selected during payment initialization,
	// this field reflects that choice.
	Method *ListSubscriptionPaymentsMethod `json:"method,omitempty"`
	// For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
	// rates you have used for the order to ensure your customer's country matches the VAT country.
	//
	// Use this parameter to restrict the payment methods available to your customer to those from a single country.
	//
	// If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
	//
	// The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
	RestrictPaymentMethodsToCountry *string `json:"restrictPaymentMethodsToCountry,omitempty"`
	// Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
	// you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
	Metadata *ListSubscriptionPaymentsMetadata `json:"metadata,omitempty"`
	// Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
	// and capture at a later time.
	//
	// This field needs to be set to `manual` for method `riverty`.
	CaptureMode *ListSubscriptionPaymentsCaptureMode `json:"captureMode,omitempty"`
	// **Only relevant if you wish to manage authorization and capturing separately.**
	//
	// Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
	// later point either be 'captured' or canceled.
	//
	// By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
	// capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
	// example `8 hours` or `2 days`.
	//
	// To schedule an automatic capture, the `captureMode` must be set to `automatic`.
	//
	// The maximum delay is 7 days (168 hours).
	//
	// Possible values: `... hours` `... days`
	CaptureDelay *string `json:"captureDelay,omitempty"`
	// Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
	// can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
	CaptureBefore *string `json:"captureBefore,omitempty"`
	// With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
	// merchants.
	//
	// If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
	// `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
	// to your own account balance.
	//
	// If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
	// `routing` parameter.
	ApplicationFee *ListSubscriptionPaymentsApplicationFee `json:"applicationFee,omitempty"`
	// *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
	//
	// With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
	// merchants.
	//
	// If you create payments on your own account that you want to split between yourself and one or more connected
	// merchants, you can use this `routing` parameter to route the payment accordingly.
	//
	// The `routing` parameter should contain an array of objects, with each object describing the destination for a
	// specific portion of the payment.
	//
	// It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
	// payment amount have been routed, the amount left will be routed to the current organization automatically.
	//
	// If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
	// parameter.
	Routing []ListSubscriptionPaymentsRouting `json:"routing,omitempty"`
	// **Only relevant for recurring payments.**
	//
	// Indicate which part of a recurring sequence this payment is for.
	//
	// Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
	// through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
	// on their account in the future.
	//
	// If set to `recurring`, the customer's card is charged automatically.
	//
	// Defaults to `oneoff`, which is a regular non-recurring payment.
	//
	// For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
	// [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
	// are set up correctly for recurring payments.
	SequenceType *ListSubscriptionPaymentsSequenceType `json:"sequenceType"`
	// If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
	// be added to the response.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// **Only relevant for recurring payments.**
	//
	// When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
	// the customer's accounts should be credited.
	MandateID *string `json:"mandateId,omitempty"`
	// The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
	// payments, but can also be used on regular payments to enable single-click payments.
	//
	// If `sequenceType` is set to `recurring`, this field is required.
	CustomerID *string `json:"customerId,omitempty"`
	// The identifier referring to the [profile](get-profile) this entity belongs to.
	//
	// When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
	// Organization tokens, the `profileId` is required.
	//
	// For more information, see [Authentication](authentication).
	ProfileID string `json:"profileId"`
	// The identifier referring to the [settlement](get-settlement) this payment was settled with.
	SettlementID *string `json:"settlementId,omitempty"`
	// If the payment was created for an [order](get-order), the ID of that order will be part of the response.
	OrderID *string `json:"orderId,omitempty"`
	// The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
	// statuses occur at what point.
	Status ListSubscriptionPaymentsStatusEnum `json:"status"`
	// This object offers details about the status of a payment. Currently it is only available for point-of-sale
	// payments.
	//
	// You can find more information about the possible values of this object on
	// [this page](status-reasons).**
	StatusReason *ListSubscriptionPaymentsStatusReason `json:"statusReason,omitempty"`
	// Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
	IsCancelable *bool `json:"isCancelable,omitempty"`
	// An object containing payment details collected during the payment process. For example, details may include the
	// customer's card or bank details and a payment reference. For the full list of details, please refer to the
	// [method-specific parameters](extra-payment-parameters) guide.
	Details *ListSubscriptionPaymentsDetails `json:"details,omitempty"`
	// The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
	CreatedAt string `json:"createdAt"`
	// The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
	// not authorized (yet).
	AuthorizedAt *string `json:"authorizedAt,omitempty"`
	// The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
	// completed (yet).
	PaidAt *string `json:"paidAt,omitempty"`
	// The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
	// canceled (yet).
	CanceledAt *string `json:"canceledAt,omitempty"`
	// The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
	// longer expire.
	ExpiresAt *string `json:"expiresAt,omitempty"`
	// The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
	// expire (yet).
	ExpiredAt *string `json:"expiredAt,omitempty"`
	// The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
	// (yet).
	FailedAt *string `json:"failedAt,omitempty"`
	// An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
	Links ListSubscriptionPaymentsPaymentLinks `json:"_links"`
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetResource() string {
	if o == nil {
		return ""
	}
	return o.Resource
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetMode() ListSubscriptionPaymentsMode {
	if o == nil {
		return ListSubscriptionPaymentsMode("")
	}
	return o.Mode
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetAmount() ListSubscriptionPaymentsAmount {
	if o == nil {
		return ListSubscriptionPaymentsAmount{}
	}
	return o.Amount
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetAmountRefunded() *ListSubscriptionPaymentsAmountRefunded {
	if o == nil {
		return nil
	}
	return o.AmountRefunded
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetAmountRemaining() *ListSubscriptionPaymentsAmountRemaining {
	if o == nil {
		return nil
	}
	return o.AmountRemaining
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetAmountCaptured() *ListSubscriptionPaymentsAmountCaptured {
	if o == nil {
		return nil
	}
	return o.AmountCaptured
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetAmountChargedBack() *ListSubscriptionPaymentsAmountChargedBack {
	if o == nil {
		return nil
	}
	return o.AmountChargedBack
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetSettlementAmount() *ListSubscriptionPaymentsSettlementAmount {
	if o == nil {
		return nil
	}
	return o.SettlementAmount
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetRedirectURL() *string {
	if o == nil {
		return nil
	}
	return o.RedirectURL
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetCancelURL() *string {
	if o == nil {
		return nil
	}
	return o.CancelURL
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetWebhookURL() *string {
	if o == nil {
		return nil
	}
	return o.WebhookURL
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetLines() []ListSubscriptionPaymentsLine {
	if o == nil {
		return nil
	}
	return o.Lines
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetBillingAddress() *ListSubscriptionPaymentsBillingAddress {
	if o == nil {
		return nil
	}
	return o.BillingAddress
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetShippingAddress() *ListSubscriptionPaymentsShippingAddress {
	if o == nil {
		return nil
	}
	return o.ShippingAddress
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetLocale() *ListSubscriptionPaymentsLocale {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetCountryCode() *string {
	if o == nil {
		return nil
	}
	return o.CountryCode
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetMethod() *ListSubscriptionPaymentsMethod {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetRestrictPaymentMethodsToCountry() *string {
	if o == nil {
		return nil
	}
	return o.RestrictPaymentMethodsToCountry
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetMetadata() *ListSubscriptionPaymentsMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetCaptureMode() *ListSubscriptionPaymentsCaptureMode {
	if o == nil {
		return nil
	}
	return o.CaptureMode
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetCaptureDelay() *string {
	if o == nil {
		return nil
	}
	return o.CaptureDelay
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetCaptureBefore() *string {
	if o == nil {
		return nil
	}
	return o.CaptureBefore
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetApplicationFee() *ListSubscriptionPaymentsApplicationFee {
	if o == nil {
		return nil
	}
	return o.ApplicationFee
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetRouting() []ListSubscriptionPaymentsRouting {
	if o == nil {
		return nil
	}
	return o.Routing
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetSequenceType() *ListSubscriptionPaymentsSequenceType {
	if o == nil {
		return nil
	}
	return o.SequenceType
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetSubscriptionID() *string {
	if o == nil {
		return nil
	}
	return o.SubscriptionID
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetMandateID() *string {
	if o == nil {
		return nil
	}
	return o.MandateID
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetCustomerID() *string {
	if o == nil {
		return nil
	}
	return o.CustomerID
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetProfileID() string {
	if o == nil {
		return ""
	}
	return o.ProfileID
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetSettlementID() *string {
	if o == nil {
		return nil
	}
	return o.SettlementID
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetOrderID() *string {
	if o == nil {
		return nil
	}
	return o.OrderID
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetStatus() ListSubscriptionPaymentsStatusEnum {
	if o == nil {
		return ListSubscriptionPaymentsStatusEnum("")
	}
	return o.Status
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetStatusReason() *ListSubscriptionPaymentsStatusReason {
	if o == nil {
		return nil
	}
	return o.StatusReason
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetIsCancelable() *bool {
	if o == nil {
		return nil
	}
	return o.IsCancelable
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetDetails() *ListSubscriptionPaymentsDetails {
	if o == nil {
		return nil
	}
	return o.Details
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetCreatedAt() string {
	if o == nil {
		return ""
	}
	return o.CreatedAt
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetAuthorizedAt() *string {
	if o == nil {
		return nil
	}
	return o.AuthorizedAt
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetPaidAt() *string {
	if o == nil {
		return nil
	}
	return o.PaidAt
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetCanceledAt() *string {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetExpiresAt() *string {
	if o == nil {
		return nil
	}
	return o.ExpiresAt
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetExpiredAt() *string {
	if o == nil {
		return nil
	}
	return o.ExpiredAt
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetFailedAt() *string {
	if o == nil {
		return nil
	}
	return o.FailedAt
}

func (o *ListSubscriptionPaymentsPaymentOutput) GetLinks() ListSubscriptionPaymentsPaymentLinks {
	if o == nil {
		return ListSubscriptionPaymentsPaymentLinks{}
	}
	return o.Links
}

type ListSubscriptionPaymentsEmbedded struct {
	// An array of payment objects.
	Payments []ListSubscriptionPaymentsPaymentOutput `json:"payments,omitempty"`
}

func (o *ListSubscriptionPaymentsEmbedded) GetPayments() []ListSubscriptionPaymentsPaymentOutput {
	if o == nil {
		return nil
	}
	return o.Payments
}

// ListSubscriptionPaymentsSelf - The URL to the current set of items.
type ListSubscriptionPaymentsSelf struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsSelf) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsSelf) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsPrevious - The previous set of items, if available.
type ListSubscriptionPaymentsPrevious struct {
	// The actual URL string.
	Href *string `json:"href,omitempty"`
	// The content type of the page or endpoint the URL points to.
	Type *string `json:"type,omitempty"`
}

func (o *ListSubscriptionPaymentsPrevious) GetHref() *string {
	if o == nil {
		return nil
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsPrevious) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// ListSubscriptionPaymentsNext - The next set of items, if available.
type ListSubscriptionPaymentsNext struct {
	// The actual URL string.
	Href *string `json:"href,omitempty"`
	// The content type of the page or endpoint the URL points to.
	Type *string `json:"type,omitempty"`
}

func (o *ListSubscriptionPaymentsNext) GetHref() *string {
	if o == nil {
		return nil
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsNext) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// ListSubscriptionPaymentsDocumentation - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type ListSubscriptionPaymentsDocumentation struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *ListSubscriptionPaymentsDocumentation) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *ListSubscriptionPaymentsDocumentation) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// ListSubscriptionPaymentsLinks - Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
type ListSubscriptionPaymentsLinks struct {
	// The URL to the current set of items.
	Self ListSubscriptionPaymentsSelf `json:"self"`
	// The previous set of items, if available.
	Previous *ListSubscriptionPaymentsPrevious `json:"previous"`
	// The next set of items, if available.
	Next *ListSubscriptionPaymentsNext `json:"next"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Documentation ListSubscriptionPaymentsDocumentation `json:"documentation"`
}

func (o *ListSubscriptionPaymentsLinks) GetSelf() ListSubscriptionPaymentsSelf {
	if o == nil {
		return ListSubscriptionPaymentsSelf{}
	}
	return o.Self
}

func (o *ListSubscriptionPaymentsLinks) GetPrevious() *ListSubscriptionPaymentsPrevious {
	if o == nil {
		return nil
	}
	return o.Previous
}

func (o *ListSubscriptionPaymentsLinks) GetNext() *ListSubscriptionPaymentsNext {
	if o == nil {
		return nil
	}
	return o.Next
}

func (o *ListSubscriptionPaymentsLinks) GetDocumentation() ListSubscriptionPaymentsDocumentation {
	if o == nil {
		return ListSubscriptionPaymentsDocumentation{}
	}
	return o.Documentation
}

// ListSubscriptionPaymentsResponseBody - A list of payment objects.
type ListSubscriptionPaymentsResponseBody struct {
	// The number of items in this result set. If more items are available, a `_links.next` URL will be present in the result
	// as well.
	//
	// The maximum number of items per result set is controlled by the `limit` property provided in the request. The default
	// limit is 50 items.
	Count    int64                            `json:"count"`
	Embedded ListSubscriptionPaymentsEmbedded `json:"_embedded"`
	// Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
	Links ListSubscriptionPaymentsLinks `json:"_links"`
}

func (o *ListSubscriptionPaymentsResponseBody) GetCount() int64 {
	if o == nil {
		return 0
	}
	return o.Count
}

func (o *ListSubscriptionPaymentsResponseBody) GetEmbedded() ListSubscriptionPaymentsEmbedded {
	if o == nil {
		return ListSubscriptionPaymentsEmbedded{}
	}
	return o.Embedded
}

func (o *ListSubscriptionPaymentsResponseBody) GetLinks() ListSubscriptionPaymentsLinks {
	if o == nil {
		return ListSubscriptionPaymentsLinks{}
	}
	return o.Links
}

type ListSubscriptionPaymentsResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// A list of payment objects.
	Object *ListSubscriptionPaymentsResponseBody
}

func (o *ListSubscriptionPaymentsResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *ListSubscriptionPaymentsResponse) GetObject() *ListSubscriptionPaymentsResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
