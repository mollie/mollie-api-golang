// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/mollie/mollie-api-golang/internal/utils"
	"github.com/mollie/mollie-api-golang/models/components"
	"github.com/mollie/mollie-api-golang/types"
)

// CreateCustomerPaymentAmountRequest - The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
//
// You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
// retrieved using the Get method endpoint.
//
// If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
// tip amount.
type CreateCustomerPaymentAmountRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentAmountRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentAmountRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentLineTypeRequest - The type of product purchased. For example, a physical or a digital product.
//
// The `tip` payment line type is not available when creating a payment.
type CreateCustomerPaymentLineTypeRequest string

const (
	CreateCustomerPaymentLineTypeRequestPhysical    CreateCustomerPaymentLineTypeRequest = "physical"
	CreateCustomerPaymentLineTypeRequestDigital     CreateCustomerPaymentLineTypeRequest = "digital"
	CreateCustomerPaymentLineTypeRequestShippingFee CreateCustomerPaymentLineTypeRequest = "shipping_fee"
	CreateCustomerPaymentLineTypeRequestDiscount    CreateCustomerPaymentLineTypeRequest = "discount"
	CreateCustomerPaymentLineTypeRequestStoreCredit CreateCustomerPaymentLineTypeRequest = "store_credit"
	CreateCustomerPaymentLineTypeRequestGiftCard    CreateCustomerPaymentLineTypeRequest = "gift_card"
	CreateCustomerPaymentLineTypeRequestSurcharge   CreateCustomerPaymentLineTypeRequest = "surcharge"
	CreateCustomerPaymentLineTypeRequestTip         CreateCustomerPaymentLineTypeRequest = "tip"
)

func (e CreateCustomerPaymentLineTypeRequest) ToPointer() *CreateCustomerPaymentLineTypeRequest {
	return &e
}
func (e *CreateCustomerPaymentLineTypeRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "physical":
		fallthrough
	case "digital":
		fallthrough
	case "shipping_fee":
		fallthrough
	case "discount":
		fallthrough
	case "store_credit":
		fallthrough
	case "gift_card":
		fallthrough
	case "surcharge":
		fallthrough
	case "tip":
		*e = CreateCustomerPaymentLineTypeRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentLineTypeRequest: %v", v)
	}
}

// CreateCustomerPaymentUnitPriceRequest - The price of a single item including VAT.
//
// For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
//
// For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
//
// The unit price can be zero in case of free items.
type CreateCustomerPaymentUnitPriceRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentUnitPriceRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentUnitPriceRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentDiscountAmountRequest - Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
// type.
type CreateCustomerPaymentDiscountAmountRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentDiscountAmountRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentDiscountAmountRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentTotalAmountRequest - The total amount of the line, including VAT and discounts.
//
// Should match the following formula: `(unitPrice × quantity) - discountAmount`.
//
// The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
type CreateCustomerPaymentTotalAmountRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentTotalAmountRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentTotalAmountRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentVatAmountRequest - The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
// calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
//
// Any deviations from this will result in an error.
//
// For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
// `SEK 100.00 × (25 / 125) = SEK 20.00`.
type CreateCustomerPaymentVatAmountRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentVatAmountRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentVatAmountRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type CreateCustomerPaymentCategoryRequest string

const (
	CreateCustomerPaymentCategoryRequestMeal         CreateCustomerPaymentCategoryRequest = "meal"
	CreateCustomerPaymentCategoryRequestEco          CreateCustomerPaymentCategoryRequest = "eco"
	CreateCustomerPaymentCategoryRequestGift         CreateCustomerPaymentCategoryRequest = "gift"
	CreateCustomerPaymentCategoryRequestSportCulture CreateCustomerPaymentCategoryRequest = "sport_culture"
)

func (e CreateCustomerPaymentCategoryRequest) ToPointer() *CreateCustomerPaymentCategoryRequest {
	return &e
}
func (e *CreateCustomerPaymentCategoryRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "meal":
		fallthrough
	case "eco":
		fallthrough
	case "gift":
		fallthrough
	case "sport_culture":
		*e = CreateCustomerPaymentCategoryRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCategoryRequest: %v", v)
	}
}

// CreateCustomerPaymentRecurringAmountRequest - Total amount and currency of the recurring item.
type CreateCustomerPaymentRecurringAmountRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentRecurringAmountRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentRecurringAmountRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentRecurringRequest - The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
// to inform the shopper of the details for recurring products in the payments.
type CreateCustomerPaymentRecurringRequest struct {
	// A description of the recurring item. If not present, the main description of the item will be used.
	Description *string `json:"description,omitempty"`
	// Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
	//
	// Possible values: `... days`, `... weeks`, `... months`.
	Interval string `json:"interval"`
	// Total amount and currency of the recurring item.
	Amount *CreateCustomerPaymentRecurringAmountRequest `json:"amount,omitempty"`
	// Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
	Times *int64 `json:"times,omitempty"`
	// The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
	StartDate *string `json:"startDate,omitempty"`
}

func (o *CreateCustomerPaymentRecurringRequest) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *CreateCustomerPaymentRecurringRequest) GetInterval() string {
	if o == nil {
		return ""
	}
	return o.Interval
}

func (o *CreateCustomerPaymentRecurringRequest) GetAmount() *CreateCustomerPaymentRecurringAmountRequest {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CreateCustomerPaymentRecurringRequest) GetTimes() *int64 {
	if o == nil {
		return nil
	}
	return o.Times
}

func (o *CreateCustomerPaymentRecurringRequest) GetStartDate() *string {
	if o == nil {
		return nil
	}
	return o.StartDate
}

type CreateCustomerPaymentLineRequest struct {
	// The type of product purchased. For example, a physical or a digital product.
	//
	// The `tip` payment line type is not available when creating a payment.
	Type *CreateCustomerPaymentLineTypeRequest `json:"type,omitempty"`
	// A description of the line item. For example *LEGO 4440 Forest Police Station*.
	Description string `json:"description"`
	// The number of items.
	Quantity int64 `json:"quantity"`
	// The unit for the quantity. For example *pcs*, *kg*, or *cm*.
	QuantityUnit *string `json:"quantityUnit,omitempty"`
	// The price of a single item including VAT.
	//
	// For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
	//
	// For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
	//
	// The unit price can be zero in case of free items.
	UnitPrice CreateCustomerPaymentUnitPriceRequest `json:"unitPrice"`
	// Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
	// type.
	DiscountAmount *CreateCustomerPaymentDiscountAmountRequest `json:"discountAmount,omitempty"`
	// The total amount of the line, including VAT and discounts.
	//
	// Should match the following formula: `(unitPrice × quantity) - discountAmount`.
	//
	// The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
	TotalAmount CreateCustomerPaymentTotalAmountRequest `json:"totalAmount"`
	// The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
	// not as a float, to ensure the correct number of decimals are passed.
	VatRate *string `json:"vatRate,omitempty"`
	// The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
	// calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
	//
	// Any deviations from this will result in an error.
	//
	// For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
	// `SEK 100.00 × (25 / 125) = SEK 20.00`.
	VatAmount *CreateCustomerPaymentVatAmountRequest `json:"vatAmount,omitempty"`
	// The SKU, EAN, ISBN or UPC of the product sold.
	Sku *string `json:"sku,omitempty"`
	// An array with the voucher categories, in case of a line eligible for a voucher. See the
	// [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
	Categories []CreateCustomerPaymentCategoryRequest `json:"categories,omitempty"`
	// A link pointing to an image of the product sold.
	ImageURL *string `json:"imageUrl,omitempty"`
	// A link pointing to the product page in your web shop of the product sold.
	ProductURL *string `json:"productUrl,omitempty"`
	// The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
	// to inform the shopper of the details for recurring products in the payments.
	Recurring *CreateCustomerPaymentRecurringRequest `json:"recurring,omitempty"`
}

func (o *CreateCustomerPaymentLineRequest) GetType() *CreateCustomerPaymentLineTypeRequest {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateCustomerPaymentLineRequest) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *CreateCustomerPaymentLineRequest) GetQuantity() int64 {
	if o == nil {
		return 0
	}
	return o.Quantity
}

func (o *CreateCustomerPaymentLineRequest) GetQuantityUnit() *string {
	if o == nil {
		return nil
	}
	return o.QuantityUnit
}

func (o *CreateCustomerPaymentLineRequest) GetUnitPrice() CreateCustomerPaymentUnitPriceRequest {
	if o == nil {
		return CreateCustomerPaymentUnitPriceRequest{}
	}
	return o.UnitPrice
}

func (o *CreateCustomerPaymentLineRequest) GetDiscountAmount() *CreateCustomerPaymentDiscountAmountRequest {
	if o == nil {
		return nil
	}
	return o.DiscountAmount
}

func (o *CreateCustomerPaymentLineRequest) GetTotalAmount() CreateCustomerPaymentTotalAmountRequest {
	if o == nil {
		return CreateCustomerPaymentTotalAmountRequest{}
	}
	return o.TotalAmount
}

func (o *CreateCustomerPaymentLineRequest) GetVatRate() *string {
	if o == nil {
		return nil
	}
	return o.VatRate
}

func (o *CreateCustomerPaymentLineRequest) GetVatAmount() *CreateCustomerPaymentVatAmountRequest {
	if o == nil {
		return nil
	}
	return o.VatAmount
}

func (o *CreateCustomerPaymentLineRequest) GetSku() *string {
	if o == nil {
		return nil
	}
	return o.Sku
}

func (o *CreateCustomerPaymentLineRequest) GetCategories() []CreateCustomerPaymentCategoryRequest {
	if o == nil {
		return nil
	}
	return o.Categories
}

func (o *CreateCustomerPaymentLineRequest) GetImageURL() *string {
	if o == nil {
		return nil
	}
	return o.ImageURL
}

func (o *CreateCustomerPaymentLineRequest) GetProductURL() *string {
	if o == nil {
		return nil
	}
	return o.ProductURL
}

func (o *CreateCustomerPaymentLineRequest) GetRecurring() *CreateCustomerPaymentRecurringRequest {
	if o == nil {
		return nil
	}
	return o.Recurring
}

// CreateCustomerPaymentBillingAddressRequest - The customer's billing address details. We advise to provide these details to improve fraud protection and
// conversion.
//
// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
// `country`.
//
// Required for payment method `in3`, `klarna`, `billie` and `riverty`.
type CreateCustomerPaymentBillingAddressRequest struct {
	// The title of the person, for example *Mr.* or *Mrs.*.
	Title *string `json:"title,omitempty"`
	// The given name (first name) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	GivenName *string `json:"givenName,omitempty"`
	// The given family name (surname) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	FamilyName *string `json:"familyName,omitempty"`
	// The name of the organization, in case the addressee is an organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// A street and street number.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	StreetAndNumber *string `json:"streetAndNumber,omitempty"`
	// Any additional addressing details, for example an apartment number.
	StreetAdditional *string `json:"streetAdditional,omitempty"`
	// A postal code. This field may be required if the provided country has a postal code system.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	PostalCode *string `json:"postalCode,omitempty"`
	// A valid e-mail address.
	//
	// If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
	// email upon payment creation. The language of the email will follow the locale parameter of the payment.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Email *string `json:"email,omitempty"`
	// If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
	Phone *string `json:"phone,omitempty"`
	// A city name.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	City *string `json:"city,omitempty"`
	// The top-level administrative subdivision of the country. For example: Noord-Holland.
	Region *string `json:"region,omitempty"`
	// A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Country *string `json:"country,omitempty"`
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetGivenName() *string {
	if o == nil {
		return nil
	}
	return o.GivenName
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetFamilyName() *string {
	if o == nil {
		return nil
	}
	return o.FamilyName
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetOrganizationName() *string {
	if o == nil {
		return nil
	}
	return o.OrganizationName
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetStreetAndNumber() *string {
	if o == nil {
		return nil
	}
	return o.StreetAndNumber
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetStreetAdditional() *string {
	if o == nil {
		return nil
	}
	return o.StreetAdditional
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetEmail() *string {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetPhone() *string {
	if o == nil {
		return nil
	}
	return o.Phone
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetCity() *string {
	if o == nil {
		return nil
	}
	return o.City
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetRegion() *string {
	if o == nil {
		return nil
	}
	return o.Region
}

func (o *CreateCustomerPaymentBillingAddressRequest) GetCountry() *string {
	if o == nil {
		return nil
	}
	return o.Country
}

// CreateCustomerPaymentShippingAddressRequest - The customer's shipping address details. We advise to provide these details to improve fraud protection and
// conversion.
//
// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
// `country`.
type CreateCustomerPaymentShippingAddressRequest struct {
	// The title of the person, for example *Mr.* or *Mrs.*.
	Title *string `json:"title,omitempty"`
	// The given name (first name) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	GivenName *string `json:"givenName,omitempty"`
	// The given family name (surname) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	FamilyName *string `json:"familyName,omitempty"`
	// The name of the organization, in case the addressee is an organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// A street and street number.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	StreetAndNumber *string `json:"streetAndNumber,omitempty"`
	// Any additional addressing details, for example an apartment number.
	StreetAdditional *string `json:"streetAdditional,omitempty"`
	// A postal code. This field may be required if the provided country has a postal code system.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	PostalCode *string `json:"postalCode,omitempty"`
	// A valid e-mail address.
	//
	// If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
	// email upon payment creation. The language of the email will follow the locale parameter of the payment.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Email *string `json:"email,omitempty"`
	// If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
	Phone *string `json:"phone,omitempty"`
	// A city name.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	City *string `json:"city,omitempty"`
	// The top-level administrative subdivision of the country. For example: Noord-Holland.
	Region *string `json:"region,omitempty"`
	// A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Country *string `json:"country,omitempty"`
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetGivenName() *string {
	if o == nil {
		return nil
	}
	return o.GivenName
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetFamilyName() *string {
	if o == nil {
		return nil
	}
	return o.FamilyName
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetOrganizationName() *string {
	if o == nil {
		return nil
	}
	return o.OrganizationName
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetStreetAndNumber() *string {
	if o == nil {
		return nil
	}
	return o.StreetAndNumber
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetStreetAdditional() *string {
	if o == nil {
		return nil
	}
	return o.StreetAdditional
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetEmail() *string {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetPhone() *string {
	if o == nil {
		return nil
	}
	return o.Phone
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetCity() *string {
	if o == nil {
		return nil
	}
	return o.City
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetRegion() *string {
	if o == nil {
		return nil
	}
	return o.Region
}

func (o *CreateCustomerPaymentShippingAddressRequest) GetCountry() *string {
	if o == nil {
		return nil
	}
	return o.Country
}

// CreateCustomerPaymentLocaleRequest - Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
// is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
// language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
// locale, but our hosted payment pages currently only support the specified languages.
//
// For bank transfer payments specifically, the locale will determine the target bank account the customer has to
// transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
// customer use a local bank account greatly increases the conversion and speed of payment.
type CreateCustomerPaymentLocaleRequest string

const (
	CreateCustomerPaymentLocaleRequestEnUs CreateCustomerPaymentLocaleRequest = "en_US"
	CreateCustomerPaymentLocaleRequestEnGb CreateCustomerPaymentLocaleRequest = "en_GB"
	CreateCustomerPaymentLocaleRequestNlNl CreateCustomerPaymentLocaleRequest = "nl_NL"
	CreateCustomerPaymentLocaleRequestNlBe CreateCustomerPaymentLocaleRequest = "nl_BE"
	CreateCustomerPaymentLocaleRequestDeDe CreateCustomerPaymentLocaleRequest = "de_DE"
	CreateCustomerPaymentLocaleRequestDeAt CreateCustomerPaymentLocaleRequest = "de_AT"
	CreateCustomerPaymentLocaleRequestDeCh CreateCustomerPaymentLocaleRequest = "de_CH"
	CreateCustomerPaymentLocaleRequestFrFr CreateCustomerPaymentLocaleRequest = "fr_FR"
	CreateCustomerPaymentLocaleRequestFrBe CreateCustomerPaymentLocaleRequest = "fr_BE"
	CreateCustomerPaymentLocaleRequestEsEs CreateCustomerPaymentLocaleRequest = "es_ES"
	CreateCustomerPaymentLocaleRequestCaEs CreateCustomerPaymentLocaleRequest = "ca_ES"
	CreateCustomerPaymentLocaleRequestPtPt CreateCustomerPaymentLocaleRequest = "pt_PT"
	CreateCustomerPaymentLocaleRequestItIt CreateCustomerPaymentLocaleRequest = "it_IT"
	CreateCustomerPaymentLocaleRequestNbNo CreateCustomerPaymentLocaleRequest = "nb_NO"
	CreateCustomerPaymentLocaleRequestSvSe CreateCustomerPaymentLocaleRequest = "sv_SE"
	CreateCustomerPaymentLocaleRequestFiFi CreateCustomerPaymentLocaleRequest = "fi_FI"
	CreateCustomerPaymentLocaleRequestDaDk CreateCustomerPaymentLocaleRequest = "da_DK"
	CreateCustomerPaymentLocaleRequestIsIs CreateCustomerPaymentLocaleRequest = "is_IS"
	CreateCustomerPaymentLocaleRequestHuHu CreateCustomerPaymentLocaleRequest = "hu_HU"
	CreateCustomerPaymentLocaleRequestPlPl CreateCustomerPaymentLocaleRequest = "pl_PL"
	CreateCustomerPaymentLocaleRequestLvLv CreateCustomerPaymentLocaleRequest = "lv_LV"
	CreateCustomerPaymentLocaleRequestLtLt CreateCustomerPaymentLocaleRequest = "lt_LT"
)

func (e CreateCustomerPaymentLocaleRequest) ToPointer() *CreateCustomerPaymentLocaleRequest {
	return &e
}
func (e *CreateCustomerPaymentLocaleRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "en_US":
		fallthrough
	case "en_GB":
		fallthrough
	case "nl_NL":
		fallthrough
	case "nl_BE":
		fallthrough
	case "de_DE":
		fallthrough
	case "de_AT":
		fallthrough
	case "de_CH":
		fallthrough
	case "fr_FR":
		fallthrough
	case "fr_BE":
		fallthrough
	case "es_ES":
		fallthrough
	case "ca_ES":
		fallthrough
	case "pt_PT":
		fallthrough
	case "it_IT":
		fallthrough
	case "nb_NO":
		fallthrough
	case "sv_SE":
		fallthrough
	case "fi_FI":
		fallthrough
	case "da_DK":
		fallthrough
	case "is_IS":
		fallthrough
	case "hu_HU":
		fallthrough
	case "pl_PL":
		fallthrough
	case "lv_LV":
		fallthrough
	case "lt_LT":
		*e = CreateCustomerPaymentLocaleRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentLocaleRequest: %v", v)
	}
}

// CreateCustomerPaymentMethodRequest - Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
// method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
// parameter enables you to fully integrate the payment method selection into your website.
//
// You can also specify the methods in an array. By doing so we will still show the payment method selection screen
// but will only show the methods specified in the array. For example, you can use this functionality to only show
// payment methods from a specific country to your customer `['bancontact', 'belfius']`.
type CreateCustomerPaymentMethodRequest string

const (
	CreateCustomerPaymentMethodRequestAlma           CreateCustomerPaymentMethodRequest = "alma"
	CreateCustomerPaymentMethodRequestApplepay       CreateCustomerPaymentMethodRequest = "applepay"
	CreateCustomerPaymentMethodRequestBacs           CreateCustomerPaymentMethodRequest = "bacs"
	CreateCustomerPaymentMethodRequestBancomatpay    CreateCustomerPaymentMethodRequest = "bancomatpay"
	CreateCustomerPaymentMethodRequestBancontact     CreateCustomerPaymentMethodRequest = "bancontact"
	CreateCustomerPaymentMethodRequestBanktransfer   CreateCustomerPaymentMethodRequest = "banktransfer"
	CreateCustomerPaymentMethodRequestBelfius        CreateCustomerPaymentMethodRequest = "belfius"
	CreateCustomerPaymentMethodRequestBillie         CreateCustomerPaymentMethodRequest = "billie"
	CreateCustomerPaymentMethodRequestBizum          CreateCustomerPaymentMethodRequest = "bizum"
	CreateCustomerPaymentMethodRequestBlik           CreateCustomerPaymentMethodRequest = "blik"
	CreateCustomerPaymentMethodRequestCreditcard     CreateCustomerPaymentMethodRequest = "creditcard"
	CreateCustomerPaymentMethodRequestDirectdebit    CreateCustomerPaymentMethodRequest = "directdebit"
	CreateCustomerPaymentMethodRequestEps            CreateCustomerPaymentMethodRequest = "eps"
	CreateCustomerPaymentMethodRequestGiftcard       CreateCustomerPaymentMethodRequest = "giftcard"
	CreateCustomerPaymentMethodRequestIdeal          CreateCustomerPaymentMethodRequest = "ideal"
	CreateCustomerPaymentMethodRequestIn3            CreateCustomerPaymentMethodRequest = "in3"
	CreateCustomerPaymentMethodRequestKbc            CreateCustomerPaymentMethodRequest = "kbc"
	CreateCustomerPaymentMethodRequestKlarna         CreateCustomerPaymentMethodRequest = "klarna"
	CreateCustomerPaymentMethodRequestKlarnapaylater CreateCustomerPaymentMethodRequest = "klarnapaylater"
	CreateCustomerPaymentMethodRequestKlarnapaynow   CreateCustomerPaymentMethodRequest = "klarnapaynow"
	CreateCustomerPaymentMethodRequestKlarnasliceit  CreateCustomerPaymentMethodRequest = "klarnasliceit"
	CreateCustomerPaymentMethodRequestMbway          CreateCustomerPaymentMethodRequest = "mbway"
	CreateCustomerPaymentMethodRequestMultibanco     CreateCustomerPaymentMethodRequest = "multibanco"
	CreateCustomerPaymentMethodRequestMybank         CreateCustomerPaymentMethodRequest = "mybank"
	CreateCustomerPaymentMethodRequestPaybybank      CreateCustomerPaymentMethodRequest = "paybybank"
	CreateCustomerPaymentMethodRequestPayconiq       CreateCustomerPaymentMethodRequest = "payconiq"
	CreateCustomerPaymentMethodRequestPaypal         CreateCustomerPaymentMethodRequest = "paypal"
	CreateCustomerPaymentMethodRequestPaysafecard    CreateCustomerPaymentMethodRequest = "paysafecard"
	CreateCustomerPaymentMethodRequestPointofsale    CreateCustomerPaymentMethodRequest = "pointofsale"
	CreateCustomerPaymentMethodRequestPrzelewy24     CreateCustomerPaymentMethodRequest = "przelewy24"
	CreateCustomerPaymentMethodRequestRiverty        CreateCustomerPaymentMethodRequest = "riverty"
	CreateCustomerPaymentMethodRequestSatispay       CreateCustomerPaymentMethodRequest = "satispay"
	CreateCustomerPaymentMethodRequestSwish          CreateCustomerPaymentMethodRequest = "swish"
	CreateCustomerPaymentMethodRequestTrustly        CreateCustomerPaymentMethodRequest = "trustly"
	CreateCustomerPaymentMethodRequestTwint          CreateCustomerPaymentMethodRequest = "twint"
	CreateCustomerPaymentMethodRequestVoucher        CreateCustomerPaymentMethodRequest = "voucher"
)

func (e CreateCustomerPaymentMethodRequest) ToPointer() *CreateCustomerPaymentMethodRequest {
	return &e
}
func (e *CreateCustomerPaymentMethodRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "alma":
		fallthrough
	case "applepay":
		fallthrough
	case "bacs":
		fallthrough
	case "bancomatpay":
		fallthrough
	case "bancontact":
		fallthrough
	case "banktransfer":
		fallthrough
	case "belfius":
		fallthrough
	case "billie":
		fallthrough
	case "bizum":
		fallthrough
	case "blik":
		fallthrough
	case "creditcard":
		fallthrough
	case "directdebit":
		fallthrough
	case "eps":
		fallthrough
	case "giftcard":
		fallthrough
	case "ideal":
		fallthrough
	case "in3":
		fallthrough
	case "kbc":
		fallthrough
	case "klarna":
		fallthrough
	case "klarnapaylater":
		fallthrough
	case "klarnapaynow":
		fallthrough
	case "klarnasliceit":
		fallthrough
	case "mbway":
		fallthrough
	case "multibanco":
		fallthrough
	case "mybank":
		fallthrough
	case "paybybank":
		fallthrough
	case "payconiq":
		fallthrough
	case "paypal":
		fallthrough
	case "paysafecard":
		fallthrough
	case "pointofsale":
		fallthrough
	case "przelewy24":
		fallthrough
	case "riverty":
		fallthrough
	case "satispay":
		fallthrough
	case "swish":
		fallthrough
	case "trustly":
		fallthrough
	case "twint":
		fallthrough
	case "voucher":
		*e = CreateCustomerPaymentMethodRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentMethodRequest: %v", v)
	}
}

type CreateCustomerPaymentMetadataRequestType string

const (
	CreateCustomerPaymentMetadataRequestTypeStr        CreateCustomerPaymentMetadataRequestType = "str"
	CreateCustomerPaymentMetadataRequestTypeMapOfAny   CreateCustomerPaymentMetadataRequestType = "mapOfAny"
	CreateCustomerPaymentMetadataRequestTypeArrayOfStr CreateCustomerPaymentMetadataRequestType = "arrayOfStr"
)

// CreateCustomerPaymentMetadataRequest - Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
// you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
type CreateCustomerPaymentMetadataRequest struct {
	Str        *string        `queryParam:"inline" name:"metadata"`
	MapOfAny   map[string]any `queryParam:"inline" name:"metadata"`
	ArrayOfStr []string       `queryParam:"inline" name:"metadata"`

	Type CreateCustomerPaymentMetadataRequestType
}

func CreateCreateCustomerPaymentMetadataRequestStr(str string) CreateCustomerPaymentMetadataRequest {
	typ := CreateCustomerPaymentMetadataRequestTypeStr

	return CreateCustomerPaymentMetadataRequest{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateCustomerPaymentMetadataRequestMapOfAny(mapOfAny map[string]any) CreateCustomerPaymentMetadataRequest {
	typ := CreateCustomerPaymentMetadataRequestTypeMapOfAny

	return CreateCustomerPaymentMetadataRequest{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreateCreateCustomerPaymentMetadataRequestArrayOfStr(arrayOfStr []string) CreateCustomerPaymentMetadataRequest {
	typ := CreateCustomerPaymentMetadataRequestTypeArrayOfStr

	return CreateCustomerPaymentMetadataRequest{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *CreateCustomerPaymentMetadataRequest) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateCustomerPaymentMetadataRequestTypeStr
		return nil
	}

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = CreateCustomerPaymentMetadataRequestTypeMapOfAny
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = CreateCustomerPaymentMetadataRequestTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateCustomerPaymentMetadataRequest", string(data))
}

func (u CreateCustomerPaymentMetadataRequest) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type CreateCustomerPaymentMetadataRequest: all fields are null")
}

// CreateCustomerPaymentCaptureModeRequest - Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
// and capture at a later time.
//
// This field needs to be set to `manual` for method `riverty`.
type CreateCustomerPaymentCaptureModeRequest string

const (
	CreateCustomerPaymentCaptureModeRequestAutomatic CreateCustomerPaymentCaptureModeRequest = "automatic"
	CreateCustomerPaymentCaptureModeRequestManual    CreateCustomerPaymentCaptureModeRequest = "manual"
)

func (e CreateCustomerPaymentCaptureModeRequest) ToPointer() *CreateCustomerPaymentCaptureModeRequest {
	return &e
}
func (e *CreateCustomerPaymentCaptureModeRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "automatic":
		fallthrough
	case "manual":
		*e = CreateCustomerPaymentCaptureModeRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCaptureModeRequest: %v", v)
	}
}

// CreateCustomerPaymentApplicationFeeAmountRequest - The fee that you wish to charge.
//
// Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
// a €0.99 fee on a €1.00 payment.
type CreateCustomerPaymentApplicationFeeAmountRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentApplicationFeeAmountRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentApplicationFeeAmountRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentApplicationFeeRequest - With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
// merchants.
//
// If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
// `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
// to your own account balance.
//
// If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
// `routing` parameter.
type CreateCustomerPaymentApplicationFeeRequest struct {
	// The fee that you wish to charge.
	//
	// Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
	// a €0.99 fee on a €1.00 payment.
	Amount *CreateCustomerPaymentApplicationFeeAmountRequest `json:"amount,omitempty"`
	// The description of the application fee. This will appear on settlement reports towards both you and the
	// connected merchant.
	Description *string `json:"description,omitempty"`
}

func (o *CreateCustomerPaymentApplicationFeeRequest) GetAmount() *CreateCustomerPaymentApplicationFeeAmountRequest {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CreateCustomerPaymentApplicationFeeRequest) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

// CreateCustomerPaymentRoutingAmountRequest - The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
type CreateCustomerPaymentRoutingAmountRequest struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentRoutingAmountRequest) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentRoutingAmountRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentRoutingTypeRequest - The type of destination. Currently only the destination type `organization` is supported.
type CreateCustomerPaymentRoutingTypeRequest string

const (
	CreateCustomerPaymentRoutingTypeRequestOrganization CreateCustomerPaymentRoutingTypeRequest = "organization"
)

func (e CreateCustomerPaymentRoutingTypeRequest) ToPointer() *CreateCustomerPaymentRoutingTypeRequest {
	return &e
}
func (e *CreateCustomerPaymentRoutingTypeRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "organization":
		*e = CreateCustomerPaymentRoutingTypeRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentRoutingTypeRequest: %v", v)
	}
}

// CreateCustomerPaymentDestinationRequest - The destination of this portion of the payment.
type CreateCustomerPaymentDestinationRequest struct {
	// The type of destination. Currently only the destination type `organization` is supported.
	Type CreateCustomerPaymentRoutingTypeRequest `json:"type"`
	// Required for destination type `organization`. The ID of the connected organization the funds should be
	// routed to.
	OrganizationID string `json:"organizationId"`
}

func (o *CreateCustomerPaymentDestinationRequest) GetType() CreateCustomerPaymentRoutingTypeRequest {
	if o == nil {
		return CreateCustomerPaymentRoutingTypeRequest("")
	}
	return o.Type
}

func (o *CreateCustomerPaymentDestinationRequest) GetOrganizationID() string {
	if o == nil {
		return ""
	}
	return o.OrganizationID
}

// CreateCustomerPaymentSelfRequest - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type CreateCustomerPaymentSelfRequest struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentSelfRequest) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentSelfRequest) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentPaymentRequest - The API resource URL of the [payment](get-payment) that belong to this route.
type CreateCustomerPaymentPaymentRequest struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentPaymentRequest) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentPaymentRequest) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentLinksRequest - An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
type CreateCustomerPaymentLinksRequest struct {
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Self CreateCustomerPaymentSelfRequest `json:"self"`
	// The API resource URL of the [payment](get-payment) that belong to this route.
	Payment CreateCustomerPaymentPaymentRequest `json:"payment"`
}

func (o *CreateCustomerPaymentLinksRequest) GetSelf() CreateCustomerPaymentSelfRequest {
	if o == nil {
		return CreateCustomerPaymentSelfRequest{}
	}
	return o.Self
}

func (o *CreateCustomerPaymentLinksRequest) GetPayment() CreateCustomerPaymentPaymentRequest {
	if o == nil {
		return CreateCustomerPaymentPaymentRequest{}
	}
	return o.Payment
}

type CreateCustomerPaymentRoutingRequest struct {
	// The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
	Amount CreateCustomerPaymentRoutingAmountRequest `json:"amount"`
	// The destination of this portion of the payment.
	Destination CreateCustomerPaymentDestinationRequest `json:"destination"`
	// Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
	// date must be given in `YYYY-MM-DD` format.
	//
	// If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
	ReleaseDate *string `json:"releaseDate,omitempty"`
	// An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
	Links CreateCustomerPaymentLinksRequest `json:"_links"`
}

func (o *CreateCustomerPaymentRoutingRequest) GetAmount() CreateCustomerPaymentRoutingAmountRequest {
	if o == nil {
		return CreateCustomerPaymentRoutingAmountRequest{}
	}
	return o.Amount
}

func (o *CreateCustomerPaymentRoutingRequest) GetDestination() CreateCustomerPaymentDestinationRequest {
	if o == nil {
		return CreateCustomerPaymentDestinationRequest{}
	}
	return o.Destination
}

func (o *CreateCustomerPaymentRoutingRequest) GetReleaseDate() *string {
	if o == nil {
		return nil
	}
	return o.ReleaseDate
}

func (o *CreateCustomerPaymentRoutingRequest) GetLinks() CreateCustomerPaymentLinksRequest {
	if o == nil {
		return CreateCustomerPaymentLinksRequest{}
	}
	return o.Links
}

// CreateCustomerPaymentSequenceTypeRequest - **Only relevant for recurring payments.**
//
// Indicate which part of a recurring sequence this payment is for.
//
// Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
// through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
// on their account in the future.
//
// If set to `recurring`, the customer's card is charged automatically.
//
// Defaults to `oneoff`, which is a regular non-recurring payment.
//
// For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
// [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
// are set up correctly for recurring payments.
type CreateCustomerPaymentSequenceTypeRequest string

const (
	CreateCustomerPaymentSequenceTypeRequestOneoff    CreateCustomerPaymentSequenceTypeRequest = "oneoff"
	CreateCustomerPaymentSequenceTypeRequestFirst     CreateCustomerPaymentSequenceTypeRequest = "first"
	CreateCustomerPaymentSequenceTypeRequestRecurring CreateCustomerPaymentSequenceTypeRequest = "recurring"
)

func (e CreateCustomerPaymentSequenceTypeRequest) ToPointer() *CreateCustomerPaymentSequenceTypeRequest {
	return &e
}
func (e *CreateCustomerPaymentSequenceTypeRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oneoff":
		fallthrough
	case "first":
		fallthrough
	case "recurring":
		*e = CreateCustomerPaymentSequenceTypeRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentSequenceTypeRequest: %v", v)
	}
}

// CreateCustomerPaymentCompany - Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
// that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
// Otherwise, Billie will ask the customer to complete the missing fields during checkout.
type CreateCustomerPaymentCompany struct {
	// The organization's registration number.
	RegistrationNumber *string `json:"registrationNumber,omitempty"`
	// The organization's VAT number.
	VatNumber *string `json:"vatNumber,omitempty"`
	// The organization's entity type.
	EntityType *string `json:"entityType,omitempty"`
}

func (o *CreateCustomerPaymentCompany) GetRegistrationNumber() *string {
	if o == nil {
		return nil
	}
	return o.RegistrationNumber
}

func (o *CreateCustomerPaymentCompany) GetVatNumber() *string {
	if o == nil {
		return nil
	}
	return o.VatNumber
}

func (o *CreateCustomerPaymentCompany) GetEntityType() *string {
	if o == nil {
		return nil
	}
	return o.EntityType
}

type CreateCustomerPaymentRequestBody struct {
	// The description of the payment. This will be shown to your customer on their card or bank statement when possible.
	// We truncate the description automatically according to the limits of the used payment method. The description is
	// also visible in any exports you generate.
	//
	// We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
	// This is particularly useful for bookkeeping.
	//
	// The maximum length of the description field differs per payment method, with the absolute maximum being 255
	// characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
	Description string `json:"description"`
	// The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
	//
	// You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
	// retrieved using the Get method endpoint.
	//
	// If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
	// tip amount.
	Amount CreateCustomerPaymentAmountRequest `json:"amount"`
	// The URL your customer will be redirected to after the payment process.
	//
	// It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
	// right page referencing the order when your customer returns.
	//
	// The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
	// Apple Pay payments with an `applePayPaymentToken`.
	RedirectURL *string `json:"redirectUrl"`
	// The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
	// provided, the customer will be redirected to the `redirectUrl` instead — see above.
	//
	// Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
	// therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
	// payment cancellations.
	CancelURL *string `json:"cancelUrl,omitempty"`
	// The webhook URL where we will send payment status updates to.
	//
	// The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
	//
	// The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
	// webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
	// local machine.
	WebhookURL *string `json:"webhookUrl,omitempty"`
	// Optionally provide the order lines for the payment. Each line contains details such as a description of the item
	// ordered and its price.
	//
	// All lines must have the same currency as the payment.
	//
	// Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
	Lines []CreateCustomerPaymentLineRequest `json:"lines,omitempty"`
	// The customer's billing address details. We advise to provide these details to improve fraud protection and
	// conversion.
	//
	// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
	// `country`.
	//
	// Required for payment method `in3`, `klarna`, `billie` and `riverty`.
	BillingAddress *CreateCustomerPaymentBillingAddressRequest `json:"billingAddress,omitempty"`
	// The customer's shipping address details. We advise to provide these details to improve fraud protection and
	// conversion.
	//
	// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
	// `country`.
	ShippingAddress *CreateCustomerPaymentShippingAddressRequest `json:"shippingAddress,omitempty"`
	// Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
	// is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
	// language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
	// locale, but our hosted payment pages currently only support the specified languages.
	//
	// For bank transfer payments specifically, the locale will determine the target bank account the customer has to
	// transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
	// customer use a local bank account greatly increases the conversion and speed of payment.
	Locale *CreateCustomerPaymentLocaleRequest `json:"locale,omitempty"`
	// Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
	// method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
	// parameter enables you to fully integrate the payment method selection into your website.
	//
	// You can also specify the methods in an array. By doing so we will still show the payment method selection screen
	// but will only show the methods specified in the array. For example, you can use this functionality to only show
	// payment methods from a specific country to your customer `['bancontact', 'belfius']`.
	Method *CreateCustomerPaymentMethodRequest `json:"method,omitempty"`
	// **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
	//
	// **⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
	// on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
	//
	// Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
	// method, the customer may still need to select the appropriate issuer before the payment can proceed.
	//
	// We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
	// up front.
	//
	// The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
	// `issuers` include.
	//
	// A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
	Issuer *string `json:"issuer,omitempty"`
	// For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
	// rates you have used for the order to ensure your customer's country matches the VAT country.
	//
	// Use this parameter to restrict the payment methods available to your customer to those from a single country.
	//
	// If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
	//
	// The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
	RestrictPaymentMethodsToCountry *string `json:"restrictPaymentMethodsToCountry,omitempty"`
	// Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
	// you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
	Metadata *CreateCustomerPaymentMetadataRequest `json:"metadata,omitempty"`
	// Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
	// and capture at a later time.
	//
	// This field needs to be set to `manual` for method `riverty`.
	CaptureMode *CreateCustomerPaymentCaptureModeRequest `json:"captureMode,omitempty"`
	// **Only relevant if you wish to manage authorization and capturing separately.**
	//
	// Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
	// later point either be 'captured' or canceled.
	//
	// By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
	// capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
	// example `8 hours` or `2 days`.
	//
	// To schedule an automatic capture, the `captureMode` must be set to `automatic`.
	//
	// The maximum delay is 7 days (168 hours).
	//
	// Possible values: `... hours` `... days`
	CaptureDelay *string `json:"captureDelay,omitempty"`
	// With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
	// merchants.
	//
	// If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
	// `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
	// to your own account balance.
	//
	// If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
	// `routing` parameter.
	ApplicationFee *CreateCustomerPaymentApplicationFeeRequest `json:"applicationFee,omitempty"`
	// *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
	//
	// With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
	// merchants.
	//
	// If you create payments on your own account that you want to split between yourself and one or more connected
	// merchants, you can use this `routing` parameter to route the payment accordingly.
	//
	// The `routing` parameter should contain an array of objects, with each object describing the destination for a
	// specific portion of the payment.
	//
	// It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
	// payment amount have been routed, the amount left will be routed to the current organization automatically.
	//
	// If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
	// parameter.
	Routing []CreateCustomerPaymentRoutingRequest `json:"routing,omitempty"`
	// **Only relevant for recurring payments.**
	//
	// Indicate which part of a recurring sequence this payment is for.
	//
	// Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
	// through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
	// on their account in the future.
	//
	// If set to `recurring`, the customer's card is charged automatically.
	//
	// Defaults to `oneoff`, which is a regular non-recurring payment.
	//
	// For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
	// [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
	// are set up correctly for recurring payments.
	SequenceType *CreateCustomerPaymentSequenceTypeRequest `json:"sequenceType,omitempty"`
	// **Only relevant for recurring payments.**
	//
	// When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
	// the customer's accounts should be credited.
	MandateID *string `json:"mandateId,omitempty"`
	// The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
	// payments, but can also be used on regular payments to enable single-click payments.
	//
	// If `sequenceType` is set to `recurring`, this field is required.
	CustomerID *string `json:"customerId,omitempty"`
	// The identifier referring to the [profile](get-profile) this entity belongs to.
	//
	// When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
	// Organization tokens, the `profileId` is required.
	//
	// For more information, see [Authentication](authentication).
	ProfileID *string `json:"profileId,omitempty"`
	// The date by which the payment should be completed in `YYYY-MM-DD` format
	DueDate *string `json:"dueDate,omitempty"`
	// Whether to create the entity in test mode or live mode.
	//
	// Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
	// omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
	// `testmode` to `true`.
	Testmode *bool `json:"testmode,omitempty"`
	// The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
	// The token contains the payment information needed to authorize the payment.
	//
	// The object should be passed encoded in a JSON string.
	ApplePayPaymentToken *string `json:"applePayPaymentToken,omitempty"`
	// Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
	// that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
	// Otherwise, Billie will ask the customer to complete the missing fields during checkout.
	Company *CreateCustomerPaymentCompany `json:"company,omitempty"`
	// When creating credit card payments using Mollie Components, you need to provide the card token you received from
	// the card component in this field. The token represents the customer's card information needed to complete the
	// payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
	// enough.
	CardToken *string `json:"cardToken,omitempty"`
	// The card token you received from the card component of Mollie Components. The token represents the customer's card
	// information needed to complete the payment.
	VoucherNumber *string `json:"voucherNumber,omitempty"`
	// The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
	VoucherPin *string `json:"voucherPin,omitempty"`
	// The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
	// the payment process.
	ConsumerDateOfBirth *types.Date `json:"consumerDateOfBirth,omitempty"`
	// For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
	// You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
	// object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
	ExtraMerchantData map[string]any `json:"extraMerchantData,omitempty"`
	// The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
	// on-demand payment.
	SessionID *string `json:"sessionId,omitempty"`
	// Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
	// can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
	DigitalGoods *bool `json:"digitalGoods,omitempty"`
	// Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
	// make sure not to put personal identifiable information or IP addresses in the customer reference directly.
	CustomerReference *string `json:"customerReference,omitempty"`
	// The ID of the terminal device where you want to initiate the payment on.
	TerminalID *string `json:"terminalId,omitempty"`
}

func (c CreateCustomerPaymentRequestBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateCustomerPaymentRequestBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"description", "amount", "redirectUrl"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateCustomerPaymentRequestBody) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *CreateCustomerPaymentRequestBody) GetAmount() CreateCustomerPaymentAmountRequest {
	if o == nil {
		return CreateCustomerPaymentAmountRequest{}
	}
	return o.Amount
}

func (o *CreateCustomerPaymentRequestBody) GetRedirectURL() *string {
	if o == nil {
		return nil
	}
	return o.RedirectURL
}

func (o *CreateCustomerPaymentRequestBody) GetCancelURL() *string {
	if o == nil {
		return nil
	}
	return o.CancelURL
}

func (o *CreateCustomerPaymentRequestBody) GetWebhookURL() *string {
	if o == nil {
		return nil
	}
	return o.WebhookURL
}

func (o *CreateCustomerPaymentRequestBody) GetLines() []CreateCustomerPaymentLineRequest {
	if o == nil {
		return nil
	}
	return o.Lines
}

func (o *CreateCustomerPaymentRequestBody) GetBillingAddress() *CreateCustomerPaymentBillingAddressRequest {
	if o == nil {
		return nil
	}
	return o.BillingAddress
}

func (o *CreateCustomerPaymentRequestBody) GetShippingAddress() *CreateCustomerPaymentShippingAddressRequest {
	if o == nil {
		return nil
	}
	return o.ShippingAddress
}

func (o *CreateCustomerPaymentRequestBody) GetLocale() *CreateCustomerPaymentLocaleRequest {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *CreateCustomerPaymentRequestBody) GetMethod() *CreateCustomerPaymentMethodRequest {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *CreateCustomerPaymentRequestBody) GetIssuer() *string {
	if o == nil {
		return nil
	}
	return o.Issuer
}

func (o *CreateCustomerPaymentRequestBody) GetRestrictPaymentMethodsToCountry() *string {
	if o == nil {
		return nil
	}
	return o.RestrictPaymentMethodsToCountry
}

func (o *CreateCustomerPaymentRequestBody) GetMetadata() *CreateCustomerPaymentMetadataRequest {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *CreateCustomerPaymentRequestBody) GetCaptureMode() *CreateCustomerPaymentCaptureModeRequest {
	if o == nil {
		return nil
	}
	return o.CaptureMode
}

func (o *CreateCustomerPaymentRequestBody) GetCaptureDelay() *string {
	if o == nil {
		return nil
	}
	return o.CaptureDelay
}

func (o *CreateCustomerPaymentRequestBody) GetApplicationFee() *CreateCustomerPaymentApplicationFeeRequest {
	if o == nil {
		return nil
	}
	return o.ApplicationFee
}

func (o *CreateCustomerPaymentRequestBody) GetRouting() []CreateCustomerPaymentRoutingRequest {
	if o == nil {
		return nil
	}
	return o.Routing
}

func (o *CreateCustomerPaymentRequestBody) GetSequenceType() *CreateCustomerPaymentSequenceTypeRequest {
	if o == nil {
		return nil
	}
	return o.SequenceType
}

func (o *CreateCustomerPaymentRequestBody) GetMandateID() *string {
	if o == nil {
		return nil
	}
	return o.MandateID
}

func (o *CreateCustomerPaymentRequestBody) GetCustomerID() *string {
	if o == nil {
		return nil
	}
	return o.CustomerID
}

func (o *CreateCustomerPaymentRequestBody) GetProfileID() *string {
	if o == nil {
		return nil
	}
	return o.ProfileID
}

func (o *CreateCustomerPaymentRequestBody) GetDueDate() *string {
	if o == nil {
		return nil
	}
	return o.DueDate
}

func (o *CreateCustomerPaymentRequestBody) GetTestmode() *bool {
	if o == nil {
		return nil
	}
	return o.Testmode
}

func (o *CreateCustomerPaymentRequestBody) GetApplePayPaymentToken() *string {
	if o == nil {
		return nil
	}
	return o.ApplePayPaymentToken
}

func (o *CreateCustomerPaymentRequestBody) GetCompany() *CreateCustomerPaymentCompany {
	if o == nil {
		return nil
	}
	return o.Company
}

func (o *CreateCustomerPaymentRequestBody) GetCardToken() *string {
	if o == nil {
		return nil
	}
	return o.CardToken
}

func (o *CreateCustomerPaymentRequestBody) GetVoucherNumber() *string {
	if o == nil {
		return nil
	}
	return o.VoucherNumber
}

func (o *CreateCustomerPaymentRequestBody) GetVoucherPin() *string {
	if o == nil {
		return nil
	}
	return o.VoucherPin
}

func (o *CreateCustomerPaymentRequestBody) GetConsumerDateOfBirth() *types.Date {
	if o == nil {
		return nil
	}
	return o.ConsumerDateOfBirth
}

func (o *CreateCustomerPaymentRequestBody) GetExtraMerchantData() map[string]any {
	if o == nil {
		return nil
	}
	return o.ExtraMerchantData
}

func (o *CreateCustomerPaymentRequestBody) GetSessionID() *string {
	if o == nil {
		return nil
	}
	return o.SessionID
}

func (o *CreateCustomerPaymentRequestBody) GetDigitalGoods() *bool {
	if o == nil {
		return nil
	}
	return o.DigitalGoods
}

func (o *CreateCustomerPaymentRequestBody) GetCustomerReference() *string {
	if o == nil {
		return nil
	}
	return o.CustomerReference
}

func (o *CreateCustomerPaymentRequestBody) GetTerminalID() *string {
	if o == nil {
		return nil
	}
	return o.TerminalID
}

type CreateCustomerPaymentRequest struct {
	// Provide the ID of the related customer.
	CustomerID  string                            `pathParam:"style=simple,explode=false,name=customerId"`
	RequestBody *CreateCustomerPaymentRequestBody `request:"mediaType=application/json"`
}

func (o *CreateCustomerPaymentRequest) GetCustomerID() string {
	if o == nil {
		return ""
	}
	return o.CustomerID
}

func (o *CreateCustomerPaymentRequest) GetRequestBody() *CreateCustomerPaymentRequestBody {
	if o == nil {
		return nil
	}
	return o.RequestBody
}

// CreateCustomerPaymentServiceUnavailableDocumentation - The URL to the generic Mollie API error handling guide.
type CreateCustomerPaymentServiceUnavailableDocumentation struct {
	Href string `json:"href"`
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentServiceUnavailableDocumentation) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentServiceUnavailableDocumentation) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

type CreateCustomerPaymentServiceUnavailableLinks struct {
	// The URL to the generic Mollie API error handling guide.
	Documentation CreateCustomerPaymentServiceUnavailableDocumentation `json:"documentation"`
}

func (o *CreateCustomerPaymentServiceUnavailableLinks) GetDocumentation() CreateCustomerPaymentServiceUnavailableDocumentation {
	if o == nil {
		return CreateCustomerPaymentServiceUnavailableDocumentation{}
	}
	return o.Documentation
}

// CreateCustomerPaymentUnprocessableEntityDocumentation - The URL to the generic Mollie API error handling guide.
type CreateCustomerPaymentUnprocessableEntityDocumentation struct {
	Href string `json:"href"`
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentUnprocessableEntityDocumentation) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentUnprocessableEntityDocumentation) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

type CreateCustomerPaymentUnprocessableEntityLinks struct {
	// The URL to the generic Mollie API error handling guide.
	Documentation CreateCustomerPaymentUnprocessableEntityDocumentation `json:"documentation"`
}

func (o *CreateCustomerPaymentUnprocessableEntityLinks) GetDocumentation() CreateCustomerPaymentUnprocessableEntityDocumentation {
	if o == nil {
		return CreateCustomerPaymentUnprocessableEntityDocumentation{}
	}
	return o.Documentation
}

// CreateCustomerPaymentMode - Whether this entity was created in live mode or in test mode.
type CreateCustomerPaymentMode string

const (
	CreateCustomerPaymentModeLive CreateCustomerPaymentMode = "live"
	CreateCustomerPaymentModeTest CreateCustomerPaymentMode = "test"
)

func (e CreateCustomerPaymentMode) ToPointer() *CreateCustomerPaymentMode {
	return &e
}
func (e *CreateCustomerPaymentMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "live":
		fallthrough
	case "test":
		*e = CreateCustomerPaymentMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentMode: %v", v)
	}
}

// CreateCustomerPaymentAmountResponse - The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
//
// You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
// retrieved using the Get method endpoint.
//
// If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
// tip amount.
type CreateCustomerPaymentAmountResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentAmountResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentAmountResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentAmountRefunded - The total amount that is already refunded. Only available when refunds are available for this payment. For some
// payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
// costs for a return shipment to the customer.
type CreateCustomerPaymentAmountRefunded struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentAmountRefunded) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentAmountRefunded) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentAmountRemaining - The remaining amount that can be refunded. Only available when refunds are available for this payment.
type CreateCustomerPaymentAmountRemaining struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentAmountRemaining) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentAmountRemaining) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentAmountCaptured - The total amount that is already captured for this payment. Only available when this payment supports captures.
type CreateCustomerPaymentAmountCaptured struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentAmountCaptured) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentAmountCaptured) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentAmountChargedBack - The total amount that was charged back for this payment. Only available when the total charged back amount is not
// zero.
type CreateCustomerPaymentAmountChargedBack struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentAmountChargedBack) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentAmountChargedBack) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentSettlementAmount - This optional field will contain the approximate amount that will be settled to your account, converted to the
// currency your account is settled in.
//
// Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
// settled by Mollie the `settlementAmount` is omitted from the response.
//
// Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
// using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
type CreateCustomerPaymentSettlementAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentSettlementAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentSettlementAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentLineTypeResponse - The type of product purchased. For example, a physical or a digital product.
//
// The `tip` payment line type is not available when creating a payment.
type CreateCustomerPaymentLineTypeResponse string

const (
	CreateCustomerPaymentLineTypeResponsePhysical    CreateCustomerPaymentLineTypeResponse = "physical"
	CreateCustomerPaymentLineTypeResponseDigital     CreateCustomerPaymentLineTypeResponse = "digital"
	CreateCustomerPaymentLineTypeResponseShippingFee CreateCustomerPaymentLineTypeResponse = "shipping_fee"
	CreateCustomerPaymentLineTypeResponseDiscount    CreateCustomerPaymentLineTypeResponse = "discount"
	CreateCustomerPaymentLineTypeResponseStoreCredit CreateCustomerPaymentLineTypeResponse = "store_credit"
	CreateCustomerPaymentLineTypeResponseGiftCard    CreateCustomerPaymentLineTypeResponse = "gift_card"
	CreateCustomerPaymentLineTypeResponseSurcharge   CreateCustomerPaymentLineTypeResponse = "surcharge"
	CreateCustomerPaymentLineTypeResponseTip         CreateCustomerPaymentLineTypeResponse = "tip"
)

func (e CreateCustomerPaymentLineTypeResponse) ToPointer() *CreateCustomerPaymentLineTypeResponse {
	return &e
}
func (e *CreateCustomerPaymentLineTypeResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "physical":
		fallthrough
	case "digital":
		fallthrough
	case "shipping_fee":
		fallthrough
	case "discount":
		fallthrough
	case "store_credit":
		fallthrough
	case "gift_card":
		fallthrough
	case "surcharge":
		fallthrough
	case "tip":
		*e = CreateCustomerPaymentLineTypeResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentLineTypeResponse: %v", v)
	}
}

// CreateCustomerPaymentUnitPriceResponse - The price of a single item including VAT.
//
// For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
//
// For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
//
// The unit price can be zero in case of free items.
type CreateCustomerPaymentUnitPriceResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentUnitPriceResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentUnitPriceResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentDiscountAmountResponse - Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
// type.
type CreateCustomerPaymentDiscountAmountResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentDiscountAmountResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentDiscountAmountResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentTotalAmountResponse - The total amount of the line, including VAT and discounts.
//
// Should match the following formula: `(unitPrice × quantity) - discountAmount`.
//
// The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
type CreateCustomerPaymentTotalAmountResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentTotalAmountResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentTotalAmountResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentVatAmountResponse - The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
// calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
//
// Any deviations from this will result in an error.
//
// For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
// `SEK 100.00 × (25 / 125) = SEK 20.00`.
type CreateCustomerPaymentVatAmountResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentVatAmountResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentVatAmountResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type CreateCustomerPaymentCategoryResponse string

const (
	CreateCustomerPaymentCategoryResponseMeal         CreateCustomerPaymentCategoryResponse = "meal"
	CreateCustomerPaymentCategoryResponseEco          CreateCustomerPaymentCategoryResponse = "eco"
	CreateCustomerPaymentCategoryResponseGift         CreateCustomerPaymentCategoryResponse = "gift"
	CreateCustomerPaymentCategoryResponseSportCulture CreateCustomerPaymentCategoryResponse = "sport_culture"
)

func (e CreateCustomerPaymentCategoryResponse) ToPointer() *CreateCustomerPaymentCategoryResponse {
	return &e
}
func (e *CreateCustomerPaymentCategoryResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "meal":
		fallthrough
	case "eco":
		fallthrough
	case "gift":
		fallthrough
	case "sport_culture":
		*e = CreateCustomerPaymentCategoryResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCategoryResponse: %v", v)
	}
}

// CreateCustomerPaymentRecurringAmountResponse - Total amount and currency of the recurring item.
type CreateCustomerPaymentRecurringAmountResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentRecurringAmountResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentRecurringAmountResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentRecurringResponse - The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
// to inform the shopper of the details for recurring products in the payments.
type CreateCustomerPaymentRecurringResponse struct {
	// A description of the recurring item. If not present, the main description of the item will be used.
	Description *string `json:"description,omitempty"`
	// Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
	//
	// Possible values: `... days`, `... weeks`, `... months`.
	Interval string `json:"interval"`
	// Total amount and currency of the recurring item.
	Amount *CreateCustomerPaymentRecurringAmountResponse `json:"amount,omitempty"`
	// Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
	Times *int64 `json:"times,omitempty"`
	// The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
	StartDate *string `json:"startDate,omitempty"`
}

func (o *CreateCustomerPaymentRecurringResponse) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *CreateCustomerPaymentRecurringResponse) GetInterval() string {
	if o == nil {
		return ""
	}
	return o.Interval
}

func (o *CreateCustomerPaymentRecurringResponse) GetAmount() *CreateCustomerPaymentRecurringAmountResponse {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CreateCustomerPaymentRecurringResponse) GetTimes() *int64 {
	if o == nil {
		return nil
	}
	return o.Times
}

func (o *CreateCustomerPaymentRecurringResponse) GetStartDate() *string {
	if o == nil {
		return nil
	}
	return o.StartDate
}

type CreateCustomerPaymentLineResponse struct {
	// The type of product purchased. For example, a physical or a digital product.
	//
	// The `tip` payment line type is not available when creating a payment.
	Type *CreateCustomerPaymentLineTypeResponse `json:"type,omitempty"`
	// A description of the line item. For example *LEGO 4440 Forest Police Station*.
	Description string `json:"description"`
	// The number of items.
	Quantity int64 `json:"quantity"`
	// The unit for the quantity. For example *pcs*, *kg*, or *cm*.
	QuantityUnit *string `json:"quantityUnit,omitempty"`
	// The price of a single item including VAT.
	//
	// For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
	//
	// For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
	//
	// The unit price can be zero in case of free items.
	UnitPrice CreateCustomerPaymentUnitPriceResponse `json:"unitPrice"`
	// Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
	// type.
	DiscountAmount *CreateCustomerPaymentDiscountAmountResponse `json:"discountAmount,omitempty"`
	// The total amount of the line, including VAT and discounts.
	//
	// Should match the following formula: `(unitPrice × quantity) - discountAmount`.
	//
	// The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
	TotalAmount CreateCustomerPaymentTotalAmountResponse `json:"totalAmount"`
	// The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
	// not as a float, to ensure the correct number of decimals are passed.
	VatRate *string `json:"vatRate,omitempty"`
	// The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
	// calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
	//
	// Any deviations from this will result in an error.
	//
	// For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
	// `SEK 100.00 × (25 / 125) = SEK 20.00`.
	VatAmount *CreateCustomerPaymentVatAmountResponse `json:"vatAmount,omitempty"`
	// The SKU, EAN, ISBN or UPC of the product sold.
	Sku *string `json:"sku,omitempty"`
	// An array with the voucher categories, in case of a line eligible for a voucher. See the
	// [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
	Categories []CreateCustomerPaymentCategoryResponse `json:"categories,omitempty"`
	// A link pointing to an image of the product sold.
	ImageURL *string `json:"imageUrl,omitempty"`
	// A link pointing to the product page in your web shop of the product sold.
	ProductURL *string `json:"productUrl,omitempty"`
	// The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
	// to inform the shopper of the details for recurring products in the payments.
	Recurring *CreateCustomerPaymentRecurringResponse `json:"recurring,omitempty"`
}

func (o *CreateCustomerPaymentLineResponse) GetType() *CreateCustomerPaymentLineTypeResponse {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateCustomerPaymentLineResponse) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *CreateCustomerPaymentLineResponse) GetQuantity() int64 {
	if o == nil {
		return 0
	}
	return o.Quantity
}

func (o *CreateCustomerPaymentLineResponse) GetQuantityUnit() *string {
	if o == nil {
		return nil
	}
	return o.QuantityUnit
}

func (o *CreateCustomerPaymentLineResponse) GetUnitPrice() CreateCustomerPaymentUnitPriceResponse {
	if o == nil {
		return CreateCustomerPaymentUnitPriceResponse{}
	}
	return o.UnitPrice
}

func (o *CreateCustomerPaymentLineResponse) GetDiscountAmount() *CreateCustomerPaymentDiscountAmountResponse {
	if o == nil {
		return nil
	}
	return o.DiscountAmount
}

func (o *CreateCustomerPaymentLineResponse) GetTotalAmount() CreateCustomerPaymentTotalAmountResponse {
	if o == nil {
		return CreateCustomerPaymentTotalAmountResponse{}
	}
	return o.TotalAmount
}

func (o *CreateCustomerPaymentLineResponse) GetVatRate() *string {
	if o == nil {
		return nil
	}
	return o.VatRate
}

func (o *CreateCustomerPaymentLineResponse) GetVatAmount() *CreateCustomerPaymentVatAmountResponse {
	if o == nil {
		return nil
	}
	return o.VatAmount
}

func (o *CreateCustomerPaymentLineResponse) GetSku() *string {
	if o == nil {
		return nil
	}
	return o.Sku
}

func (o *CreateCustomerPaymentLineResponse) GetCategories() []CreateCustomerPaymentCategoryResponse {
	if o == nil {
		return nil
	}
	return o.Categories
}

func (o *CreateCustomerPaymentLineResponse) GetImageURL() *string {
	if o == nil {
		return nil
	}
	return o.ImageURL
}

func (o *CreateCustomerPaymentLineResponse) GetProductURL() *string {
	if o == nil {
		return nil
	}
	return o.ProductURL
}

func (o *CreateCustomerPaymentLineResponse) GetRecurring() *CreateCustomerPaymentRecurringResponse {
	if o == nil {
		return nil
	}
	return o.Recurring
}

// CreateCustomerPaymentBillingAddressResponse - The customer's billing address details. We advise to provide these details to improve fraud protection and
// conversion.
//
// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
// `country`.
//
// Required for payment method `in3`, `klarna`, `billie` and `riverty`.
type CreateCustomerPaymentBillingAddressResponse struct {
	// The title of the person, for example *Mr.* or *Mrs.*.
	Title *string `json:"title,omitempty"`
	// The given name (first name) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	GivenName *string `json:"givenName,omitempty"`
	// The given family name (surname) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	FamilyName *string `json:"familyName,omitempty"`
	// The name of the organization, in case the addressee is an organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// A street and street number.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	StreetAndNumber *string `json:"streetAndNumber,omitempty"`
	// Any additional addressing details, for example an apartment number.
	StreetAdditional *string `json:"streetAdditional,omitempty"`
	// A postal code. This field may be required if the provided country has a postal code system.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	PostalCode *string `json:"postalCode,omitempty"`
	// A valid e-mail address.
	//
	// If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
	// email upon payment creation. The language of the email will follow the locale parameter of the payment.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Email *string `json:"email,omitempty"`
	// If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
	Phone *string `json:"phone,omitempty"`
	// A city name.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	City *string `json:"city,omitempty"`
	// The top-level administrative subdivision of the country. For example: Noord-Holland.
	Region *string `json:"region,omitempty"`
	// A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Country *string `json:"country,omitempty"`
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetGivenName() *string {
	if o == nil {
		return nil
	}
	return o.GivenName
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetFamilyName() *string {
	if o == nil {
		return nil
	}
	return o.FamilyName
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetOrganizationName() *string {
	if o == nil {
		return nil
	}
	return o.OrganizationName
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetStreetAndNumber() *string {
	if o == nil {
		return nil
	}
	return o.StreetAndNumber
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetStreetAdditional() *string {
	if o == nil {
		return nil
	}
	return o.StreetAdditional
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetEmail() *string {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetPhone() *string {
	if o == nil {
		return nil
	}
	return o.Phone
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetCity() *string {
	if o == nil {
		return nil
	}
	return o.City
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetRegion() *string {
	if o == nil {
		return nil
	}
	return o.Region
}

func (o *CreateCustomerPaymentBillingAddressResponse) GetCountry() *string {
	if o == nil {
		return nil
	}
	return o.Country
}

// CreateCustomerPaymentShippingAddressResponse - The customer's shipping address details. We advise to provide these details to improve fraud protection and
// conversion.
//
// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
// `country`.
type CreateCustomerPaymentShippingAddressResponse struct {
	// The title of the person, for example *Mr.* or *Mrs.*.
	Title *string `json:"title,omitempty"`
	// The given name (first name) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	GivenName *string `json:"givenName,omitempty"`
	// The given family name (surname) of the person should be at least two characters and cannot contain only
	// numbers.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	FamilyName *string `json:"familyName,omitempty"`
	// The name of the organization, in case the addressee is an organization.
	OrganizationName *string `json:"organizationName,omitempty"`
	// A street and street number.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	StreetAndNumber *string `json:"streetAndNumber,omitempty"`
	// Any additional addressing details, for example an apartment number.
	StreetAdditional *string `json:"streetAdditional,omitempty"`
	// A postal code. This field may be required if the provided country has a postal code system.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	PostalCode *string `json:"postalCode,omitempty"`
	// A valid e-mail address.
	//
	// If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
	// email upon payment creation. The language of the email will follow the locale parameter of the payment.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Email *string `json:"email,omitempty"`
	// If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
	Phone *string `json:"phone,omitempty"`
	// A city name.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	City *string `json:"city,omitempty"`
	// The top-level administrative subdivision of the country. For example: Noord-Holland.
	Region *string `json:"region,omitempty"`
	// A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
	//
	// Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
	Country *string `json:"country,omitempty"`
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetGivenName() *string {
	if o == nil {
		return nil
	}
	return o.GivenName
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetFamilyName() *string {
	if o == nil {
		return nil
	}
	return o.FamilyName
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetOrganizationName() *string {
	if o == nil {
		return nil
	}
	return o.OrganizationName
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetStreetAndNumber() *string {
	if o == nil {
		return nil
	}
	return o.StreetAndNumber
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetStreetAdditional() *string {
	if o == nil {
		return nil
	}
	return o.StreetAdditional
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetEmail() *string {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetPhone() *string {
	if o == nil {
		return nil
	}
	return o.Phone
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetCity() *string {
	if o == nil {
		return nil
	}
	return o.City
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetRegion() *string {
	if o == nil {
		return nil
	}
	return o.Region
}

func (o *CreateCustomerPaymentShippingAddressResponse) GetCountry() *string {
	if o == nil {
		return nil
	}
	return o.Country
}

// CreateCustomerPaymentLocaleResponse - Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
// is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
// language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
// locale, but our hosted payment pages currently only support the specified languages.
//
// For bank transfer payments specifically, the locale will determine the target bank account the customer has to
// transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
// customer use a local bank account greatly increases the conversion and speed of payment.
type CreateCustomerPaymentLocaleResponse string

const (
	CreateCustomerPaymentLocaleResponseEnUs CreateCustomerPaymentLocaleResponse = "en_US"
	CreateCustomerPaymentLocaleResponseEnGb CreateCustomerPaymentLocaleResponse = "en_GB"
	CreateCustomerPaymentLocaleResponseNlNl CreateCustomerPaymentLocaleResponse = "nl_NL"
	CreateCustomerPaymentLocaleResponseNlBe CreateCustomerPaymentLocaleResponse = "nl_BE"
	CreateCustomerPaymentLocaleResponseDeDe CreateCustomerPaymentLocaleResponse = "de_DE"
	CreateCustomerPaymentLocaleResponseDeAt CreateCustomerPaymentLocaleResponse = "de_AT"
	CreateCustomerPaymentLocaleResponseDeCh CreateCustomerPaymentLocaleResponse = "de_CH"
	CreateCustomerPaymentLocaleResponseFrFr CreateCustomerPaymentLocaleResponse = "fr_FR"
	CreateCustomerPaymentLocaleResponseFrBe CreateCustomerPaymentLocaleResponse = "fr_BE"
	CreateCustomerPaymentLocaleResponseEsEs CreateCustomerPaymentLocaleResponse = "es_ES"
	CreateCustomerPaymentLocaleResponseCaEs CreateCustomerPaymentLocaleResponse = "ca_ES"
	CreateCustomerPaymentLocaleResponsePtPt CreateCustomerPaymentLocaleResponse = "pt_PT"
	CreateCustomerPaymentLocaleResponseItIt CreateCustomerPaymentLocaleResponse = "it_IT"
	CreateCustomerPaymentLocaleResponseNbNo CreateCustomerPaymentLocaleResponse = "nb_NO"
	CreateCustomerPaymentLocaleResponseSvSe CreateCustomerPaymentLocaleResponse = "sv_SE"
	CreateCustomerPaymentLocaleResponseFiFi CreateCustomerPaymentLocaleResponse = "fi_FI"
	CreateCustomerPaymentLocaleResponseDaDk CreateCustomerPaymentLocaleResponse = "da_DK"
	CreateCustomerPaymentLocaleResponseIsIs CreateCustomerPaymentLocaleResponse = "is_IS"
	CreateCustomerPaymentLocaleResponseHuHu CreateCustomerPaymentLocaleResponse = "hu_HU"
	CreateCustomerPaymentLocaleResponsePlPl CreateCustomerPaymentLocaleResponse = "pl_PL"
	CreateCustomerPaymentLocaleResponseLvLv CreateCustomerPaymentLocaleResponse = "lv_LV"
	CreateCustomerPaymentLocaleResponseLtLt CreateCustomerPaymentLocaleResponse = "lt_LT"
)

func (e CreateCustomerPaymentLocaleResponse) ToPointer() *CreateCustomerPaymentLocaleResponse {
	return &e
}
func (e *CreateCustomerPaymentLocaleResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "en_US":
		fallthrough
	case "en_GB":
		fallthrough
	case "nl_NL":
		fallthrough
	case "nl_BE":
		fallthrough
	case "de_DE":
		fallthrough
	case "de_AT":
		fallthrough
	case "de_CH":
		fallthrough
	case "fr_FR":
		fallthrough
	case "fr_BE":
		fallthrough
	case "es_ES":
		fallthrough
	case "ca_ES":
		fallthrough
	case "pt_PT":
		fallthrough
	case "it_IT":
		fallthrough
	case "nb_NO":
		fallthrough
	case "sv_SE":
		fallthrough
	case "fi_FI":
		fallthrough
	case "da_DK":
		fallthrough
	case "is_IS":
		fallthrough
	case "hu_HU":
		fallthrough
	case "pl_PL":
		fallthrough
	case "lv_LV":
		fallthrough
	case "lt_LT":
		*e = CreateCustomerPaymentLocaleResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentLocaleResponse: %v", v)
	}
}

// CreateCustomerPaymentMethodResponse - The payment method used for this transaction. If a specific method was selected during payment initialization,
// this field reflects that choice.
type CreateCustomerPaymentMethodResponse string

const (
	CreateCustomerPaymentMethodResponseAlma           CreateCustomerPaymentMethodResponse = "alma"
	CreateCustomerPaymentMethodResponseApplepay       CreateCustomerPaymentMethodResponse = "applepay"
	CreateCustomerPaymentMethodResponseBacs           CreateCustomerPaymentMethodResponse = "bacs"
	CreateCustomerPaymentMethodResponseBancomatpay    CreateCustomerPaymentMethodResponse = "bancomatpay"
	CreateCustomerPaymentMethodResponseBancontact     CreateCustomerPaymentMethodResponse = "bancontact"
	CreateCustomerPaymentMethodResponseBanktransfer   CreateCustomerPaymentMethodResponse = "banktransfer"
	CreateCustomerPaymentMethodResponseBelfius        CreateCustomerPaymentMethodResponse = "belfius"
	CreateCustomerPaymentMethodResponseBillie         CreateCustomerPaymentMethodResponse = "billie"
	CreateCustomerPaymentMethodResponseBizum          CreateCustomerPaymentMethodResponse = "bizum"
	CreateCustomerPaymentMethodResponseBlik           CreateCustomerPaymentMethodResponse = "blik"
	CreateCustomerPaymentMethodResponseCreditcard     CreateCustomerPaymentMethodResponse = "creditcard"
	CreateCustomerPaymentMethodResponseDirectdebit    CreateCustomerPaymentMethodResponse = "directdebit"
	CreateCustomerPaymentMethodResponseEps            CreateCustomerPaymentMethodResponse = "eps"
	CreateCustomerPaymentMethodResponseGiftcard       CreateCustomerPaymentMethodResponse = "giftcard"
	CreateCustomerPaymentMethodResponseIdeal          CreateCustomerPaymentMethodResponse = "ideal"
	CreateCustomerPaymentMethodResponseIn3            CreateCustomerPaymentMethodResponse = "in3"
	CreateCustomerPaymentMethodResponseKbc            CreateCustomerPaymentMethodResponse = "kbc"
	CreateCustomerPaymentMethodResponseKlarna         CreateCustomerPaymentMethodResponse = "klarna"
	CreateCustomerPaymentMethodResponseKlarnapaylater CreateCustomerPaymentMethodResponse = "klarnapaylater"
	CreateCustomerPaymentMethodResponseKlarnapaynow   CreateCustomerPaymentMethodResponse = "klarnapaynow"
	CreateCustomerPaymentMethodResponseKlarnasliceit  CreateCustomerPaymentMethodResponse = "klarnasliceit"
	CreateCustomerPaymentMethodResponseMbway          CreateCustomerPaymentMethodResponse = "mbway"
	CreateCustomerPaymentMethodResponseMultibanco     CreateCustomerPaymentMethodResponse = "multibanco"
	CreateCustomerPaymentMethodResponseMybank         CreateCustomerPaymentMethodResponse = "mybank"
	CreateCustomerPaymentMethodResponsePaybybank      CreateCustomerPaymentMethodResponse = "paybybank"
	CreateCustomerPaymentMethodResponsePayconiq       CreateCustomerPaymentMethodResponse = "payconiq"
	CreateCustomerPaymentMethodResponsePaypal         CreateCustomerPaymentMethodResponse = "paypal"
	CreateCustomerPaymentMethodResponsePaysafecard    CreateCustomerPaymentMethodResponse = "paysafecard"
	CreateCustomerPaymentMethodResponsePointofsale    CreateCustomerPaymentMethodResponse = "pointofsale"
	CreateCustomerPaymentMethodResponsePrzelewy24     CreateCustomerPaymentMethodResponse = "przelewy24"
	CreateCustomerPaymentMethodResponseRiverty        CreateCustomerPaymentMethodResponse = "riverty"
	CreateCustomerPaymentMethodResponseSatispay       CreateCustomerPaymentMethodResponse = "satispay"
	CreateCustomerPaymentMethodResponseSwish          CreateCustomerPaymentMethodResponse = "swish"
	CreateCustomerPaymentMethodResponseTrustly        CreateCustomerPaymentMethodResponse = "trustly"
	CreateCustomerPaymentMethodResponseTwint          CreateCustomerPaymentMethodResponse = "twint"
	CreateCustomerPaymentMethodResponseVoucher        CreateCustomerPaymentMethodResponse = "voucher"
)

func (e CreateCustomerPaymentMethodResponse) ToPointer() *CreateCustomerPaymentMethodResponse {
	return &e
}
func (e *CreateCustomerPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "alma":
		fallthrough
	case "applepay":
		fallthrough
	case "bacs":
		fallthrough
	case "bancomatpay":
		fallthrough
	case "bancontact":
		fallthrough
	case "banktransfer":
		fallthrough
	case "belfius":
		fallthrough
	case "billie":
		fallthrough
	case "bizum":
		fallthrough
	case "blik":
		fallthrough
	case "creditcard":
		fallthrough
	case "directdebit":
		fallthrough
	case "eps":
		fallthrough
	case "giftcard":
		fallthrough
	case "ideal":
		fallthrough
	case "in3":
		fallthrough
	case "kbc":
		fallthrough
	case "klarna":
		fallthrough
	case "klarnapaylater":
		fallthrough
	case "klarnapaynow":
		fallthrough
	case "klarnasliceit":
		fallthrough
	case "mbway":
		fallthrough
	case "multibanco":
		fallthrough
	case "mybank":
		fallthrough
	case "paybybank":
		fallthrough
	case "payconiq":
		fallthrough
	case "paypal":
		fallthrough
	case "paysafecard":
		fallthrough
	case "pointofsale":
		fallthrough
	case "przelewy24":
		fallthrough
	case "riverty":
		fallthrough
	case "satispay":
		fallthrough
	case "swish":
		fallthrough
	case "trustly":
		fallthrough
	case "twint":
		fallthrough
	case "voucher":
		*e = CreateCustomerPaymentMethodResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentMethodResponse: %v", v)
	}
}

type CreateCustomerPaymentMetadataResponseType string

const (
	CreateCustomerPaymentMetadataResponseTypeStr        CreateCustomerPaymentMetadataResponseType = "str"
	CreateCustomerPaymentMetadataResponseTypeMapOfAny   CreateCustomerPaymentMetadataResponseType = "mapOfAny"
	CreateCustomerPaymentMetadataResponseTypeArrayOfStr CreateCustomerPaymentMetadataResponseType = "arrayOfStr"
)

// CreateCustomerPaymentMetadataResponse - Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
// you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
type CreateCustomerPaymentMetadataResponse struct {
	Str        *string        `queryParam:"inline" name:"metadata"`
	MapOfAny   map[string]any `queryParam:"inline" name:"metadata"`
	ArrayOfStr []string       `queryParam:"inline" name:"metadata"`

	Type CreateCustomerPaymentMetadataResponseType
}

func CreateCreateCustomerPaymentMetadataResponseStr(str string) CreateCustomerPaymentMetadataResponse {
	typ := CreateCustomerPaymentMetadataResponseTypeStr

	return CreateCustomerPaymentMetadataResponse{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateCustomerPaymentMetadataResponseMapOfAny(mapOfAny map[string]any) CreateCustomerPaymentMetadataResponse {
	typ := CreateCustomerPaymentMetadataResponseTypeMapOfAny

	return CreateCustomerPaymentMetadataResponse{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func CreateCreateCustomerPaymentMetadataResponseArrayOfStr(arrayOfStr []string) CreateCustomerPaymentMetadataResponse {
	typ := CreateCustomerPaymentMetadataResponseTypeArrayOfStr

	return CreateCustomerPaymentMetadataResponse{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *CreateCustomerPaymentMetadataResponse) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateCustomerPaymentMetadataResponseTypeStr
		return nil
	}

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		u.MapOfAny = mapOfAny
		u.Type = CreateCustomerPaymentMetadataResponseTypeMapOfAny
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = CreateCustomerPaymentMetadataResponseTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateCustomerPaymentMetadataResponse", string(data))
}

func (u CreateCustomerPaymentMetadataResponse) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type CreateCustomerPaymentMetadataResponse: all fields are null")
}

// CreateCustomerPaymentCaptureModeResponse - Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
// and capture at a later time.
//
// This field needs to be set to `manual` for method `riverty`.
type CreateCustomerPaymentCaptureModeResponse string

const (
	CreateCustomerPaymentCaptureModeResponseAutomatic CreateCustomerPaymentCaptureModeResponse = "automatic"
	CreateCustomerPaymentCaptureModeResponseManual    CreateCustomerPaymentCaptureModeResponse = "manual"
)

func (e CreateCustomerPaymentCaptureModeResponse) ToPointer() *CreateCustomerPaymentCaptureModeResponse {
	return &e
}
func (e *CreateCustomerPaymentCaptureModeResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "automatic":
		fallthrough
	case "manual":
		*e = CreateCustomerPaymentCaptureModeResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCaptureModeResponse: %v", v)
	}
}

// CreateCustomerPaymentApplicationFeeAmountResponse - The fee that you wish to charge.
//
// Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
// a €0.99 fee on a €1.00 payment.
type CreateCustomerPaymentApplicationFeeAmountResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentApplicationFeeAmountResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentApplicationFeeAmountResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentApplicationFeeResponse - With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
// merchants.
//
// If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
// `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
// to your own account balance.
//
// If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
// `routing` parameter.
type CreateCustomerPaymentApplicationFeeResponse struct {
	// The fee that you wish to charge.
	//
	// Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
	// a €0.99 fee on a €1.00 payment.
	Amount *CreateCustomerPaymentApplicationFeeAmountResponse `json:"amount,omitempty"`
	// The description of the application fee. This will appear on settlement reports towards both you and the
	// connected merchant.
	Description *string `json:"description,omitempty"`
}

func (o *CreateCustomerPaymentApplicationFeeResponse) GetAmount() *CreateCustomerPaymentApplicationFeeAmountResponse {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CreateCustomerPaymentApplicationFeeResponse) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

// CreateCustomerPaymentRoutingMode - Whether this entity was created in live mode or in test mode.
type CreateCustomerPaymentRoutingMode string

const (
	CreateCustomerPaymentRoutingModeLive CreateCustomerPaymentRoutingMode = "live"
	CreateCustomerPaymentRoutingModeTest CreateCustomerPaymentRoutingMode = "test"
)

func (e CreateCustomerPaymentRoutingMode) ToPointer() *CreateCustomerPaymentRoutingMode {
	return &e
}
func (e *CreateCustomerPaymentRoutingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "live":
		fallthrough
	case "test":
		*e = CreateCustomerPaymentRoutingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentRoutingMode: %v", v)
	}
}

// CreateCustomerPaymentRoutingAmountResponse - The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
type CreateCustomerPaymentRoutingAmountResponse struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentRoutingAmountResponse) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentRoutingAmountResponse) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentRoutingTypeResponse - The type of destination. Currently only the destination type `organization` is supported.
type CreateCustomerPaymentRoutingTypeResponse string

const (
	CreateCustomerPaymentRoutingTypeResponseOrganization CreateCustomerPaymentRoutingTypeResponse = "organization"
)

func (e CreateCustomerPaymentRoutingTypeResponse) ToPointer() *CreateCustomerPaymentRoutingTypeResponse {
	return &e
}
func (e *CreateCustomerPaymentRoutingTypeResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "organization":
		*e = CreateCustomerPaymentRoutingTypeResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentRoutingTypeResponse: %v", v)
	}
}

// CreateCustomerPaymentDestinationResponse - The destination of this portion of the payment.
type CreateCustomerPaymentDestinationResponse struct {
	// The type of destination. Currently only the destination type `organization` is supported.
	Type CreateCustomerPaymentRoutingTypeResponse `json:"type"`
	// Required for destination type `organization`. The ID of the connected organization the funds should be
	// routed to.
	OrganizationID string `json:"organizationId"`
}

func (o *CreateCustomerPaymentDestinationResponse) GetType() CreateCustomerPaymentRoutingTypeResponse {
	if o == nil {
		return CreateCustomerPaymentRoutingTypeResponse("")
	}
	return o.Type
}

func (o *CreateCustomerPaymentDestinationResponse) GetOrganizationID() string {
	if o == nil {
		return ""
	}
	return o.OrganizationID
}

// CreateCustomerPaymentRoutingSelfResponse - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type CreateCustomerPaymentRoutingSelfResponse struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentRoutingSelfResponse) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentRoutingSelfResponse) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentPaymentResponse - The API resource URL of the [payment](get-payment) that belong to this route.
type CreateCustomerPaymentPaymentResponse struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentPaymentResponse) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentPaymentResponse) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentRoutingLinksResponse - An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
type CreateCustomerPaymentRoutingLinksResponse struct {
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Self CreateCustomerPaymentRoutingSelfResponse `json:"self"`
	// The API resource URL of the [payment](get-payment) that belong to this route.
	Payment CreateCustomerPaymentPaymentResponse `json:"payment"`
}

func (o *CreateCustomerPaymentRoutingLinksResponse) GetSelf() CreateCustomerPaymentRoutingSelfResponse {
	if o == nil {
		return CreateCustomerPaymentRoutingSelfResponse{}
	}
	return o.Self
}

func (o *CreateCustomerPaymentRoutingLinksResponse) GetPayment() CreateCustomerPaymentPaymentResponse {
	if o == nil {
		return CreateCustomerPaymentPaymentResponse{}
	}
	return o.Payment
}

type CreateCustomerPaymentRoutingResponse struct {
	// Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
	Resource string `json:"resource"`
	// The identifier uniquely referring to this route. Mollie will always refer to the route by this ID.
	// Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
	ID string `json:"id"`
	// Whether this entity was created in live mode or in test mode.
	Mode CreateCustomerPaymentRoutingMode `json:"mode"`
	// The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
	Amount CreateCustomerPaymentRoutingAmountResponse `json:"amount"`
	// The destination of this portion of the payment.
	Destination CreateCustomerPaymentDestinationResponse `json:"destination"`
	// The date and time when the route was created. The date is given in ISO 8601 format.
	CreatedAt string `json:"createdAt"`
	// Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
	// date must be given in `YYYY-MM-DD` format.
	//
	// If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
	ReleaseDate *string `json:"releaseDate,omitempty"`
	// An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
	Links CreateCustomerPaymentRoutingLinksResponse `json:"_links"`
}

func (o *CreateCustomerPaymentRoutingResponse) GetResource() string {
	if o == nil {
		return ""
	}
	return o.Resource
}

func (o *CreateCustomerPaymentRoutingResponse) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateCustomerPaymentRoutingResponse) GetMode() CreateCustomerPaymentRoutingMode {
	if o == nil {
		return CreateCustomerPaymentRoutingMode("")
	}
	return o.Mode
}

func (o *CreateCustomerPaymentRoutingResponse) GetAmount() CreateCustomerPaymentRoutingAmountResponse {
	if o == nil {
		return CreateCustomerPaymentRoutingAmountResponse{}
	}
	return o.Amount
}

func (o *CreateCustomerPaymentRoutingResponse) GetDestination() CreateCustomerPaymentDestinationResponse {
	if o == nil {
		return CreateCustomerPaymentDestinationResponse{}
	}
	return o.Destination
}

func (o *CreateCustomerPaymentRoutingResponse) GetCreatedAt() string {
	if o == nil {
		return ""
	}
	return o.CreatedAt
}

func (o *CreateCustomerPaymentRoutingResponse) GetReleaseDate() *string {
	if o == nil {
		return nil
	}
	return o.ReleaseDate
}

func (o *CreateCustomerPaymentRoutingResponse) GetLinks() CreateCustomerPaymentRoutingLinksResponse {
	if o == nil {
		return CreateCustomerPaymentRoutingLinksResponse{}
	}
	return o.Links
}

// CreateCustomerPaymentSequenceTypeResponse - **Only relevant for recurring payments.**
//
// Indicate which part of a recurring sequence this payment is for.
//
// Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
// through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
// on their account in the future.
//
// If set to `recurring`, the customer's card is charged automatically.
//
// Defaults to `oneoff`, which is a regular non-recurring payment.
//
// For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
// [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
// are set up correctly for recurring payments.
type CreateCustomerPaymentSequenceTypeResponse string

const (
	CreateCustomerPaymentSequenceTypeResponseOneoff    CreateCustomerPaymentSequenceTypeResponse = "oneoff"
	CreateCustomerPaymentSequenceTypeResponseFirst     CreateCustomerPaymentSequenceTypeResponse = "first"
	CreateCustomerPaymentSequenceTypeResponseRecurring CreateCustomerPaymentSequenceTypeResponse = "recurring"
)

func (e CreateCustomerPaymentSequenceTypeResponse) ToPointer() *CreateCustomerPaymentSequenceTypeResponse {
	return &e
}
func (e *CreateCustomerPaymentSequenceTypeResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oneoff":
		fallthrough
	case "first":
		fallthrough
	case "recurring":
		*e = CreateCustomerPaymentSequenceTypeResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentSequenceTypeResponse: %v", v)
	}
}

// CreateCustomerPaymentStatusEnum - The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
// statuses occur at what point.
type CreateCustomerPaymentStatusEnum string

const (
	CreateCustomerPaymentStatusEnumOpen       CreateCustomerPaymentStatusEnum = "open"
	CreateCustomerPaymentStatusEnumPending    CreateCustomerPaymentStatusEnum = "pending"
	CreateCustomerPaymentStatusEnumAuthorized CreateCustomerPaymentStatusEnum = "authorized"
	CreateCustomerPaymentStatusEnumPaid       CreateCustomerPaymentStatusEnum = "paid"
	CreateCustomerPaymentStatusEnumCanceled   CreateCustomerPaymentStatusEnum = "canceled"
	CreateCustomerPaymentStatusEnumExpired    CreateCustomerPaymentStatusEnum = "expired"
	CreateCustomerPaymentStatusEnumFailed     CreateCustomerPaymentStatusEnum = "failed"
)

func (e CreateCustomerPaymentStatusEnum) ToPointer() *CreateCustomerPaymentStatusEnum {
	return &e
}
func (e *CreateCustomerPaymentStatusEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "open":
		fallthrough
	case "pending":
		fallthrough
	case "authorized":
		fallthrough
	case "paid":
		fallthrough
	case "canceled":
		fallthrough
	case "expired":
		fallthrough
	case "failed":
		*e = CreateCustomerPaymentStatusEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentStatusEnum: %v", v)
	}
}

// CreateCustomerPaymentCode - A machine-readable code that indicates the reason for the payment's status.
type CreateCustomerPaymentCode string

const (
	CreateCustomerPaymentCodeApprovedOrCompletedSuccessfully             CreateCustomerPaymentCode = "approved_or_completed_successfully"
	CreateCustomerPaymentCodeReferToCardIssuer                           CreateCustomerPaymentCode = "refer_to_card_issuer"
	CreateCustomerPaymentCodeInvalidMerchant                             CreateCustomerPaymentCode = "invalid_merchant"
	CreateCustomerPaymentCodeCaptureCard                                 CreateCustomerPaymentCode = "capture_card"
	CreateCustomerPaymentCodeDoNotHonor                                  CreateCustomerPaymentCode = "do_not_honor"
	CreateCustomerPaymentCodeError                                       CreateCustomerPaymentCode = "error"
	CreateCustomerPaymentCodePartialApproval                             CreateCustomerPaymentCode = "partial_approval"
	CreateCustomerPaymentCodeInvalidTransaction                          CreateCustomerPaymentCode = "invalid_transaction"
	CreateCustomerPaymentCodeInvalidAmount                               CreateCustomerPaymentCode = "invalid_amount"
	CreateCustomerPaymentCodeInvalidIssuer                               CreateCustomerPaymentCode = "invalid_issuer"
	CreateCustomerPaymentCodeLostCard                                    CreateCustomerPaymentCode = "lost_card"
	CreateCustomerPaymentCodeStolenCard                                  CreateCustomerPaymentCode = "stolen_card"
	CreateCustomerPaymentCodeInsufficientFunds                           CreateCustomerPaymentCode = "insufficient_funds"
	CreateCustomerPaymentCodeExpiredCard                                 CreateCustomerPaymentCode = "expired_card"
	CreateCustomerPaymentCodeInvalidPin                                  CreateCustomerPaymentCode = "invalid_pin"
	CreateCustomerPaymentCodeTransactionNotPermittedToCardholder         CreateCustomerPaymentCode = "transaction_not_permitted_to_cardholder"
	CreateCustomerPaymentCodeTransactionNotAllowedAtTerminal             CreateCustomerPaymentCode = "transaction_not_allowed_at_terminal"
	CreateCustomerPaymentCodeExceedsWithdrawalAmountLimit                CreateCustomerPaymentCode = "exceeds_withdrawal_amount_limit"
	CreateCustomerPaymentCodeRestrictedCard                              CreateCustomerPaymentCode = "restricted_card"
	CreateCustomerPaymentCodeSecurityViolation                           CreateCustomerPaymentCode = "security_violation"
	CreateCustomerPaymentCodeExceedsWithdrawalCountLimit                 CreateCustomerPaymentCode = "exceeds_withdrawal_count_limit"
	CreateCustomerPaymentCodeAllowableNumberOfPinTriesExceeded           CreateCustomerPaymentCode = "allowable_number_of_pin_tries_exceeded"
	CreateCustomerPaymentCodeNoReasonToDecline                           CreateCustomerPaymentCode = "no_reason_to_decline"
	CreateCustomerPaymentCodeCannotVerifyPin                             CreateCustomerPaymentCode = "cannot_verify_pin"
	CreateCustomerPaymentCodeIssuerUnavailable                           CreateCustomerPaymentCode = "issuer_unavailable"
	CreateCustomerPaymentCodeUnableToRouteTransaction                    CreateCustomerPaymentCode = "unable_to_route_transaction"
	CreateCustomerPaymentCodeDuplicateTransaction                        CreateCustomerPaymentCode = "duplicate_transaction"
	CreateCustomerPaymentCodeSystemMalfunction                           CreateCustomerPaymentCode = "system_malfunction"
	CreateCustomerPaymentCodeHonorWithID                                 CreateCustomerPaymentCode = "honor_with_id"
	CreateCustomerPaymentCodeInvalidCardNumber                           CreateCustomerPaymentCode = "invalid_card_number"
	CreateCustomerPaymentCodeFormatError                                 CreateCustomerPaymentCode = "format_error"
	CreateCustomerPaymentCodeContactCardIssuer                           CreateCustomerPaymentCode = "contact_card_issuer"
	CreateCustomerPaymentCodePinNotChanged                               CreateCustomerPaymentCode = "pin_not_changed"
	CreateCustomerPaymentCodeInvalidNonexistentToAccountSpecified        CreateCustomerPaymentCode = "invalid_nonexistent_to_account_specified"
	CreateCustomerPaymentCodeInvalidNonexistentFromAccountSpecified      CreateCustomerPaymentCode = "invalid_nonexistent_from_account_specified"
	CreateCustomerPaymentCodeInvalidNonexistentAccountSpecified          CreateCustomerPaymentCode = "invalid_nonexistent_account_specified"
	CreateCustomerPaymentCodeLifecycleRelated                            CreateCustomerPaymentCode = "lifecycle_related"
	CreateCustomerPaymentCodeDomesticDebitTransactionNotAllowed          CreateCustomerPaymentCode = "domestic_debit_transaction_not_allowed"
	CreateCustomerPaymentCodePolicyRelated                               CreateCustomerPaymentCode = "policy_related"
	CreateCustomerPaymentCodeFraudSecurityRelated                        CreateCustomerPaymentCode = "fraud_security_related"
	CreateCustomerPaymentCodeInvalidAuthorizationLifeCycle               CreateCustomerPaymentCode = "invalid_authorization_life_cycle"
	CreateCustomerPaymentCodePurchaseAmountOnlyNoCashBackAllowed         CreateCustomerPaymentCode = "purchase_amount_only_no_cash_back_allowed"
	CreateCustomerPaymentCodeCryptographicFailure                        CreateCustomerPaymentCode = "cryptographic_failure"
	CreateCustomerPaymentCodeUnacceptablePin                             CreateCustomerPaymentCode = "unacceptable_pin"
	CreateCustomerPaymentCodeReferToCardIssuerSpecialCondition           CreateCustomerPaymentCode = "refer_to_card_issuer_special_condition"
	CreateCustomerPaymentCodePickUpCardSpecialCondition                  CreateCustomerPaymentCode = "pick_up_card_special_condition"
	CreateCustomerPaymentCodeVipApproval                                 CreateCustomerPaymentCode = "vip_approval"
	CreateCustomerPaymentCodeInvalidAccountNumber                        CreateCustomerPaymentCode = "invalid_account_number"
	CreateCustomerPaymentCodeReEnterTransaction                          CreateCustomerPaymentCode = "re_enter_transaction"
	CreateCustomerPaymentCodeNoActionTaken                               CreateCustomerPaymentCode = "no_action_taken"
	CreateCustomerPaymentCodeUnableToLocateRecord                        CreateCustomerPaymentCode = "unable_to_locate_record"
	CreateCustomerPaymentCodeFileTemporarilyUnavailable                  CreateCustomerPaymentCode = "file_temporarily_unavailable"
	CreateCustomerPaymentCodeNoCreditAccount                             CreateCustomerPaymentCode = "no_credit_account"
	CreateCustomerPaymentCodeClosedAccount                               CreateCustomerPaymentCode = "closed_account"
	CreateCustomerPaymentCodeNoCheckingAccount                           CreateCustomerPaymentCode = "no_checking_account"
	CreateCustomerPaymentCodeNoSavingsAccount                            CreateCustomerPaymentCode = "no_savings_account"
	CreateCustomerPaymentCodeSuspectedFraud                              CreateCustomerPaymentCode = "suspected_fraud"
	CreateCustomerPaymentCodeTransactionDoesNotFulfillAmlRequirement     CreateCustomerPaymentCode = "transaction_does_not_fulfill_aml_requirement"
	CreateCustomerPaymentCodePinDataRequired                             CreateCustomerPaymentCode = "pin_data_required"
	CreateCustomerPaymentCodeUnableToLocatePreviousMessage               CreateCustomerPaymentCode = "unable_to_locate_previous_message"
	CreateCustomerPaymentCodePreviousMessageLocatedInconsistentData      CreateCustomerPaymentCode = "previous_message_located_inconsistent_data"
	CreateCustomerPaymentCodeBlockedFirstUsed                            CreateCustomerPaymentCode = "blocked_first_used"
	CreateCustomerPaymentCodeTransactionReversed                         CreateCustomerPaymentCode = "transaction_reversed"
	CreateCustomerPaymentCodeCreditIssuerUnavailable                     CreateCustomerPaymentCode = "credit_issuer_unavailable"
	CreateCustomerPaymentCodePinCryptographicErrorFound                  CreateCustomerPaymentCode = "pin_cryptographic_error_found"
	CreateCustomerPaymentCodeNegativeOnlineCamResult                     CreateCustomerPaymentCode = "negative_online_cam_result"
	CreateCustomerPaymentCodeViolationOfLaw                              CreateCustomerPaymentCode = "violation_of_law"
	CreateCustomerPaymentCodeForceStip                                   CreateCustomerPaymentCode = "force_stip"
	CreateCustomerPaymentCodeCashServiceNotAvailable                     CreateCustomerPaymentCode = "cash_service_not_available"
	CreateCustomerPaymentCodeCashbackRequestExceedsIssuerLimit           CreateCustomerPaymentCode = "cashback_request_exceeds_issuer_limit"
	CreateCustomerPaymentCodeDeclineForCvv2Failure                       CreateCustomerPaymentCode = "decline_for_cvv2_failure"
	CreateCustomerPaymentCodeTransactionAmountExceedsPreAuthorizedAmount CreateCustomerPaymentCode = "transaction_amount_exceeds_pre_authorized_amount"
	CreateCustomerPaymentCodeInvalidBillerInformation                    CreateCustomerPaymentCode = "invalid_biller_information"
	CreateCustomerPaymentCodePinChangeUnblockRequestDeclined             CreateCustomerPaymentCode = "pin_change_unblock_request_declined"
	CreateCustomerPaymentCodeUnsafePin                                   CreateCustomerPaymentCode = "unsafe_pin"
	CreateCustomerPaymentCodeCardAuthenticationFailed                    CreateCustomerPaymentCode = "card_authentication_failed"
	CreateCustomerPaymentCodeStopPaymentOrder                            CreateCustomerPaymentCode = "stop_payment_order"
	CreateCustomerPaymentCodeRevocationOfAuthorization                   CreateCustomerPaymentCode = "revocation_of_authorization"
	CreateCustomerPaymentCodeRevocationOfAllAuthorizations               CreateCustomerPaymentCode = "revocation_of_all_authorizations"
	CreateCustomerPaymentCodeForwardToIssuerXa                           CreateCustomerPaymentCode = "forward_to_issuer_xa"
	CreateCustomerPaymentCodeForwardToIssuerXd                           CreateCustomerPaymentCode = "forward_to_issuer_xd"
	CreateCustomerPaymentCodeUnableToGoOnline                            CreateCustomerPaymentCode = "unable_to_go_online"
	CreateCustomerPaymentCodeAdditionalCustomerAuthenticationRequired    CreateCustomerPaymentCode = "additional_customer_authentication_required"
	CreateCustomerPaymentCodeMerchantIDNotFound                          CreateCustomerPaymentCode = "merchant_id_not_found"
	CreateCustomerPaymentCodeMerchantAccountClosed                       CreateCustomerPaymentCode = "merchant_account_closed"
	CreateCustomerPaymentCodeTerminalIDNotFound                          CreateCustomerPaymentCode = "terminal_id_not_found"
	CreateCustomerPaymentCodeTerminalClosed                              CreateCustomerPaymentCode = "terminal_closed"
	CreateCustomerPaymentCodeInvalidCategoryCode                         CreateCustomerPaymentCode = "invalid_category_code"
	CreateCustomerPaymentCodeInvalidCurrency                             CreateCustomerPaymentCode = "invalid_currency"
	CreateCustomerPaymentCodeMissingCvv2Cvc2                             CreateCustomerPaymentCode = "missing_cvv2_cvc2"
	CreateCustomerPaymentCodeCvv2NotAllowed                              CreateCustomerPaymentCode = "cvv2_not_allowed"
	CreateCustomerPaymentCodeMerchantNotRegisteredVbv                    CreateCustomerPaymentCode = "merchant_not_registered_vbv"
	CreateCustomerPaymentCodeMerchantNotRegisteredForAmex                CreateCustomerPaymentCode = "merchant_not_registered_for_amex"
	CreateCustomerPaymentCodeTransactionNotPermittedAtTerminal           CreateCustomerPaymentCode = "transaction_not_permitted_at_terminal"
	CreateCustomerPaymentCodeAgreementTerminalNotRelated                 CreateCustomerPaymentCode = "agreement_terminal_not_related"
	CreateCustomerPaymentCodeInvalidProcessorID                          CreateCustomerPaymentCode = "invalid_processor_id"
	CreateCustomerPaymentCodeInvalidMerchantData                         CreateCustomerPaymentCode = "invalid_merchant_data"
	CreateCustomerPaymentCodeSubMerchantAccountClosed                    CreateCustomerPaymentCode = "sub_merchant_account_closed"
	CreateCustomerPaymentCodeTerminalBusy                                CreateCustomerPaymentCode = "terminal_busy"
	CreateCustomerPaymentCodeTerminalUnreachable                         CreateCustomerPaymentCode = "terminal_unreachable"
	CreateCustomerPaymentCodeServiceFailed                               CreateCustomerPaymentCode = "service_failed"
	CreateCustomerPaymentCodeInvalidOperation                            CreateCustomerPaymentCode = "invalid_operation"
	CreateCustomerPaymentCodeAuthorizationError                          CreateCustomerPaymentCode = "authorization_error"
	CreateCustomerPaymentCodeLoginFailedWithoutReason                    CreateCustomerPaymentCode = "login_failed_without_reason"
	CreateCustomerPaymentCodeInvalidRetailer                             CreateCustomerPaymentCode = "invalid_retailer"
	CreateCustomerPaymentCodeCardDoesNotExist                            CreateCustomerPaymentCode = "card_does_not_exist"
	CreateCustomerPaymentCodeCardIsBlocked                               CreateCustomerPaymentCode = "card_is_blocked"
	CreateCustomerPaymentCodeInvalidCardID                               CreateCustomerPaymentCode = "invalid_card_id"
	CreateCustomerPaymentCodeCardIsTransferred                           CreateCustomerPaymentCode = "card_is_transferred"
	CreateCustomerPaymentCodeCardIsNotActive                             CreateCustomerPaymentCode = "card_is_not_active"
	CreateCustomerPaymentCodeIncorrectPurchaseValue                      CreateCustomerPaymentCode = "incorrect_purchase_value"
	CreateCustomerPaymentCodeCardNotAvailable                            CreateCustomerPaymentCode = "card_not_available"
	CreateCustomerPaymentCodeWrongCurrency                               CreateCustomerPaymentCode = "wrong_currency"
	CreateCustomerPaymentCodeLoginFailedUnknownUser                      CreateCustomerPaymentCode = "login_failed_unknown_user"
	CreateCustomerPaymentCodeLoginFailedInvalidPassword                  CreateCustomerPaymentCode = "login_failed_invalid_password"
	CreateCustomerPaymentCodeInvalidEanCode                              CreateCustomerPaymentCode = "invalid_ean_code"
)

func (e CreateCustomerPaymentCode) ToPointer() *CreateCustomerPaymentCode {
	return &e
}
func (e *CreateCustomerPaymentCode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "approved_or_completed_successfully":
		fallthrough
	case "refer_to_card_issuer":
		fallthrough
	case "invalid_merchant":
		fallthrough
	case "capture_card":
		fallthrough
	case "do_not_honor":
		fallthrough
	case "error":
		fallthrough
	case "partial_approval":
		fallthrough
	case "invalid_transaction":
		fallthrough
	case "invalid_amount":
		fallthrough
	case "invalid_issuer":
		fallthrough
	case "lost_card":
		fallthrough
	case "stolen_card":
		fallthrough
	case "insufficient_funds":
		fallthrough
	case "expired_card":
		fallthrough
	case "invalid_pin":
		fallthrough
	case "transaction_not_permitted_to_cardholder":
		fallthrough
	case "transaction_not_allowed_at_terminal":
		fallthrough
	case "exceeds_withdrawal_amount_limit":
		fallthrough
	case "restricted_card":
		fallthrough
	case "security_violation":
		fallthrough
	case "exceeds_withdrawal_count_limit":
		fallthrough
	case "allowable_number_of_pin_tries_exceeded":
		fallthrough
	case "no_reason_to_decline":
		fallthrough
	case "cannot_verify_pin":
		fallthrough
	case "issuer_unavailable":
		fallthrough
	case "unable_to_route_transaction":
		fallthrough
	case "duplicate_transaction":
		fallthrough
	case "system_malfunction":
		fallthrough
	case "honor_with_id":
		fallthrough
	case "invalid_card_number":
		fallthrough
	case "format_error":
		fallthrough
	case "contact_card_issuer":
		fallthrough
	case "pin_not_changed":
		fallthrough
	case "invalid_nonexistent_to_account_specified":
		fallthrough
	case "invalid_nonexistent_from_account_specified":
		fallthrough
	case "invalid_nonexistent_account_specified":
		fallthrough
	case "lifecycle_related":
		fallthrough
	case "domestic_debit_transaction_not_allowed":
		fallthrough
	case "policy_related":
		fallthrough
	case "fraud_security_related":
		fallthrough
	case "invalid_authorization_life_cycle":
		fallthrough
	case "purchase_amount_only_no_cash_back_allowed":
		fallthrough
	case "cryptographic_failure":
		fallthrough
	case "unacceptable_pin":
		fallthrough
	case "refer_to_card_issuer_special_condition":
		fallthrough
	case "pick_up_card_special_condition":
		fallthrough
	case "vip_approval":
		fallthrough
	case "invalid_account_number":
		fallthrough
	case "re_enter_transaction":
		fallthrough
	case "no_action_taken":
		fallthrough
	case "unable_to_locate_record":
		fallthrough
	case "file_temporarily_unavailable":
		fallthrough
	case "no_credit_account":
		fallthrough
	case "closed_account":
		fallthrough
	case "no_checking_account":
		fallthrough
	case "no_savings_account":
		fallthrough
	case "suspected_fraud":
		fallthrough
	case "transaction_does_not_fulfill_aml_requirement":
		fallthrough
	case "pin_data_required":
		fallthrough
	case "unable_to_locate_previous_message":
		fallthrough
	case "previous_message_located_inconsistent_data":
		fallthrough
	case "blocked_first_used":
		fallthrough
	case "transaction_reversed":
		fallthrough
	case "credit_issuer_unavailable":
		fallthrough
	case "pin_cryptographic_error_found":
		fallthrough
	case "negative_online_cam_result":
		fallthrough
	case "violation_of_law":
		fallthrough
	case "force_stip":
		fallthrough
	case "cash_service_not_available":
		fallthrough
	case "cashback_request_exceeds_issuer_limit":
		fallthrough
	case "decline_for_cvv2_failure":
		fallthrough
	case "transaction_amount_exceeds_pre_authorized_amount":
		fallthrough
	case "invalid_biller_information":
		fallthrough
	case "pin_change_unblock_request_declined":
		fallthrough
	case "unsafe_pin":
		fallthrough
	case "card_authentication_failed":
		fallthrough
	case "stop_payment_order":
		fallthrough
	case "revocation_of_authorization":
		fallthrough
	case "revocation_of_all_authorizations":
		fallthrough
	case "forward_to_issuer_xa":
		fallthrough
	case "forward_to_issuer_xd":
		fallthrough
	case "unable_to_go_online":
		fallthrough
	case "additional_customer_authentication_required":
		fallthrough
	case "merchant_id_not_found":
		fallthrough
	case "merchant_account_closed":
		fallthrough
	case "terminal_id_not_found":
		fallthrough
	case "terminal_closed":
		fallthrough
	case "invalid_category_code":
		fallthrough
	case "invalid_currency":
		fallthrough
	case "missing_cvv2_cvc2":
		fallthrough
	case "cvv2_not_allowed":
		fallthrough
	case "merchant_not_registered_vbv":
		fallthrough
	case "merchant_not_registered_for_amex":
		fallthrough
	case "transaction_not_permitted_at_terminal":
		fallthrough
	case "agreement_terminal_not_related":
		fallthrough
	case "invalid_processor_id":
		fallthrough
	case "invalid_merchant_data":
		fallthrough
	case "sub_merchant_account_closed":
		fallthrough
	case "terminal_busy":
		fallthrough
	case "terminal_unreachable":
		fallthrough
	case "service_failed":
		fallthrough
	case "invalid_operation":
		fallthrough
	case "authorization_error":
		fallthrough
	case "login_failed_without_reason":
		fallthrough
	case "invalid_retailer":
		fallthrough
	case "card_does_not_exist":
		fallthrough
	case "card_is_blocked":
		fallthrough
	case "invalid_card_id":
		fallthrough
	case "card_is_transferred":
		fallthrough
	case "card_is_not_active":
		fallthrough
	case "incorrect_purchase_value":
		fallthrough
	case "card_not_available":
		fallthrough
	case "wrong_currency":
		fallthrough
	case "login_failed_unknown_user":
		fallthrough
	case "login_failed_invalid_password":
		fallthrough
	case "invalid_ean_code":
		*e = CreateCustomerPaymentCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCode: %v", v)
	}
}

// CreateCustomerPaymentStatusReason - This object offers details about the status of a payment. Currently it is only available for point-of-sale
// payments.
//
// You can find more information about the possible values of this object on
// [this page](status-reasons).**
type CreateCustomerPaymentStatusReason struct {
	Code CreateCustomerPaymentCode `json:"code"`
	// A description of the status reason, localized according to the payment `locale`.
	Message string `json:"message"`
}

func (o *CreateCustomerPaymentStatusReason) GetCode() CreateCustomerPaymentCode {
	if o == nil {
		return CreateCustomerPaymentCode("")
	}
	return o.Code
}

func (o *CreateCustomerPaymentStatusReason) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

// CreateCustomerPaymentCardAudition - The card's target audience, if known.
type CreateCustomerPaymentCardAudition string

const (
	CreateCustomerPaymentCardAuditionConsumer CreateCustomerPaymentCardAudition = "consumer"
	CreateCustomerPaymentCardAuditionBusiness CreateCustomerPaymentCardAudition = "business"
)

func (e CreateCustomerPaymentCardAudition) ToPointer() *CreateCustomerPaymentCardAudition {
	return &e
}
func (e *CreateCustomerPaymentCardAudition) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "consumer":
		fallthrough
	case "business":
		*e = CreateCustomerPaymentCardAudition(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCardAudition: %v", v)
	}
}

// CreateCustomerPaymentCardLabel - The card's label, if known.
type CreateCustomerPaymentCardLabel string

const (
	CreateCustomerPaymentCardLabelAmericanExpress CreateCustomerPaymentCardLabel = "American Express"
	CreateCustomerPaymentCardLabelCartaSi         CreateCustomerPaymentCardLabel = "Carta Si"
	CreateCustomerPaymentCardLabelCarteBleue      CreateCustomerPaymentCardLabel = "Carte Bleue"
	CreateCustomerPaymentCardLabelDankort         CreateCustomerPaymentCardLabel = "Dankort"
	CreateCustomerPaymentCardLabelDinersClub      CreateCustomerPaymentCardLabel = "Diners Club"
	CreateCustomerPaymentCardLabelDiscover        CreateCustomerPaymentCardLabel = "Discover"
	CreateCustomerPaymentCardLabelJcb             CreateCustomerPaymentCardLabel = "JCB"
	CreateCustomerPaymentCardLabelLaser           CreateCustomerPaymentCardLabel = "Laser"
	CreateCustomerPaymentCardLabelMaestro         CreateCustomerPaymentCardLabel = "Maestro"
	CreateCustomerPaymentCardLabelMastercard      CreateCustomerPaymentCardLabel = "Mastercard"
	CreateCustomerPaymentCardLabelUnionpay        CreateCustomerPaymentCardLabel = "Unionpay"
	CreateCustomerPaymentCardLabelVisa            CreateCustomerPaymentCardLabel = "Visa"
	CreateCustomerPaymentCardLabelVpay            CreateCustomerPaymentCardLabel = "Vpay"
)

func (e CreateCustomerPaymentCardLabel) ToPointer() *CreateCustomerPaymentCardLabel {
	return &e
}
func (e *CreateCustomerPaymentCardLabel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "American Express":
		fallthrough
	case "Carta Si":
		fallthrough
	case "Carte Bleue":
		fallthrough
	case "Dankort":
		fallthrough
	case "Diners Club":
		fallthrough
	case "Discover":
		fallthrough
	case "JCB":
		fallthrough
	case "Laser":
		fallthrough
	case "Maestro":
		fallthrough
	case "Mastercard":
		fallthrough
	case "Unionpay":
		fallthrough
	case "Visa":
		fallthrough
	case "Vpay":
		*e = CreateCustomerPaymentCardLabel(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCardLabel: %v", v)
	}
}

// CreateCustomerPaymentCardFunding - The card type.
type CreateCustomerPaymentCardFunding string

const (
	CreateCustomerPaymentCardFundingDebit         CreateCustomerPaymentCardFunding = "debit"
	CreateCustomerPaymentCardFundingCredit        CreateCustomerPaymentCardFunding = "credit"
	CreateCustomerPaymentCardFundingPrepaid       CreateCustomerPaymentCardFunding = "prepaid"
	CreateCustomerPaymentCardFundingDeferredDebit CreateCustomerPaymentCardFunding = "deferred-debit"
)

func (e CreateCustomerPaymentCardFunding) ToPointer() *CreateCustomerPaymentCardFunding {
	return &e
}
func (e *CreateCustomerPaymentCardFunding) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "debit":
		fallthrough
	case "credit":
		fallthrough
	case "prepaid":
		fallthrough
	case "deferred-debit":
		*e = CreateCustomerPaymentCardFunding(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCardFunding: %v", v)
	}
}

// CreateCustomerPaymentCardSecurity - The level of security applied during card processing.
type CreateCustomerPaymentCardSecurity string

const (
	CreateCustomerPaymentCardSecurityNormal       CreateCustomerPaymentCardSecurity = "normal"
	CreateCustomerPaymentCardSecurityThreedsecure CreateCustomerPaymentCardSecurity = "3dsecure"
)

func (e CreateCustomerPaymentCardSecurity) ToPointer() *CreateCustomerPaymentCardSecurity {
	return &e
}
func (e *CreateCustomerPaymentCardSecurity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "normal":
		fallthrough
	case "3dsecure":
		*e = CreateCustomerPaymentCardSecurity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCardSecurity: %v", v)
	}
}

// CreateCustomerPaymentFeeRegion - The applicable card fee region.
type CreateCustomerPaymentFeeRegion string

const (
	CreateCustomerPaymentFeeRegionAmericanExpress  CreateCustomerPaymentFeeRegion = "american-express"
	CreateCustomerPaymentFeeRegionAmexIntraEea     CreateCustomerPaymentFeeRegion = "amex-intra-eea"
	CreateCustomerPaymentFeeRegionCarteBancaire    CreateCustomerPaymentFeeRegion = "carte-bancaire"
	CreateCustomerPaymentFeeRegionIntraEu          CreateCustomerPaymentFeeRegion = "intra-eu"
	CreateCustomerPaymentFeeRegionIntraEuCorporate CreateCustomerPaymentFeeRegion = "intra-eu-corporate"
	CreateCustomerPaymentFeeRegionDomestic         CreateCustomerPaymentFeeRegion = "domestic"
	CreateCustomerPaymentFeeRegionMaestro          CreateCustomerPaymentFeeRegion = "maestro"
	CreateCustomerPaymentFeeRegionOther            CreateCustomerPaymentFeeRegion = "other"
	CreateCustomerPaymentFeeRegionInter            CreateCustomerPaymentFeeRegion = "inter"
	CreateCustomerPaymentFeeRegionIntraEea         CreateCustomerPaymentFeeRegion = "intra_eea"
)

func (e CreateCustomerPaymentFeeRegion) ToPointer() *CreateCustomerPaymentFeeRegion {
	return &e
}
func (e *CreateCustomerPaymentFeeRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "american-express":
		fallthrough
	case "amex-intra-eea":
		fallthrough
	case "carte-bancaire":
		fallthrough
	case "intra-eu":
		fallthrough
	case "intra-eu-corporate":
		fallthrough
	case "domestic":
		fallthrough
	case "maestro":
		fallthrough
	case "other":
		fallthrough
	case "inter":
		fallthrough
	case "intra_eea":
		*e = CreateCustomerPaymentFeeRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentFeeRegion: %v", v)
	}
}

// CreateCustomerPaymentFailureReason - A failure code to help understand why the payment failed.
type CreateCustomerPaymentFailureReason string

const (
	CreateCustomerPaymentFailureReasonAuthenticationAbandoned      CreateCustomerPaymentFailureReason = "authentication_abandoned"
	CreateCustomerPaymentFailureReasonAuthenticationFailed         CreateCustomerPaymentFailureReason = "authentication_failed"
	CreateCustomerPaymentFailureReasonAuthenticationRequired       CreateCustomerPaymentFailureReason = "authentication_required"
	CreateCustomerPaymentFailureReasonAuthenticationUnavailableAcs CreateCustomerPaymentFailureReason = "authentication_unavailable_acs"
	CreateCustomerPaymentFailureReasonCardDeclined                 CreateCustomerPaymentFailureReason = "card_declined"
	CreateCustomerPaymentFailureReasonCardExpired                  CreateCustomerPaymentFailureReason = "card_expired"
	CreateCustomerPaymentFailureReasonInactiveCard                 CreateCustomerPaymentFailureReason = "inactive_card"
	CreateCustomerPaymentFailureReasonInsufficientFunds            CreateCustomerPaymentFailureReason = "insufficient_funds"
	CreateCustomerPaymentFailureReasonInvalidCvv                   CreateCustomerPaymentFailureReason = "invalid_cvv"
	CreateCustomerPaymentFailureReasonInvalidCardHolderName        CreateCustomerPaymentFailureReason = "invalid_card_holder_name"
	CreateCustomerPaymentFailureReasonInvalidCardNumber            CreateCustomerPaymentFailureReason = "invalid_card_number"
	CreateCustomerPaymentFailureReasonInvalidCardType              CreateCustomerPaymentFailureReason = "invalid_card_type"
	CreateCustomerPaymentFailureReasonPossibleFraud                CreateCustomerPaymentFailureReason = "possible_fraud"
	CreateCustomerPaymentFailureReasonRefusedByIssuer              CreateCustomerPaymentFailureReason = "refused_by_issuer"
	CreateCustomerPaymentFailureReasonUnknownReason                CreateCustomerPaymentFailureReason = "unknown_reason"
)

func (e CreateCustomerPaymentFailureReason) ToPointer() *CreateCustomerPaymentFailureReason {
	return &e
}
func (e *CreateCustomerPaymentFailureReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "authentication_abandoned":
		fallthrough
	case "authentication_failed":
		fallthrough
	case "authentication_required":
		fallthrough
	case "authentication_unavailable_acs":
		fallthrough
	case "card_declined":
		fallthrough
	case "card_expired":
		fallthrough
	case "inactive_card":
		fallthrough
	case "insufficient_funds":
		fallthrough
	case "invalid_cvv":
		fallthrough
	case "invalid_card_holder_name":
		fallthrough
	case "invalid_card_number":
		fallthrough
	case "invalid_card_type":
		fallthrough
	case "possible_fraud":
		fallthrough
	case "refused_by_issuer":
		fallthrough
	case "unknown_reason":
		*e = CreateCustomerPaymentFailureReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentFailureReason: %v", v)
	}
}

// CreateCustomerPaymentWallet - The wallet used when creating the payment.
type CreateCustomerPaymentWallet string

const (
	CreateCustomerPaymentWalletApplepay CreateCustomerPaymentWallet = "applepay"
)

func (e CreateCustomerPaymentWallet) ToPointer() *CreateCustomerPaymentWallet {
	return &e
}
func (e *CreateCustomerPaymentWallet) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "applepay":
		*e = CreateCustomerPaymentWallet(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentWallet: %v", v)
	}
}

// CreateCustomerPaymentSellerProtection - Indicates to what extent the payment is eligible for PayPal's Seller Protection. Only available for PayPal
// payments, and if the information is made available by PayPal.
type CreateCustomerPaymentSellerProtection string

const (
	CreateCustomerPaymentSellerProtectionEligible                          CreateCustomerPaymentSellerProtection = "Eligible"
	CreateCustomerPaymentSellerProtectionIneligible                        CreateCustomerPaymentSellerProtection = "Ineligible"
	CreateCustomerPaymentSellerProtectionPartiallyEligibleInrOnly          CreateCustomerPaymentSellerProtection = "Partially Eligible - INR Only"
	CreateCustomerPaymentSellerProtectionPartiallyEligibleUnauthOnly       CreateCustomerPaymentSellerProtection = "Partially Eligible - Unauth Only"
	CreateCustomerPaymentSellerProtectionPartiallyEligible                 CreateCustomerPaymentSellerProtection = "Partially Eligible"
	CreateCustomerPaymentSellerProtectionNone                              CreateCustomerPaymentSellerProtection = "None"
	CreateCustomerPaymentSellerProtectionActive                            CreateCustomerPaymentSellerProtection = "Active"
	CreateCustomerPaymentSellerProtectionFraudControlUnauthPremiumEligible CreateCustomerPaymentSellerProtection = "Fraud Control - Unauth Premium Eligible"
)

func (e CreateCustomerPaymentSellerProtection) ToPointer() *CreateCustomerPaymentSellerProtection {
	return &e
}
func (e *CreateCustomerPaymentSellerProtection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Eligible":
		fallthrough
	case "Ineligible":
		fallthrough
	case "Partially Eligible - INR Only":
		fallthrough
	case "Partially Eligible - Unauth Only":
		fallthrough
	case "Partially Eligible":
		fallthrough
	case "None":
		fallthrough
	case "Active":
		fallthrough
	case "Fraud Control - Unauth Premium Eligible":
		*e = CreateCustomerPaymentSellerProtection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentSellerProtection: %v", v)
	}
}

// CreateCustomerPaymentPaypalFee - An amount object containing the fee PayPal will charge for this transaction. The field may be omitted if
// PayPal will not charge a fee for this transaction.
type CreateCustomerPaymentPaypalFee struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentPaypalFee) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentPaypalFee) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentCardReadMethod - The method by which the card was read by the terminal.
type CreateCustomerPaymentCardReadMethod string

const (
	CreateCustomerPaymentCardReadMethodChip                   CreateCustomerPaymentCardReadMethod = "chip"
	CreateCustomerPaymentCardReadMethodMagneticStripe         CreateCustomerPaymentCardReadMethod = "magnetic-stripe"
	CreateCustomerPaymentCardReadMethodNearFieldCommunication CreateCustomerPaymentCardReadMethod = "near-field-communication"
	CreateCustomerPaymentCardReadMethodContactless            CreateCustomerPaymentCardReadMethod = "contactless"
	CreateCustomerPaymentCardReadMethodMoto                   CreateCustomerPaymentCardReadMethod = "moto"
)

func (e CreateCustomerPaymentCardReadMethod) ToPointer() *CreateCustomerPaymentCardReadMethod {
	return &e
}
func (e *CreateCustomerPaymentCardReadMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "chip":
		fallthrough
	case "magnetic-stripe":
		fallthrough
	case "near-field-communication":
		fallthrough
	case "contactless":
		fallthrough
	case "moto":
		*e = CreateCustomerPaymentCardReadMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCardReadMethod: %v", v)
	}
}

// CreateCustomerPaymentCardVerificationMethod - The method used to verify the cardholder's identity.
type CreateCustomerPaymentCardVerificationMethod string

const (
	CreateCustomerPaymentCardVerificationMethodNoCvmRequired         CreateCustomerPaymentCardVerificationMethod = "no-cvm-required"
	CreateCustomerPaymentCardVerificationMethodOnlinePin             CreateCustomerPaymentCardVerificationMethod = "online-pin"
	CreateCustomerPaymentCardVerificationMethodOfflinePin            CreateCustomerPaymentCardVerificationMethod = "offline-pin"
	CreateCustomerPaymentCardVerificationMethodConsumerDevice        CreateCustomerPaymentCardVerificationMethod = "consumer-device"
	CreateCustomerPaymentCardVerificationMethodSignature             CreateCustomerPaymentCardVerificationMethod = "signature"
	CreateCustomerPaymentCardVerificationMethodSignatureAndOnlinePin CreateCustomerPaymentCardVerificationMethod = "signature-and-online-pin"
	CreateCustomerPaymentCardVerificationMethodOnlinePinAndSignature CreateCustomerPaymentCardVerificationMethod = "online-pin-and-signature"
	CreateCustomerPaymentCardVerificationMethodNone                  CreateCustomerPaymentCardVerificationMethod = "none"
	CreateCustomerPaymentCardVerificationMethodFailed                CreateCustomerPaymentCardVerificationMethod = "failed"
)

func (e CreateCustomerPaymentCardVerificationMethod) ToPointer() *CreateCustomerPaymentCardVerificationMethod {
	return &e
}
func (e *CreateCustomerPaymentCardVerificationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no-cvm-required":
		fallthrough
	case "online-pin":
		fallthrough
	case "offline-pin":
		fallthrough
	case "consumer-device":
		fallthrough
	case "signature":
		fallthrough
	case "signature-and-online-pin":
		fallthrough
	case "online-pin-and-signature":
		fallthrough
	case "none":
		fallthrough
	case "failed":
		*e = CreateCustomerPaymentCardVerificationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCustomerPaymentCardVerificationMethod: %v", v)
	}
}

// CreateCustomerPaymentReceipt - The Point of sale receipt object.
type CreateCustomerPaymentReceipt struct {
	// A unique code provided by the cardholder’s bank to confirm that the transaction was successfully approved.
	AuthorizationCode *string `json:"authorizationCode,omitempty"`
	// The unique number that identifies a specific payment application on a chip card.
	ApplicationIdentifier *string `json:"applicationIdentifier,omitempty"`
	// The method by which the card was read by the terminal.
	CardReadMethod *CreateCustomerPaymentCardReadMethod `json:"cardReadMethod,omitempty"`
	// The method used to verify the cardholder's identity.
	CardVerificationMethod *CreateCustomerPaymentCardVerificationMethod `json:"cardVerificationMethod,omitempty"`
}

func (o *CreateCustomerPaymentReceipt) GetAuthorizationCode() *string {
	if o == nil {
		return nil
	}
	return o.AuthorizationCode
}

func (o *CreateCustomerPaymentReceipt) GetApplicationIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.ApplicationIdentifier
}

func (o *CreateCustomerPaymentReceipt) GetCardReadMethod() *CreateCustomerPaymentCardReadMethod {
	if o == nil {
		return nil
	}
	return o.CardReadMethod
}

func (o *CreateCustomerPaymentReceipt) GetCardVerificationMethod() *CreateCustomerPaymentCardVerificationMethod {
	if o == nil {
		return nil
	}
	return o.CardVerificationMethod
}

// CreateCustomerPaymentQrCode - Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
// the QR code details will be available in this object.
//
// The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
// Bancontact QR payments can be completed by the customer using the Bancontact app.
type CreateCustomerPaymentQrCode struct {
	// The height of the QR code image in pixels.
	Height *int64 `json:"height,omitempty"`
	// The width of the QR code image in pixels.
	Width *int64 `json:"width,omitempty"`
	// The URL to the QR code image. The image is a PNG file, and can be displayed directly in the browser or
	// downloaded.
	Src *string `json:"src,omitempty"`
}

func (o *CreateCustomerPaymentQrCode) GetHeight() *int64 {
	if o == nil {
		return nil
	}
	return o.Height
}

func (o *CreateCustomerPaymentQrCode) GetWidth() *int64 {
	if o == nil {
		return nil
	}
	return o.Width
}

func (o *CreateCustomerPaymentQrCode) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

// CreateCustomerPaymentRemainderAmount - An amount object for the amount that remained after all gift cards or vouchers were applied.
type CreateCustomerPaymentRemainderAmount struct {
	// A three-character ISO 4217 currency code.
	Currency string `json:"currency"`
	// A string containing an exact monetary amount in the given currency.
	Value string `json:"value"`
}

func (o *CreateCustomerPaymentRemainderAmount) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *CreateCustomerPaymentRemainderAmount) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// CreateCustomerPaymentDetails - An object containing payment details collected during the payment process. For example, details may include the
// customer's card or bank details and a payment reference. For the full list of details, please refer to the
// [method-specific parameters](extra-payment-parameters) guide.
type CreateCustomerPaymentDetails struct {
	// The customer's name, if made available by the payment method. For card payments, refer to details.cardHolder.
	ConsumerName *string `json:"consumerName,omitempty"`
	// The customer's account reference.
	//
	// For banking-based payment methods — such as iDEAL — this is normally either an IBAN or a domestic bank account
	// number.
	//
	// For PayPal, the account reference is an email address.
	//
	// For card and Bancontact payments, refer to details.cardNumber.
	ConsumerAccount *string `json:"consumerAccount,omitempty"`
	// The BIC of the customer's bank account, if applicable.
	ConsumerBic *string `json:"consumerBic,omitempty"`
	// For wallet payment methods — such as Apple Pay and PayPal — the shipping address is often already known by the
	// wallet provider. In these cases the shipping address may be available as a payment detail.
	ShippingAddress map[string]any `json:"shippingAddress,omitempty"`
	// For bancontact, it will be the customer's masked card number. For cards, it will be the last 4-digit of the
	// PAN. For Point-of-sale, it will be the the last 4 digits of the customer's masked card number.
	CardNumber *string `json:"cardNumber,omitempty"`
	// The name of the bank that the customer will need to make the bank transfer payment towards.
	BankName *string `json:"bankName,omitempty"`
	// The bank account number the customer will need to make the bank transfer payment towards.
	BankAccount *string `json:"bankAccount,omitempty"`
	// The BIC of the bank the customer will need to make the bank transfer payment towards.
	BankBic *string `json:"bankBic,omitempty"`
	// The Mollie-generated reference the customer needs to use when transfering the amount. Do not apply any
	// formatting here; show it to the customer as-is.
	TransferReference *string `json:"transferReference,omitempty"`
	// A unique fingerprint for a specific card. Can be used to identify returning customers.
	//
	// In the case of Point-of-sale payments, it's a unique identifier assigned to a cardholder's payment account,
	// linking multiple transactions from wallets and physical card to a single account, also across payment methods
	// or when the card is reissued.
	CardFingerprint *string `json:"cardFingerprint,omitempty"`
	// The customer's name as shown on their card.
	CardHolder *string `json:"cardHolder,omitempty"`
	// The card's target audience, if known.
	CardAudition *CreateCustomerPaymentCardAudition `json:"cardAudition,omitempty"`
	// The card's label, if known.
	CardLabel *CreateCustomerPaymentCardLabel `json:"cardLabel,omitempty"`
	// The ISO 3166-1 alpha-2 country code of the country the card was issued in.
	CardCountryCode *string `json:"cardCountryCode,omitempty"`
	// The expiry date (MM/YY) of the card as displayed on the card.
	CardExpiryDate *string `json:"cardExpiryDate,omitempty"`
	// The card type.
	CardFunding *CreateCustomerPaymentCardFunding `json:"cardFunding,omitempty"`
	// The level of security applied during card processing.
	CardSecurity *CreateCustomerPaymentCardSecurity `json:"cardSecurity,omitempty"`
	// The applicable card fee region.
	FeeRegion *CreateCustomerPaymentFeeRegion `json:"feeRegion,omitempty"`
	// The first 6 and last 4 digits of the card number.
	CardMaskedNumber *string `json:"cardMaskedNumber,omitempty"`
	// The outcome of authentication attempted on transactions enforced by 3DS (ie valid only for oneoff and first).
	Card3dsEci *string `json:"card3dsEci,omitempty"`
	// The first 6 digit of the card bank identification number.
	CardBin *string `json:"cardBin,omitempty"`
	// The issuer of the Card.
	CardIssuer *string `json:"cardIssuer,omitempty"`
	// A failure code to help understand why the payment failed.
	FailureReason *CreateCustomerPaymentFailureReason `json:"failureReason,omitempty"`
	// A human-friendly failure message that can be shown to the customer. The message is translated in accordance
	// with the payment's locale setting.
	FailureMessage *string `json:"failureMessage,omitempty"`
	// The wallet used when creating the payment.
	Wallet *CreateCustomerPaymentWallet `json:"wallet,omitempty"`
	// PayPal's reference for the payment.
	PaypalReference *string `json:"paypalReference,omitempty"`
	// ID of the customer's PayPal account.
	PaypalPayerID *string `json:"paypalPayerId,omitempty"`
	// Indicates to what extent the payment is eligible for PayPal's Seller Protection. Only available for PayPal
	// payments, and if the information is made available by PayPal.
	SellerProtection *CreateCustomerPaymentSellerProtection `json:"sellerProtection,omitempty"`
	// An amount object containing the fee PayPal will charge for this transaction. The field may be omitted if
	// PayPal will not charge a fee for this transaction.
	PaypalFee *CreateCustomerPaymentPaypalFee `json:"paypalFee,omitempty"`
	// The paysafecard customer reference either provided via the API or otherwise auto-generated by Mollie.
	CustomerReference *string `json:"customerReference,omitempty"`
	// The ID of the terminal device where the payment took place on.
	TerminalID *string `json:"terminalId,omitempty"`
	// The first 6 digits & last 4 digits of the customer's masked card number.
	MaskedNumber *string `json:"maskedNumber,omitempty"`
	// The Point of sale receipt object.
	Receipt *CreateCustomerPaymentReceipt `json:"receipt,omitempty"`
	// The creditor identifier indicates who is authorized to execute the payment. In this case, it is a
	// reference to Mollie.
	CreditorIdentifier *string `json:"creditorIdentifier,omitempty"`
	// Estimated date the payment is debited from the customer's bank account, in YYYY-MM-DD format.
	DueDate *types.Date `json:"dueDate,omitempty"`
	// Date the payment has been signed by the customer, in YYYY-MM-DD format. Only available if the payment
	// has been signed.
	SignatureDate *types.Date `json:"signatureDate,omitempty"`
	// The official reason why this payment has failed. A detailed description of each reason is available on the
	// website of the European Payments Council.
	BankReasonCode *string `json:"bankReasonCode,omitempty"`
	// A human-friendly description of the failure reason.
	BankReason *string `json:"bankReason,omitempty"`
	// The end-to-end identifier you provided in the batch file.
	EndToEndIdentifier *string `json:"endToEndIdentifier,omitempty"`
	// The mandate reference you provided in the batch file.
	MandateReference *string `json:"mandateReference,omitempty"`
	// The batch reference you provided in the batch file.
	BatchReference *string `json:"batchReference,omitempty"`
	// The file reference you provided in the batch file.
	FileReference *string `json:"fileReference,omitempty"`
	// Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
	// the QR code details will be available in this object.
	//
	// The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
	// Bancontact QR payments can be completed by the customer using the Bancontact app.
	QrCode *CreateCustomerPaymentQrCode `json:"qrCode,omitempty"`
	// For payments with gift cards: the masked gift card number of the first gift card applied to the payment.
	VoucherNumber *string `json:"voucherNumber,omitempty"`
	// An array of detail objects for each gift card that was used on this payment, if any.
	Giftcards []map[string]any `json:"giftcards,omitempty"`
	// For payments with vouchers: the brand name of the first voucher applied.
	Issuer *string `json:"issuer,omitempty"`
	// An array of detail objects for each voucher that was used on this payment, if any.
	Vouchers []map[string]any `json:"vouchers,omitempty"`
	// An amount object for the amount that remained after all gift cards or vouchers were applied.
	RemainderAmount *CreateCustomerPaymentRemainderAmount `json:"remainderAmount,omitempty"`
	// The payment method used to pay the remainder amount, after all gift cards or vouchers were applied.
	RemainderMethod *string `json:"remainderMethod,omitempty"`
	// Optional include. The full payment method details of the remainder payment.
	RemainderDetails map[string]any `json:"remainderDetails,omitempty"`
}

func (c CreateCustomerPaymentDetails) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateCustomerPaymentDetails) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *CreateCustomerPaymentDetails) GetConsumerName() *string {
	if o == nil {
		return nil
	}
	return o.ConsumerName
}

func (o *CreateCustomerPaymentDetails) GetConsumerAccount() *string {
	if o == nil {
		return nil
	}
	return o.ConsumerAccount
}

func (o *CreateCustomerPaymentDetails) GetConsumerBic() *string {
	if o == nil {
		return nil
	}
	return o.ConsumerBic
}

func (o *CreateCustomerPaymentDetails) GetShippingAddress() map[string]any {
	if o == nil {
		return nil
	}
	return o.ShippingAddress
}

func (o *CreateCustomerPaymentDetails) GetCardNumber() *string {
	if o == nil {
		return nil
	}
	return o.CardNumber
}

func (o *CreateCustomerPaymentDetails) GetBankName() *string {
	if o == nil {
		return nil
	}
	return o.BankName
}

func (o *CreateCustomerPaymentDetails) GetBankAccount() *string {
	if o == nil {
		return nil
	}
	return o.BankAccount
}

func (o *CreateCustomerPaymentDetails) GetBankBic() *string {
	if o == nil {
		return nil
	}
	return o.BankBic
}

func (o *CreateCustomerPaymentDetails) GetTransferReference() *string {
	if o == nil {
		return nil
	}
	return o.TransferReference
}

func (o *CreateCustomerPaymentDetails) GetCardFingerprint() *string {
	if o == nil {
		return nil
	}
	return o.CardFingerprint
}

func (o *CreateCustomerPaymentDetails) GetCardHolder() *string {
	if o == nil {
		return nil
	}
	return o.CardHolder
}

func (o *CreateCustomerPaymentDetails) GetCardAudition() *CreateCustomerPaymentCardAudition {
	if o == nil {
		return nil
	}
	return o.CardAudition
}

func (o *CreateCustomerPaymentDetails) GetCardLabel() *CreateCustomerPaymentCardLabel {
	if o == nil {
		return nil
	}
	return o.CardLabel
}

func (o *CreateCustomerPaymentDetails) GetCardCountryCode() *string {
	if o == nil {
		return nil
	}
	return o.CardCountryCode
}

func (o *CreateCustomerPaymentDetails) GetCardExpiryDate() *string {
	if o == nil {
		return nil
	}
	return o.CardExpiryDate
}

func (o *CreateCustomerPaymentDetails) GetCardFunding() *CreateCustomerPaymentCardFunding {
	if o == nil {
		return nil
	}
	return o.CardFunding
}

func (o *CreateCustomerPaymentDetails) GetCardSecurity() *CreateCustomerPaymentCardSecurity {
	if o == nil {
		return nil
	}
	return o.CardSecurity
}

func (o *CreateCustomerPaymentDetails) GetFeeRegion() *CreateCustomerPaymentFeeRegion {
	if o == nil {
		return nil
	}
	return o.FeeRegion
}

func (o *CreateCustomerPaymentDetails) GetCardMaskedNumber() *string {
	if o == nil {
		return nil
	}
	return o.CardMaskedNumber
}

func (o *CreateCustomerPaymentDetails) GetCard3dsEci() *string {
	if o == nil {
		return nil
	}
	return o.Card3dsEci
}

func (o *CreateCustomerPaymentDetails) GetCardBin() *string {
	if o == nil {
		return nil
	}
	return o.CardBin
}

func (o *CreateCustomerPaymentDetails) GetCardIssuer() *string {
	if o == nil {
		return nil
	}
	return o.CardIssuer
}

func (o *CreateCustomerPaymentDetails) GetFailureReason() *CreateCustomerPaymentFailureReason {
	if o == nil {
		return nil
	}
	return o.FailureReason
}

func (o *CreateCustomerPaymentDetails) GetFailureMessage() *string {
	if o == nil {
		return nil
	}
	return o.FailureMessage
}

func (o *CreateCustomerPaymentDetails) GetWallet() *CreateCustomerPaymentWallet {
	if o == nil {
		return nil
	}
	return o.Wallet
}

func (o *CreateCustomerPaymentDetails) GetPaypalReference() *string {
	if o == nil {
		return nil
	}
	return o.PaypalReference
}

func (o *CreateCustomerPaymentDetails) GetPaypalPayerID() *string {
	if o == nil {
		return nil
	}
	return o.PaypalPayerID
}

func (o *CreateCustomerPaymentDetails) GetSellerProtection() *CreateCustomerPaymentSellerProtection {
	if o == nil {
		return nil
	}
	return o.SellerProtection
}

func (o *CreateCustomerPaymentDetails) GetPaypalFee() *CreateCustomerPaymentPaypalFee {
	if o == nil {
		return nil
	}
	return o.PaypalFee
}

func (o *CreateCustomerPaymentDetails) GetCustomerReference() *string {
	if o == nil {
		return nil
	}
	return o.CustomerReference
}

func (o *CreateCustomerPaymentDetails) GetTerminalID() *string {
	if o == nil {
		return nil
	}
	return o.TerminalID
}

func (o *CreateCustomerPaymentDetails) GetMaskedNumber() *string {
	if o == nil {
		return nil
	}
	return o.MaskedNumber
}

func (o *CreateCustomerPaymentDetails) GetReceipt() *CreateCustomerPaymentReceipt {
	if o == nil {
		return nil
	}
	return o.Receipt
}

func (o *CreateCustomerPaymentDetails) GetCreditorIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.CreditorIdentifier
}

func (o *CreateCustomerPaymentDetails) GetDueDate() *types.Date {
	if o == nil {
		return nil
	}
	return o.DueDate
}

func (o *CreateCustomerPaymentDetails) GetSignatureDate() *types.Date {
	if o == nil {
		return nil
	}
	return o.SignatureDate
}

func (o *CreateCustomerPaymentDetails) GetBankReasonCode() *string {
	if o == nil {
		return nil
	}
	return o.BankReasonCode
}

func (o *CreateCustomerPaymentDetails) GetBankReason() *string {
	if o == nil {
		return nil
	}
	return o.BankReason
}

func (o *CreateCustomerPaymentDetails) GetEndToEndIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.EndToEndIdentifier
}

func (o *CreateCustomerPaymentDetails) GetMandateReference() *string {
	if o == nil {
		return nil
	}
	return o.MandateReference
}

func (o *CreateCustomerPaymentDetails) GetBatchReference() *string {
	if o == nil {
		return nil
	}
	return o.BatchReference
}

func (o *CreateCustomerPaymentDetails) GetFileReference() *string {
	if o == nil {
		return nil
	}
	return o.FileReference
}

func (o *CreateCustomerPaymentDetails) GetQrCode() *CreateCustomerPaymentQrCode {
	if o == nil {
		return nil
	}
	return o.QrCode
}

func (o *CreateCustomerPaymentDetails) GetVoucherNumber() *string {
	if o == nil {
		return nil
	}
	return o.VoucherNumber
}

func (o *CreateCustomerPaymentDetails) GetGiftcards() []map[string]any {
	if o == nil {
		return nil
	}
	return o.Giftcards
}

func (o *CreateCustomerPaymentDetails) GetIssuer() *string {
	if o == nil {
		return nil
	}
	return o.Issuer
}

func (o *CreateCustomerPaymentDetails) GetVouchers() []map[string]any {
	if o == nil {
		return nil
	}
	return o.Vouchers
}

func (o *CreateCustomerPaymentDetails) GetRemainderAmount() *CreateCustomerPaymentRemainderAmount {
	if o == nil {
		return nil
	}
	return o.RemainderAmount
}

func (o *CreateCustomerPaymentDetails) GetRemainderMethod() *string {
	if o == nil {
		return nil
	}
	return o.RemainderMethod
}

func (o *CreateCustomerPaymentDetails) GetRemainderDetails() map[string]any {
	if o == nil {
		return nil
	}
	return o.RemainderDetails
}

// CreateCustomerPaymentSelfResponse - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type CreateCustomerPaymentSelfResponse struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentSelfResponse) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentSelfResponse) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentCheckout - The URL your customer should visit to make the payment. This is where you should redirect the customer to.
type CreateCustomerPaymentCheckout struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentCheckout) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentCheckout) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentMobileAppCheckout - The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
type CreateCustomerPaymentMobileAppCheckout struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentMobileAppCheckout) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentMobileAppCheckout) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentChangePaymentState - For test mode payments in certain scenarios, a hosted interface is available to help you test different
// payment states.
//
// Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
// payments are executed without any user interaction.
//
// Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
// chargeback for the test payment.
type CreateCustomerPaymentChangePaymentState struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentChangePaymentState) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentChangePaymentState) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentDashboard - Direct link to the payment in the Mollie Dashboard.
type CreateCustomerPaymentDashboard struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentDashboard) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentDashboard) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentRefunds - The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
type CreateCustomerPaymentRefunds struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentRefunds) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentRefunds) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentChargebacks - The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
// payment.
type CreateCustomerPaymentChargebacks struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentChargebacks) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentChargebacks) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentCaptures - The API resource URL of the [captures](list-payment-captures) that belong to this payment.
type CreateCustomerPaymentCaptures struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentCaptures) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentCaptures) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentSettlement - The API resource URL of the [settlement](get-settlement) this payment has been settled with.
// Not present if not yet settled.
type CreateCustomerPaymentSettlement struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentSettlement) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentSettlement) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentCustomer - The API resource URL of the [customer](get-customer).
type CreateCustomerPaymentCustomer struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentCustomer) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentCustomer) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentMandate - The API resource URL of the [mandate](get-mandate).
type CreateCustomerPaymentMandate struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentMandate) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentMandate) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentSubscription - The API resource URL of the [subscription](get-subscription).
type CreateCustomerPaymentSubscription struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentSubscription) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentSubscription) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentOrder - The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
// order.
type CreateCustomerPaymentOrder struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentOrder) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentOrder) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentTerminal - The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
// point-of-sale payments.
type CreateCustomerPaymentTerminal struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentTerminal) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentTerminal) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentDocumentation - In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
type CreateCustomerPaymentDocumentation struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentDocumentation) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentDocumentation) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentLinksStatus - Link to customer-facing page showing the status of the bank transfer (to verify if the transaction was
// successful).
type CreateCustomerPaymentLinksStatus struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentLinksStatus) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentLinksStatus) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentPayOnline - Link to Mollie Checkout page allowing customers to select a different payment method instead of legacy
// bank transfer.
type CreateCustomerPaymentPayOnline struct {
	// The actual URL string.
	Href string `json:"href"`
	// The content type of the page or endpoint the URL points to.
	Type string `json:"type"`
}

func (o *CreateCustomerPaymentPayOnline) GetHref() string {
	if o == nil {
		return ""
	}
	return o.Href
}

func (o *CreateCustomerPaymentPayOnline) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// CreateCustomerPaymentLinksResponse - An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
type CreateCustomerPaymentLinksResponse struct {
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Self CreateCustomerPaymentSelfResponse `json:"self"`
	// The URL your customer should visit to make the payment. This is where you should redirect the customer to.
	Checkout *CreateCustomerPaymentCheckout `json:"checkout,omitempty"`
	// The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
	MobileAppCheckout *CreateCustomerPaymentMobileAppCheckout `json:"mobileAppCheckout,omitempty"`
	// For test mode payments in certain scenarios, a hosted interface is available to help you test different
	// payment states.
	//
	// Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
	// payments are executed without any user interaction.
	//
	// Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
	// chargeback for the test payment.
	ChangePaymentState *CreateCustomerPaymentChangePaymentState `json:"changePaymentState,omitempty"`
	// Direct link to the payment in the Mollie Dashboard.
	Dashboard CreateCustomerPaymentDashboard `json:"dashboard"`
	// The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
	Refunds *CreateCustomerPaymentRefunds `json:"refunds,omitempty"`
	// The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
	// payment.
	Chargebacks *CreateCustomerPaymentChargebacks `json:"chargebacks,omitempty"`
	// The API resource URL of the [captures](list-payment-captures) that belong to this payment.
	Captures *CreateCustomerPaymentCaptures `json:"captures,omitempty"`
	// The API resource URL of the [settlement](get-settlement) this payment has been settled with.
	// Not present if not yet settled.
	Settlement *CreateCustomerPaymentSettlement `json:"settlement,omitempty"`
	// The API resource URL of the [customer](get-customer).
	Customer *CreateCustomerPaymentCustomer `json:"customer,omitempty"`
	// The API resource URL of the [mandate](get-mandate).
	Mandate *CreateCustomerPaymentMandate `json:"mandate,omitempty"`
	// The API resource URL of the [subscription](get-subscription).
	Subscription *CreateCustomerPaymentSubscription `json:"subscription,omitempty"`
	// The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
	// order.
	Order *CreateCustomerPaymentOrder `json:"order,omitempty"`
	// The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
	// point-of-sale payments.
	Terminal *CreateCustomerPaymentTerminal `json:"terminal,omitempty"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Documentation *CreateCustomerPaymentDocumentation `json:"documentation,omitempty"`
	// Link to customer-facing page showing the status of the bank transfer (to verify if the transaction was
	// successful).
	Status *CreateCustomerPaymentLinksStatus `json:"status,omitempty"`
	// Link to Mollie Checkout page allowing customers to select a different payment method instead of legacy
	// bank transfer.
	PayOnline *CreateCustomerPaymentPayOnline `json:"payOnline,omitempty"`
}

func (o *CreateCustomerPaymentLinksResponse) GetSelf() CreateCustomerPaymentSelfResponse {
	if o == nil {
		return CreateCustomerPaymentSelfResponse{}
	}
	return o.Self
}

func (o *CreateCustomerPaymentLinksResponse) GetCheckout() *CreateCustomerPaymentCheckout {
	if o == nil {
		return nil
	}
	return o.Checkout
}

func (o *CreateCustomerPaymentLinksResponse) GetMobileAppCheckout() *CreateCustomerPaymentMobileAppCheckout {
	if o == nil {
		return nil
	}
	return o.MobileAppCheckout
}

func (o *CreateCustomerPaymentLinksResponse) GetChangePaymentState() *CreateCustomerPaymentChangePaymentState {
	if o == nil {
		return nil
	}
	return o.ChangePaymentState
}

func (o *CreateCustomerPaymentLinksResponse) GetDashboard() CreateCustomerPaymentDashboard {
	if o == nil {
		return CreateCustomerPaymentDashboard{}
	}
	return o.Dashboard
}

func (o *CreateCustomerPaymentLinksResponse) GetRefunds() *CreateCustomerPaymentRefunds {
	if o == nil {
		return nil
	}
	return o.Refunds
}

func (o *CreateCustomerPaymentLinksResponse) GetChargebacks() *CreateCustomerPaymentChargebacks {
	if o == nil {
		return nil
	}
	return o.Chargebacks
}

func (o *CreateCustomerPaymentLinksResponse) GetCaptures() *CreateCustomerPaymentCaptures {
	if o == nil {
		return nil
	}
	return o.Captures
}

func (o *CreateCustomerPaymentLinksResponse) GetSettlement() *CreateCustomerPaymentSettlement {
	if o == nil {
		return nil
	}
	return o.Settlement
}

func (o *CreateCustomerPaymentLinksResponse) GetCustomer() *CreateCustomerPaymentCustomer {
	if o == nil {
		return nil
	}
	return o.Customer
}

func (o *CreateCustomerPaymentLinksResponse) GetMandate() *CreateCustomerPaymentMandate {
	if o == nil {
		return nil
	}
	return o.Mandate
}

func (o *CreateCustomerPaymentLinksResponse) GetSubscription() *CreateCustomerPaymentSubscription {
	if o == nil {
		return nil
	}
	return o.Subscription
}

func (o *CreateCustomerPaymentLinksResponse) GetOrder() *CreateCustomerPaymentOrder {
	if o == nil {
		return nil
	}
	return o.Order
}

func (o *CreateCustomerPaymentLinksResponse) GetTerminal() *CreateCustomerPaymentTerminal {
	if o == nil {
		return nil
	}
	return o.Terminal
}

func (o *CreateCustomerPaymentLinksResponse) GetDocumentation() *CreateCustomerPaymentDocumentation {
	if o == nil {
		return nil
	}
	return o.Documentation
}

func (o *CreateCustomerPaymentLinksResponse) GetStatus() *CreateCustomerPaymentLinksStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *CreateCustomerPaymentLinksResponse) GetPayOnline() *CreateCustomerPaymentPayOnline {
	if o == nil {
		return nil
	}
	return o.PayOnline
}

// CreateCustomerPaymentResponseBody - The newly created payment object.
type CreateCustomerPaymentResponseBody struct {
	// Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
	Resource string `json:"resource"`
	// The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
	// will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
	ID string `json:"id"`
	// Whether this entity was created in live mode or in test mode.
	Mode CreateCustomerPaymentMode `json:"mode"`
	// The description of the payment. This will be shown to your customer on their card or bank statement when possible.
	// We truncate the description automatically according to the limits of the used payment method. The description is
	// also visible in any exports you generate.
	//
	// We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
	// This is particularly useful for bookkeeping.
	//
	// The maximum length of the description field differs per payment method, with the absolute maximum being 255
	// characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
	Description string `json:"description"`
	// The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
	//
	// You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
	// retrieved using the Get method endpoint.
	//
	// If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
	// tip amount.
	Amount CreateCustomerPaymentAmountResponse `json:"amount"`
	// The total amount that is already refunded. Only available when refunds are available for this payment. For some
	// payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
	// costs for a return shipment to the customer.
	AmountRefunded *CreateCustomerPaymentAmountRefunded `json:"amountRefunded,omitempty"`
	// The remaining amount that can be refunded. Only available when refunds are available for this payment.
	AmountRemaining *CreateCustomerPaymentAmountRemaining `json:"amountRemaining,omitempty"`
	// The total amount that is already captured for this payment. Only available when this payment supports captures.
	AmountCaptured *CreateCustomerPaymentAmountCaptured `json:"amountCaptured,omitempty"`
	// The total amount that was charged back for this payment. Only available when the total charged back amount is not
	// zero.
	AmountChargedBack *CreateCustomerPaymentAmountChargedBack `json:"amountChargedBack,omitempty"`
	// This optional field will contain the approximate amount that will be settled to your account, converted to the
	// currency your account is settled in.
	//
	// Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
	// settled by Mollie the `settlementAmount` is omitted from the response.
	//
	// Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
	// using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
	SettlementAmount *CreateCustomerPaymentSettlementAmount `json:"settlementAmount,omitempty"`
	// The URL your customer will be redirected to after the payment process.
	//
	// It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
	// right page referencing the order when your customer returns.
	//
	// The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
	// Apple Pay payments with an `applePayPaymentToken`.
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
	// provided, the customer will be redirected to the `redirectUrl` instead — see above.
	//
	// Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
	// therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
	// payment cancellations.
	CancelURL *string `json:"cancelUrl,omitempty"`
	// The webhook URL where we will send payment status updates to.
	//
	// The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
	//
	// The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
	// webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
	// local machine.
	WebhookURL *string `json:"webhookUrl,omitempty"`
	// Optionally provide the order lines for the payment. Each line contains details such as a description of the item
	// ordered and its price.
	//
	// All lines must have the same currency as the payment.
	//
	// Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
	Lines []CreateCustomerPaymentLineResponse `json:"lines,omitempty"`
	// The customer's billing address details. We advise to provide these details to improve fraud protection and
	// conversion.
	//
	// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
	// `country`.
	//
	// Required for payment method `in3`, `klarna`, `billie` and `riverty`.
	BillingAddress *CreateCustomerPaymentBillingAddressResponse `json:"billingAddress,omitempty"`
	// The customer's shipping address details. We advise to provide these details to improve fraud protection and
	// conversion.
	//
	// Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
	// `country`.
	ShippingAddress *CreateCustomerPaymentShippingAddressResponse `json:"shippingAddress,omitempty"`
	// Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
	// is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
	// language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
	// locale, but our hosted payment pages currently only support the specified languages.
	//
	// For bank transfer payments specifically, the locale will determine the target bank account the customer has to
	// transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
	// customer use a local bank account greatly increases the conversion and speed of payment.
	Locale *CreateCustomerPaymentLocaleResponse `json:"locale,omitempty"`
	// This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
	// field is omitted if the country code was not detected.
	CountryCode *string `json:"countryCode,omitempty"`
	// The payment method used for this transaction. If a specific method was selected during payment initialization,
	// this field reflects that choice.
	Method *CreateCustomerPaymentMethodResponse `json:"method,omitempty"`
	// For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
	// rates you have used for the order to ensure your customer's country matches the VAT country.
	//
	// Use this parameter to restrict the payment methods available to your customer to those from a single country.
	//
	// If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
	//
	// The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
	RestrictPaymentMethodsToCountry *string `json:"restrictPaymentMethodsToCountry,omitempty"`
	// Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
	// you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
	Metadata *CreateCustomerPaymentMetadataResponse `json:"metadata,omitempty"`
	// Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
	// and capture at a later time.
	//
	// This field needs to be set to `manual` for method `riverty`.
	CaptureMode *CreateCustomerPaymentCaptureModeResponse `json:"captureMode,omitempty"`
	// **Only relevant if you wish to manage authorization and capturing separately.**
	//
	// Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
	// later point either be 'captured' or canceled.
	//
	// By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
	// capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
	// example `8 hours` or `2 days`.
	//
	// To schedule an automatic capture, the `captureMode` must be set to `automatic`.
	//
	// The maximum delay is 7 days (168 hours).
	//
	// Possible values: `... hours` `... days`
	CaptureDelay *string `json:"captureDelay,omitempty"`
	// Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
	// can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
	CaptureBefore *string `json:"captureBefore,omitempty"`
	// With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
	// merchants.
	//
	// If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
	// `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
	// to your own account balance.
	//
	// If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
	// `routing` parameter.
	ApplicationFee *CreateCustomerPaymentApplicationFeeResponse `json:"applicationFee,omitempty"`
	// *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
	//
	// With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
	// merchants.
	//
	// If you create payments on your own account that you want to split between yourself and one or more connected
	// merchants, you can use this `routing` parameter to route the payment accordingly.
	//
	// The `routing` parameter should contain an array of objects, with each object describing the destination for a
	// specific portion of the payment.
	//
	// It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
	// payment amount have been routed, the amount left will be routed to the current organization automatically.
	//
	// If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
	// parameter.
	Routing []CreateCustomerPaymentRoutingResponse `json:"routing,omitempty"`
	// **Only relevant for recurring payments.**
	//
	// Indicate which part of a recurring sequence this payment is for.
	//
	// Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
	// through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
	// on their account in the future.
	//
	// If set to `recurring`, the customer's card is charged automatically.
	//
	// Defaults to `oneoff`, which is a regular non-recurring payment.
	//
	// For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
	// [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
	// are set up correctly for recurring payments.
	SequenceType *CreateCustomerPaymentSequenceTypeResponse `json:"sequenceType"`
	// If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
	// be added to the response.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// **Only relevant for recurring payments.**
	//
	// When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
	// the customer's accounts should be credited.
	MandateID *string `json:"mandateId,omitempty"`
	// The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
	// payments, but can also be used on regular payments to enable single-click payments.
	//
	// If `sequenceType` is set to `recurring`, this field is required.
	CustomerID *string `json:"customerId,omitempty"`
	// The identifier referring to the [profile](get-profile) this entity belongs to.
	//
	// When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
	// Organization tokens, the `profileId` is required.
	//
	// For more information, see [Authentication](authentication).
	ProfileID string `json:"profileId"`
	// The identifier referring to the [settlement](get-settlement) this payment was settled with.
	SettlementID *string `json:"settlementId,omitempty"`
	// If the payment was created for an [order](get-order), the ID of that order will be part of the response.
	OrderID *string `json:"orderId,omitempty"`
	// The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
	// statuses occur at what point.
	Status CreateCustomerPaymentStatusEnum `json:"status"`
	// This object offers details about the status of a payment. Currently it is only available for point-of-sale
	// payments.
	//
	// You can find more information about the possible values of this object on
	// [this page](status-reasons).**
	StatusReason *CreateCustomerPaymentStatusReason `json:"statusReason,omitempty"`
	// Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
	IsCancelable *bool `json:"isCancelable,omitempty"`
	// An object containing payment details collected during the payment process. For example, details may include the
	// customer's card or bank details and a payment reference. For the full list of details, please refer to the
	// [method-specific parameters](extra-payment-parameters) guide.
	Details *CreateCustomerPaymentDetails `json:"details,omitempty"`
	// The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
	CreatedAt string `json:"createdAt"`
	// The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
	// not authorized (yet).
	AuthorizedAt *string `json:"authorizedAt,omitempty"`
	// The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
	// completed (yet).
	PaidAt *string `json:"paidAt,omitempty"`
	// The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
	// canceled (yet).
	CanceledAt *string `json:"canceledAt,omitempty"`
	// The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
	// longer expire.
	ExpiresAt *string `json:"expiresAt,omitempty"`
	// The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
	// expire (yet).
	ExpiredAt *string `json:"expiredAt,omitempty"`
	// The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
	// (yet).
	FailedAt *string `json:"failedAt,omitempty"`
	// An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
	Links CreateCustomerPaymentLinksResponse `json:"_links"`
}

func (o *CreateCustomerPaymentResponseBody) GetResource() string {
	if o == nil {
		return ""
	}
	return o.Resource
}

func (o *CreateCustomerPaymentResponseBody) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateCustomerPaymentResponseBody) GetMode() CreateCustomerPaymentMode {
	if o == nil {
		return CreateCustomerPaymentMode("")
	}
	return o.Mode
}

func (o *CreateCustomerPaymentResponseBody) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *CreateCustomerPaymentResponseBody) GetAmount() CreateCustomerPaymentAmountResponse {
	if o == nil {
		return CreateCustomerPaymentAmountResponse{}
	}
	return o.Amount
}

func (o *CreateCustomerPaymentResponseBody) GetAmountRefunded() *CreateCustomerPaymentAmountRefunded {
	if o == nil {
		return nil
	}
	return o.AmountRefunded
}

func (o *CreateCustomerPaymentResponseBody) GetAmountRemaining() *CreateCustomerPaymentAmountRemaining {
	if o == nil {
		return nil
	}
	return o.AmountRemaining
}

func (o *CreateCustomerPaymentResponseBody) GetAmountCaptured() *CreateCustomerPaymentAmountCaptured {
	if o == nil {
		return nil
	}
	return o.AmountCaptured
}

func (o *CreateCustomerPaymentResponseBody) GetAmountChargedBack() *CreateCustomerPaymentAmountChargedBack {
	if o == nil {
		return nil
	}
	return o.AmountChargedBack
}

func (o *CreateCustomerPaymentResponseBody) GetSettlementAmount() *CreateCustomerPaymentSettlementAmount {
	if o == nil {
		return nil
	}
	return o.SettlementAmount
}

func (o *CreateCustomerPaymentResponseBody) GetRedirectURL() *string {
	if o == nil {
		return nil
	}
	return o.RedirectURL
}

func (o *CreateCustomerPaymentResponseBody) GetCancelURL() *string {
	if o == nil {
		return nil
	}
	return o.CancelURL
}

func (o *CreateCustomerPaymentResponseBody) GetWebhookURL() *string {
	if o == nil {
		return nil
	}
	return o.WebhookURL
}

func (o *CreateCustomerPaymentResponseBody) GetLines() []CreateCustomerPaymentLineResponse {
	if o == nil {
		return nil
	}
	return o.Lines
}

func (o *CreateCustomerPaymentResponseBody) GetBillingAddress() *CreateCustomerPaymentBillingAddressResponse {
	if o == nil {
		return nil
	}
	return o.BillingAddress
}

func (o *CreateCustomerPaymentResponseBody) GetShippingAddress() *CreateCustomerPaymentShippingAddressResponse {
	if o == nil {
		return nil
	}
	return o.ShippingAddress
}

func (o *CreateCustomerPaymentResponseBody) GetLocale() *CreateCustomerPaymentLocaleResponse {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *CreateCustomerPaymentResponseBody) GetCountryCode() *string {
	if o == nil {
		return nil
	}
	return o.CountryCode
}

func (o *CreateCustomerPaymentResponseBody) GetMethod() *CreateCustomerPaymentMethodResponse {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *CreateCustomerPaymentResponseBody) GetRestrictPaymentMethodsToCountry() *string {
	if o == nil {
		return nil
	}
	return o.RestrictPaymentMethodsToCountry
}

func (o *CreateCustomerPaymentResponseBody) GetMetadata() *CreateCustomerPaymentMetadataResponse {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *CreateCustomerPaymentResponseBody) GetCaptureMode() *CreateCustomerPaymentCaptureModeResponse {
	if o == nil {
		return nil
	}
	return o.CaptureMode
}

func (o *CreateCustomerPaymentResponseBody) GetCaptureDelay() *string {
	if o == nil {
		return nil
	}
	return o.CaptureDelay
}

func (o *CreateCustomerPaymentResponseBody) GetCaptureBefore() *string {
	if o == nil {
		return nil
	}
	return o.CaptureBefore
}

func (o *CreateCustomerPaymentResponseBody) GetApplicationFee() *CreateCustomerPaymentApplicationFeeResponse {
	if o == nil {
		return nil
	}
	return o.ApplicationFee
}

func (o *CreateCustomerPaymentResponseBody) GetRouting() []CreateCustomerPaymentRoutingResponse {
	if o == nil {
		return nil
	}
	return o.Routing
}

func (o *CreateCustomerPaymentResponseBody) GetSequenceType() *CreateCustomerPaymentSequenceTypeResponse {
	if o == nil {
		return nil
	}
	return o.SequenceType
}

func (o *CreateCustomerPaymentResponseBody) GetSubscriptionID() *string {
	if o == nil {
		return nil
	}
	return o.SubscriptionID
}

func (o *CreateCustomerPaymentResponseBody) GetMandateID() *string {
	if o == nil {
		return nil
	}
	return o.MandateID
}

func (o *CreateCustomerPaymentResponseBody) GetCustomerID() *string {
	if o == nil {
		return nil
	}
	return o.CustomerID
}

func (o *CreateCustomerPaymentResponseBody) GetProfileID() string {
	if o == nil {
		return ""
	}
	return o.ProfileID
}

func (o *CreateCustomerPaymentResponseBody) GetSettlementID() *string {
	if o == nil {
		return nil
	}
	return o.SettlementID
}

func (o *CreateCustomerPaymentResponseBody) GetOrderID() *string {
	if o == nil {
		return nil
	}
	return o.OrderID
}

func (o *CreateCustomerPaymentResponseBody) GetStatus() CreateCustomerPaymentStatusEnum {
	if o == nil {
		return CreateCustomerPaymentStatusEnum("")
	}
	return o.Status
}

func (o *CreateCustomerPaymentResponseBody) GetStatusReason() *CreateCustomerPaymentStatusReason {
	if o == nil {
		return nil
	}
	return o.StatusReason
}

func (o *CreateCustomerPaymentResponseBody) GetIsCancelable() *bool {
	if o == nil {
		return nil
	}
	return o.IsCancelable
}

func (o *CreateCustomerPaymentResponseBody) GetDetails() *CreateCustomerPaymentDetails {
	if o == nil {
		return nil
	}
	return o.Details
}

func (o *CreateCustomerPaymentResponseBody) GetCreatedAt() string {
	if o == nil {
		return ""
	}
	return o.CreatedAt
}

func (o *CreateCustomerPaymentResponseBody) GetAuthorizedAt() *string {
	if o == nil {
		return nil
	}
	return o.AuthorizedAt
}

func (o *CreateCustomerPaymentResponseBody) GetPaidAt() *string {
	if o == nil {
		return nil
	}
	return o.PaidAt
}

func (o *CreateCustomerPaymentResponseBody) GetCanceledAt() *string {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *CreateCustomerPaymentResponseBody) GetExpiresAt() *string {
	if o == nil {
		return nil
	}
	return o.ExpiresAt
}

func (o *CreateCustomerPaymentResponseBody) GetExpiredAt() *string {
	if o == nil {
		return nil
	}
	return o.ExpiredAt
}

func (o *CreateCustomerPaymentResponseBody) GetFailedAt() *string {
	if o == nil {
		return nil
	}
	return o.FailedAt
}

func (o *CreateCustomerPaymentResponseBody) GetLinks() CreateCustomerPaymentLinksResponse {
	if o == nil {
		return CreateCustomerPaymentLinksResponse{}
	}
	return o.Links
}

type CreateCustomerPaymentResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// The newly created payment object.
	Object *CreateCustomerPaymentResponseBody
}

func (o *CreateCustomerPaymentResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *CreateCustomerPaymentResponse) GetObject() *CreateCustomerPaymentResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
