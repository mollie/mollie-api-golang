// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

// Grouping - You can retrieve reports in two different formats. With the `status-balances` format, transactions are grouped by
// status (e.g. `pending`, `available`), then by direction of movement (e.g. moved from pending to available), then
// by transaction type, and then by other sub-groupings where available (e.g. payment method).
//
// With the `transaction-categories` format, transactions are grouped by transaction type, then by direction of
// movement, and then again by other sub-groupings where available.
//
// Both reporting formats will always contain opening and closing amounts that correspond to the start and end dates
// of the report.
type Grouping string

const (
	GroupingStatusBalances        Grouping = "status-balances"
	GroupingTransactionCategories Grouping = "transaction-categories"
)

func (e Grouping) ToPointer() *Grouping {
	return &e
}
func (e *Grouping) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "status-balances":
		fallthrough
	case "transaction-categories":
		*e = Grouping(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Grouping: %v", v)
	}
}

// PendingBalance - The pending balance. Only available if grouping is `status-balances`.
type PendingBalance struct {
	Open             *SubGroup `json:"open,omitempty"`
	Close            *SubGroup `json:"close,omitempty"`
	Pending          *SubGroup `json:"pending,omitempty"`
	MovedToAvailable *SubGroup `json:"movedToAvailable,omitempty"`
}

func (o *PendingBalance) GetOpen() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Open
}

func (o *PendingBalance) GetClose() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Close
}

func (o *PendingBalance) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *PendingBalance) GetMovedToAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedToAvailable
}

// AvailableBalance - The available balance. Only available if grouping is `status-balances`.
type AvailableBalance struct {
	Open                 *SubGroup `json:"open,omitempty"`
	MovedFromPending     *SubGroup `json:"movedFromPending,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
	Close                *SubGroup `json:"close,omitempty"`
}

func (o *AvailableBalance) GetOpen() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Open
}

func (o *AvailableBalance) GetMovedFromPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedFromPending
}

func (o *AvailableBalance) GetImmediatelyAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.ImmediatelyAvailable
}

func (o *AvailableBalance) GetClose() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Close
}

// Open - Only available on `transaction-categories` grouping.
type Open struct {
	Pending   *SubGroup `json:"pending,omitempty"`
	Available *SubGroup `json:"available,omitempty"`
}

func (o *Open) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Open) GetAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Available
}

// Close - Only available on `transaction-categories` grouping.
type Close struct {
	Pending   *SubGroup `json:"pending,omitempty"`
	Available *SubGroup `json:"available,omitempty"`
}

func (o *Close) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Close) GetAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Available
}

// Payments - Only available on `transaction-categories` grouping.
type Payments struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (o *Payments) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Payments) GetMovedToAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedToAvailable
}

func (o *Payments) GetImmediatelyAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.ImmediatelyAvailable
}

// Refunds - Only available on `transaction-categories` grouping.
type Refunds struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (o *Refunds) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Refunds) GetMovedToAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedToAvailable
}

func (o *Refunds) GetImmediatelyAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.ImmediatelyAvailable
}

// Chargebacks - Only available on `transaction-categories` grouping.
type Chargebacks struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (o *Chargebacks) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Chargebacks) GetMovedToAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedToAvailable
}

func (o *Chargebacks) GetImmediatelyAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.ImmediatelyAvailable
}

// Capital - Only available on `transaction-categories` grouping.
type Capital struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (o *Capital) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Capital) GetMovedToAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedToAvailable
}

func (o *Capital) GetImmediatelyAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.ImmediatelyAvailable
}

// Transfers - Only available on `transaction-categories` grouping.
type Transfers struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (o *Transfers) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Transfers) GetMovedToAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedToAvailable
}

func (o *Transfers) GetImmediatelyAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.ImmediatelyAvailable
}

// FeePrepayments - Only available on `transaction-categories` grouping.
type FeePrepayments struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (o *FeePrepayments) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *FeePrepayments) GetMovedToAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedToAvailable
}

func (o *FeePrepayments) GetImmediatelyAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.ImmediatelyAvailable
}

// Corrections - Only available on `transaction-categories` grouping.
type Corrections struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (o *Corrections) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Corrections) GetMovedToAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedToAvailable
}

func (o *Corrections) GetImmediatelyAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.ImmediatelyAvailable
}

// Topups - Only available on `transaction-categories` grouping.
type Topups struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (o *Topups) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Topups) GetMovedToAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.MovedToAvailable
}

func (o *Topups) GetImmediatelyAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.ImmediatelyAvailable
}

// Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a
// typical grouping looks like.
//
// If grouping `status-balances` is chosen, the main grouping is as follows:
//
// * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
// * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
//
// If grouping `transaction-categories` is chosen, the main grouping is as follows:
//
// * `open` and `close` groups, each containing a `pending` and `available` sub-group
// * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups`
// each containing a `pending`, `movedToAvailable`, and
// `immediatelyAvailable` sub-group
//
// Each sub-group typically has:
//
// * An `amount` object containing the group's total amount
// * A `count` integer if relevant (for example, counting the number of refunds)
// * A `subtotals` array containing more sub-group objects if applicable
type Totals struct {
	// The pending balance. Only available if grouping is `status-balances`.
	PendingBalance *PendingBalance `json:"pendingBalance,omitempty"`
	// The available balance. Only available if grouping is `status-balances`.
	AvailableBalance *AvailableBalance `json:"availableBalance,omitempty"`
	// Only available on `transaction-categories` grouping.
	Open *Open `json:"open,omitempty"`
	// Only available on `transaction-categories` grouping.
	Close *Close `json:"close,omitempty"`
	// Only available on `transaction-categories` grouping.
	Payments *Payments `json:"payments,omitempty"`
	// Only available on `transaction-categories` grouping.
	Refunds *Refunds `json:"refunds,omitempty"`
	// Only available on `transaction-categories` grouping.
	Chargebacks *Chargebacks `json:"chargebacks,omitempty"`
	// Only available on `transaction-categories` grouping.
	Capital *Capital `json:"capital,omitempty"`
	// Only available on `transaction-categories` grouping.
	Transfers *Transfers `json:"transfers,omitempty"`
	// Only available on `transaction-categories` grouping.
	FeePrepayments *FeePrepayments `json:"fee-prepayments,omitempty"`
	// Only available on `transaction-categories` grouping.
	Corrections *Corrections `json:"corrections,omitempty"`
	// Only available on `transaction-categories` grouping.
	Topups *Topups `json:"topups,omitempty"`
}

func (o *Totals) GetPendingBalance() *PendingBalance {
	if o == nil {
		return nil
	}
	return o.PendingBalance
}

func (o *Totals) GetAvailableBalance() *AvailableBalance {
	if o == nil {
		return nil
	}
	return o.AvailableBalance
}

func (o *Totals) GetOpen() *Open {
	if o == nil {
		return nil
	}
	return o.Open
}

func (o *Totals) GetClose() *Close {
	if o == nil {
		return nil
	}
	return o.Close
}

func (o *Totals) GetPayments() *Payments {
	if o == nil {
		return nil
	}
	return o.Payments
}

func (o *Totals) GetRefunds() *Refunds {
	if o == nil {
		return nil
	}
	return o.Refunds
}

func (o *Totals) GetChargebacks() *Chargebacks {
	if o == nil {
		return nil
	}
	return o.Chargebacks
}

func (o *Totals) GetCapital() *Capital {
	if o == nil {
		return nil
	}
	return o.Capital
}

func (o *Totals) GetTransfers() *Transfers {
	if o == nil {
		return nil
	}
	return o.Transfers
}

func (o *Totals) GetFeePrepayments() *FeePrepayments {
	if o == nil {
		return nil
	}
	return o.FeePrepayments
}

func (o *Totals) GetCorrections() *Corrections {
	if o == nil {
		return nil
	}
	return o.Corrections
}

func (o *Totals) GetTopups() *Topups {
	if o == nil {
		return nil
	}
	return o.Topups
}

// EntityBalanceReportLinks - An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
type EntityBalanceReportLinks struct {
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Self *URLObj `json:"self,omitempty"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Documentation *URLObj `json:"documentation,omitempty"`
}

func (o *EntityBalanceReportLinks) GetSelf() *URLObj {
	if o == nil {
		return nil
	}
	return o.Self
}

func (o *EntityBalanceReportLinks) GetDocumentation() *URLObj {
	if o == nil {
		return nil
	}
	return o.Documentation
}

type EntityBalanceReport struct {
	// Indicates the response contains a balance report object. Will always contain the string `balance-report` for this
	// endpoint.
	Resource  *string `json:"resource,omitempty"`
	BalanceID *string `json:"balanceId,omitempty"`
	// The time zone used for the from and until parameters. Currently only time zone `Europe/Amsterdam` is supported.
	TimeZone *string `json:"timeZone,omitempty"`
	// The start date of the report, in `YYYY-MM-DD` format. The from date is 'inclusive', and in Central European Time.
	// This means a report with for example `from=2024-01-01` will include movements of 2024-01-01 00:00:00 CET and
	// onwards.
	From *string `json:"from,omitempty"`
	// The end date of the report, in `YYYY-MM-DD` format. The until date is 'exclusive', and in Central European Time.
	// This means a report with for example `until=2024-02-01` will include movements up until 2024-01-31 23:59:59 CET.
	Until *string `json:"until,omitempty"`
	// You can retrieve reports in two different formats. With the `status-balances` format, transactions are grouped by
	// status (e.g. `pending`, `available`), then by direction of movement (e.g. moved from pending to available), then
	// by transaction type, and then by other sub-groupings where available (e.g. payment method).
	//
	// With the `transaction-categories` format, transactions are grouped by transaction type, then by direction of
	// movement, and then again by other sub-groupings where available.
	//
	// Both reporting formats will always contain opening and closing amounts that correspond to the start and end dates
	// of the report.
	Grouping *Grouping `json:"grouping,omitempty"`
	// Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a
	// typical grouping looks like.
	//
	// If grouping `status-balances` is chosen, the main grouping is as follows:
	//
	// * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
	// * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
	//
	// If grouping `transaction-categories` is chosen, the main grouping is as follows:
	//
	// * `open` and `close` groups, each containing a `pending` and `available` sub-group
	// * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups`
	// each containing a `pending`, `movedToAvailable`, and
	// `immediatelyAvailable` sub-group
	//
	// Each sub-group typically has:
	//
	// * An `amount` object containing the group's total amount
	// * A `count` integer if relevant (for example, counting the number of refunds)
	// * A `subtotals` array containing more sub-group objects if applicable
	Totals *Totals `json:"totals,omitempty"`
	// An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
	Links *EntityBalanceReportLinks `json:"_links,omitempty"`
}

func (o *EntityBalanceReport) GetResource() *string {
	if o == nil {
		return nil
	}
	return o.Resource
}

func (o *EntityBalanceReport) GetBalanceID() *string {
	if o == nil {
		return nil
	}
	return o.BalanceID
}

func (o *EntityBalanceReport) GetTimeZone() *string {
	if o == nil {
		return nil
	}
	return o.TimeZone
}

func (o *EntityBalanceReport) GetFrom() *string {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *EntityBalanceReport) GetUntil() *string {
	if o == nil {
		return nil
	}
	return o.Until
}

func (o *EntityBalanceReport) GetGrouping() *Grouping {
	if o == nil {
		return nil
	}
	return o.Grouping
}

func (o *EntityBalanceReport) GetTotals() *Totals {
	if o == nil {
		return nil
	}
	return o.Totals
}

func (o *EntityBalanceReport) GetLinks() *EntityBalanceReportLinks {
	if o == nil {
		return nil
	}
	return o.Links
}
