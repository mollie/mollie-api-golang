// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

// PendingBalance - The pending balance. Only available if grouping is `status-balances`.
type PendingBalance struct {
	Open             *SubGroup `json:"open,omitempty"`
	Close            *SubGroup `json:"close,omitempty"`
	Pending          *SubGroup `json:"pending,omitempty"`
	MovedToAvailable *SubGroup `json:"movedToAvailable,omitempty"`
}

func (p *PendingBalance) GetOpen() *SubGroup {
	if p == nil {
		return nil
	}
	return p.Open
}

func (p *PendingBalance) GetClose() *SubGroup {
	if p == nil {
		return nil
	}
	return p.Close
}

func (p *PendingBalance) GetPending() *SubGroup {
	if p == nil {
		return nil
	}
	return p.Pending
}

func (p *PendingBalance) GetMovedToAvailable() *SubGroup {
	if p == nil {
		return nil
	}
	return p.MovedToAvailable
}

// AvailableBalance - The available balance. Only available if grouping is `status-balances`.
type AvailableBalance struct {
	Open                 *SubGroup `json:"open,omitempty"`
	MovedFromPending     *SubGroup `json:"movedFromPending,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
	Close                *SubGroup `json:"close,omitempty"`
}

func (a *AvailableBalance) GetOpen() *SubGroup {
	if a == nil {
		return nil
	}
	return a.Open
}

func (a *AvailableBalance) GetMovedFromPending() *SubGroup {
	if a == nil {
		return nil
	}
	return a.MovedFromPending
}

func (a *AvailableBalance) GetImmediatelyAvailable() *SubGroup {
	if a == nil {
		return nil
	}
	return a.ImmediatelyAvailable
}

func (a *AvailableBalance) GetClose() *SubGroup {
	if a == nil {
		return nil
	}
	return a.Close
}

// Open - Only available on `transaction-categories` grouping.
type Open struct {
	Pending   *SubGroup `json:"pending,omitempty"`
	Available *SubGroup `json:"available,omitempty"`
}

func (o *Open) GetPending() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Pending
}

func (o *Open) GetAvailable() *SubGroup {
	if o == nil {
		return nil
	}
	return o.Available
}

// Close - Only available on `transaction-categories` grouping.
type Close struct {
	Pending   *SubGroup `json:"pending,omitempty"`
	Available *SubGroup `json:"available,omitempty"`
}

func (c *Close) GetPending() *SubGroup {
	if c == nil {
		return nil
	}
	return c.Pending
}

func (c *Close) GetAvailable() *SubGroup {
	if c == nil {
		return nil
	}
	return c.Available
}

// Payments - Only available on `transaction-categories` grouping.
type Payments struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (p *Payments) GetPending() *SubGroup {
	if p == nil {
		return nil
	}
	return p.Pending
}

func (p *Payments) GetMovedToAvailable() *SubGroup {
	if p == nil {
		return nil
	}
	return p.MovedToAvailable
}

func (p *Payments) GetImmediatelyAvailable() *SubGroup {
	if p == nil {
		return nil
	}
	return p.ImmediatelyAvailable
}

// Refunds - Only available on `transaction-categories` grouping.
type Refunds struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (r *Refunds) GetPending() *SubGroup {
	if r == nil {
		return nil
	}
	return r.Pending
}

func (r *Refunds) GetMovedToAvailable() *SubGroup {
	if r == nil {
		return nil
	}
	return r.MovedToAvailable
}

func (r *Refunds) GetImmediatelyAvailable() *SubGroup {
	if r == nil {
		return nil
	}
	return r.ImmediatelyAvailable
}

// Chargebacks - Only available on `transaction-categories` grouping.
type Chargebacks struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (c *Chargebacks) GetPending() *SubGroup {
	if c == nil {
		return nil
	}
	return c.Pending
}

func (c *Chargebacks) GetMovedToAvailable() *SubGroup {
	if c == nil {
		return nil
	}
	return c.MovedToAvailable
}

func (c *Chargebacks) GetImmediatelyAvailable() *SubGroup {
	if c == nil {
		return nil
	}
	return c.ImmediatelyAvailable
}

// Capital - Only available on `transaction-categories` grouping.
type Capital struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (c *Capital) GetPending() *SubGroup {
	if c == nil {
		return nil
	}
	return c.Pending
}

func (c *Capital) GetMovedToAvailable() *SubGroup {
	if c == nil {
		return nil
	}
	return c.MovedToAvailable
}

func (c *Capital) GetImmediatelyAvailable() *SubGroup {
	if c == nil {
		return nil
	}
	return c.ImmediatelyAvailable
}

// Transfers - Only available on `transaction-categories` grouping.
type Transfers struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (t *Transfers) GetPending() *SubGroup {
	if t == nil {
		return nil
	}
	return t.Pending
}

func (t *Transfers) GetMovedToAvailable() *SubGroup {
	if t == nil {
		return nil
	}
	return t.MovedToAvailable
}

func (t *Transfers) GetImmediatelyAvailable() *SubGroup {
	if t == nil {
		return nil
	}
	return t.ImmediatelyAvailable
}

// FeePrepayments - Only available on `transaction-categories` grouping.
type FeePrepayments struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (f *FeePrepayments) GetPending() *SubGroup {
	if f == nil {
		return nil
	}
	return f.Pending
}

func (f *FeePrepayments) GetMovedToAvailable() *SubGroup {
	if f == nil {
		return nil
	}
	return f.MovedToAvailable
}

func (f *FeePrepayments) GetImmediatelyAvailable() *SubGroup {
	if f == nil {
		return nil
	}
	return f.ImmediatelyAvailable
}

// Corrections - Only available on `transaction-categories` grouping.
type Corrections struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (c *Corrections) GetPending() *SubGroup {
	if c == nil {
		return nil
	}
	return c.Pending
}

func (c *Corrections) GetMovedToAvailable() *SubGroup {
	if c == nil {
		return nil
	}
	return c.MovedToAvailable
}

func (c *Corrections) GetImmediatelyAvailable() *SubGroup {
	if c == nil {
		return nil
	}
	return c.ImmediatelyAvailable
}

// Topups - Only available on `transaction-categories` grouping.
type Topups struct {
	Pending              *SubGroup `json:"pending,omitempty"`
	MovedToAvailable     *SubGroup `json:"movedToAvailable,omitempty"`
	ImmediatelyAvailable *SubGroup `json:"immediatelyAvailable,omitempty"`
}

func (t *Topups) GetPending() *SubGroup {
	if t == nil {
		return nil
	}
	return t.Pending
}

func (t *Topups) GetMovedToAvailable() *SubGroup {
	if t == nil {
		return nil
	}
	return t.MovedToAvailable
}

func (t *Topups) GetImmediatelyAvailable() *SubGroup {
	if t == nil {
		return nil
	}
	return t.ImmediatelyAvailable
}

// Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a
// typical grouping looks like.
//
// If grouping `status-balances` is chosen, the main grouping is as follows:
//
// * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
// * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
//
// If grouping `transaction-categories` is chosen, the main grouping is as follows:
//
// * `open` and `close` groups, each containing a `pending` and `available` sub-group
// * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups`
// each containing a `pending`, `movedToAvailable`, and
// `immediatelyAvailable` sub-group
//
// Each sub-group typically has:
//
// * An `amount` object containing the group's total amount
// * A `count` integer if relevant (for example, counting the number of refunds)
// * A `subtotals` array containing more sub-group objects if applicable
type Totals struct {
	// The pending balance. Only available if grouping is `status-balances`.
	PendingBalance *PendingBalance `json:"pendingBalance,omitempty"`
	// The available balance. Only available if grouping is `status-balances`.
	AvailableBalance *AvailableBalance `json:"availableBalance,omitempty"`
	// Only available on `transaction-categories` grouping.
	Open *Open `json:"open,omitempty"`
	// Only available on `transaction-categories` grouping.
	Close *Close `json:"close,omitempty"`
	// Only available on `transaction-categories` grouping.
	Payments *Payments `json:"payments,omitempty"`
	// Only available on `transaction-categories` grouping.
	Refunds *Refunds `json:"refunds,omitempty"`
	// Only available on `transaction-categories` grouping.
	Chargebacks *Chargebacks `json:"chargebacks,omitempty"`
	// Only available on `transaction-categories` grouping.
	Capital *Capital `json:"capital,omitempty"`
	// Only available on `transaction-categories` grouping.
	Transfers *Transfers `json:"transfers,omitempty"`
	// Only available on `transaction-categories` grouping.
	FeePrepayments *FeePrepayments `json:"fee-prepayments,omitempty"`
	// Only available on `transaction-categories` grouping.
	Corrections *Corrections `json:"corrections,omitempty"`
	// Only available on `transaction-categories` grouping.
	Topups *Topups `json:"topups,omitempty"`
}

func (t *Totals) GetPendingBalance() *PendingBalance {
	if t == nil {
		return nil
	}
	return t.PendingBalance
}

func (t *Totals) GetAvailableBalance() *AvailableBalance {
	if t == nil {
		return nil
	}
	return t.AvailableBalance
}

func (t *Totals) GetOpen() *Open {
	if t == nil {
		return nil
	}
	return t.Open
}

func (t *Totals) GetClose() *Close {
	if t == nil {
		return nil
	}
	return t.Close
}

func (t *Totals) GetPayments() *Payments {
	if t == nil {
		return nil
	}
	return t.Payments
}

func (t *Totals) GetRefunds() *Refunds {
	if t == nil {
		return nil
	}
	return t.Refunds
}

func (t *Totals) GetChargebacks() *Chargebacks {
	if t == nil {
		return nil
	}
	return t.Chargebacks
}

func (t *Totals) GetCapital() *Capital {
	if t == nil {
		return nil
	}
	return t.Capital
}

func (t *Totals) GetTransfers() *Transfers {
	if t == nil {
		return nil
	}
	return t.Transfers
}

func (t *Totals) GetFeePrepayments() *FeePrepayments {
	if t == nil {
		return nil
	}
	return t.FeePrepayments
}

func (t *Totals) GetCorrections() *Corrections {
	if t == nil {
		return nil
	}
	return t.Corrections
}

func (t *Totals) GetTopups() *Topups {
	if t == nil {
		return nil
	}
	return t.Topups
}

// EntityBalanceReportLinks - An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
type EntityBalanceReportLinks struct {
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Self *URLObj `json:"self,omitempty"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Documentation *URLObj `json:"documentation,omitempty"`
}

func (e *EntityBalanceReportLinks) GetSelf() *URLObj {
	if e == nil {
		return nil
	}
	return e.Self
}

func (e *EntityBalanceReportLinks) GetDocumentation() *URLObj {
	if e == nil {
		return nil
	}
	return e.Documentation
}

type EntityBalanceReport struct {
	// Indicates the response contains a balance report object. Will always contain the string `balance-report` for this
	// endpoint.
	Resource  *string `json:"resource,omitempty"`
	BalanceID *string `json:"balanceId,omitempty"`
	// The time zone used for the from and until parameters. Currently only time zone `Europe/Amsterdam` is supported.
	TimeZone *string `json:"timeZone,omitempty"`
	// The start date of the report, in `YYYY-MM-DD` format. The from date is 'inclusive', and in Central European Time.
	// This means a report with for example `from=2024-01-01` will include movements of 2024-01-01 00:00:00 CET and
	// onwards.
	From *string `json:"from,omitempty"`
	// The end date of the report, in `YYYY-MM-DD` format. The until date is 'exclusive', and in Central European Time.
	// This means a report with for example `until=2024-02-01` will include movements up until 2024-01-31 23:59:59 CET.
	Until    *string                `json:"until,omitempty"`
	Grouping *BalanceReportGrouping `json:"grouping,omitempty"`
	// Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a
	// typical grouping looks like.
	//
	// If grouping `status-balances` is chosen, the main grouping is as follows:
	//
	// * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
	// * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
	//
	// If grouping `transaction-categories` is chosen, the main grouping is as follows:
	//
	// * `open` and `close` groups, each containing a `pending` and `available` sub-group
	// * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups`
	// each containing a `pending`, `movedToAvailable`, and
	// `immediatelyAvailable` sub-group
	//
	// Each sub-group typically has:
	//
	// * An `amount` object containing the group's total amount
	// * A `count` integer if relevant (for example, counting the number of refunds)
	// * A `subtotals` array containing more sub-group objects if applicable
	Totals *Totals `json:"totals,omitempty"`
	// An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
	Links *EntityBalanceReportLinks `json:"_links,omitempty"`
}

func (e *EntityBalanceReport) GetResource() *string {
	if e == nil {
		return nil
	}
	return e.Resource
}

func (e *EntityBalanceReport) GetBalanceID() *string {
	if e == nil {
		return nil
	}
	return e.BalanceID
}

func (e *EntityBalanceReport) GetTimeZone() *string {
	if e == nil {
		return nil
	}
	return e.TimeZone
}

func (e *EntityBalanceReport) GetFrom() *string {
	if e == nil {
		return nil
	}
	return e.From
}

func (e *EntityBalanceReport) GetUntil() *string {
	if e == nil {
		return nil
	}
	return e.Until
}

func (e *EntityBalanceReport) GetGrouping() *BalanceReportGrouping {
	if e == nil {
		return nil
	}
	return e.Grouping
}

func (e *EntityBalanceReport) GetTotals() *Totals {
	if e == nil {
		return nil
	}
	return e.Totals
}

func (e *EntityBalanceReport) GetLinks() *EntityBalanceReportLinks {
	if e == nil {
		return nil
	}
	return e.Links
}
