// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

// ListSubscriptionResponseStatus - The subscription's current status is directly related to the status of the underlying customer or mandate that is
// enabling the subscription.
type ListSubscriptionResponseStatus string

const (
	ListSubscriptionResponseStatusPending   ListSubscriptionResponseStatus = "pending"
	ListSubscriptionResponseStatusActive    ListSubscriptionResponseStatus = "active"
	ListSubscriptionResponseStatusCanceled  ListSubscriptionResponseStatus = "canceled"
	ListSubscriptionResponseStatusSuspended ListSubscriptionResponseStatus = "suspended"
	ListSubscriptionResponseStatusCompleted ListSubscriptionResponseStatus = "completed"
)

func (e ListSubscriptionResponseStatus) ToPointer() *ListSubscriptionResponseStatus {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ListSubscriptionResponseStatus) IsExact() bool {
	if e != nil {
		switch *e {
		case "pending", "active", "canceled", "suspended", "completed":
			return true
		}
	}
	return false
}

// ListSubscriptionResponseApplicationFee - With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
// merchants.
//
// Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
//
// Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
// information.
type ListSubscriptionResponseApplicationFee struct {
	// In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
	Amount      Amount `json:"amount"`
	Description string `json:"description"`
}

func (l *ListSubscriptionResponseApplicationFee) GetAmount() Amount {
	if l == nil {
		return Amount{}
	}
	return l.Amount
}

func (l *ListSubscriptionResponseApplicationFee) GetDescription() string {
	if l == nil {
		return ""
	}
	return l.Description
}

// ListSubscriptionResponseLinks - An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
type ListSubscriptionResponseLinks struct {
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Self URLObj `json:"self"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Customer *URLNullable `json:"customer"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Mandate *URLNullable `json:"mandate,omitempty"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Profile *URLNullable `json:"profile"`
	// In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
	Payments *URLNullable `json:"payments,omitempty"`
}

func (l *ListSubscriptionResponseLinks) GetSelf() URLObj {
	if l == nil {
		return URLObj{}
	}
	return l.Self
}

func (l *ListSubscriptionResponseLinks) GetCustomer() *URLNullable {
	if l == nil {
		return nil
	}
	return l.Customer
}

func (l *ListSubscriptionResponseLinks) GetMandate() *URLNullable {
	if l == nil {
		return nil
	}
	return l.Mandate
}

func (l *ListSubscriptionResponseLinks) GetProfile() *URLNullable {
	if l == nil {
		return nil
	}
	return l.Profile
}

func (l *ListSubscriptionResponseLinks) GetPayments() *URLNullable {
	if l == nil {
		return nil
	}
	return l.Payments
}

type ListSubscriptionResponse struct {
	// Indicates the response contains a subscription object. Will always contain the string `subscription` for this
	// endpoint.
	Resource string `json:"resource"`
	// The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
	ID string `json:"id"`
	// Whether this entity was created in live mode or in test mode.
	Mode   Mode                           `json:"mode"`
	Status ListSubscriptionResponseStatus `json:"status"`
	// In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
	Amount Amount `json:"amount"`
	// Total number of payments for the subscription. Once this number of payments is reached, the subscription is
	// considered completed.
	//
	// Test mode subscriptions will get canceled automatically after 10 payments.
	Times *int64 `json:"times"`
	// Number of payments left for the subscription.
	TimesRemaining *int64 `json:"timesRemaining"`
	// Interval to wait between payments, for example `1 month` or `14 days`.
	//
	// The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
	//
	// Possible values: `... days`, `... weeks`, `... months`.
	Interval string `json:"interval"`
	// The start date of the subscription in `YYYY-MM-DD` format.
	StartDate string `json:"startDate"`
	// The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
	// this parameter will not be returned.
	NextPaymentDate *string `json:"nextPaymentDate,omitempty"`
	// The subscription's description will be used as the description of the resulting individual payments and so showing
	// up on the bank statement of the consumer.
	//
	// **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
	Description string `json:"description"`
	// The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
	Method *SubscriptionMethodResponse `json:"method"`
	// With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
	// merchants.
	//
	// Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
	//
	// Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
	// information.
	ApplicationFee *ListSubscriptionResponseApplicationFee `json:"applicationFee,omitempty"`
	// Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
	// you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
	Metadata *Metadata `json:"metadata"`
	// We will call this URL for any payment status changes of payments resulting from this subscription.
	//
	// This webhook will receive **all** events for the subscription's payments. This may include payment failures as
	// well. Be sure to verify the payment's subscription ID and its status.
	WebhookURL *string `json:"webhookUrl"`
	// The customer this subscription belongs to.
	CustomerID string  `json:"customerId"`
	MandateID  *string `json:"mandateId,omitempty"`
	// The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
	CreatedAt string `json:"createdAt"`
	// The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
	// subscription is not canceled (yet).
	CanceledAt *string `json:"canceledAt,omitempty"`
	// An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
	Links ListSubscriptionResponseLinks `json:"_links"`
}

func (l *ListSubscriptionResponse) GetResource() string {
	if l == nil {
		return ""
	}
	return l.Resource
}

func (l *ListSubscriptionResponse) GetID() string {
	if l == nil {
		return ""
	}
	return l.ID
}

func (l *ListSubscriptionResponse) GetMode() Mode {
	if l == nil {
		return Mode("")
	}
	return l.Mode
}

func (l *ListSubscriptionResponse) GetStatus() ListSubscriptionResponseStatus {
	if l == nil {
		return ListSubscriptionResponseStatus("")
	}
	return l.Status
}

func (l *ListSubscriptionResponse) GetAmount() Amount {
	if l == nil {
		return Amount{}
	}
	return l.Amount
}

func (l *ListSubscriptionResponse) GetTimes() *int64 {
	if l == nil {
		return nil
	}
	return l.Times
}

func (l *ListSubscriptionResponse) GetTimesRemaining() *int64 {
	if l == nil {
		return nil
	}
	return l.TimesRemaining
}

func (l *ListSubscriptionResponse) GetInterval() string {
	if l == nil {
		return ""
	}
	return l.Interval
}

func (l *ListSubscriptionResponse) GetStartDate() string {
	if l == nil {
		return ""
	}
	return l.StartDate
}

func (l *ListSubscriptionResponse) GetNextPaymentDate() *string {
	if l == nil {
		return nil
	}
	return l.NextPaymentDate
}

func (l *ListSubscriptionResponse) GetDescription() string {
	if l == nil {
		return ""
	}
	return l.Description
}

func (l *ListSubscriptionResponse) GetMethod() *SubscriptionMethodResponse {
	if l == nil {
		return nil
	}
	return l.Method
}

func (l *ListSubscriptionResponse) GetApplicationFee() *ListSubscriptionResponseApplicationFee {
	if l == nil {
		return nil
	}
	return l.ApplicationFee
}

func (l *ListSubscriptionResponse) GetMetadata() *Metadata {
	if l == nil {
		return nil
	}
	return l.Metadata
}

func (l *ListSubscriptionResponse) GetWebhookURL() *string {
	if l == nil {
		return nil
	}
	return l.WebhookURL
}

func (l *ListSubscriptionResponse) GetCustomerID() string {
	if l == nil {
		return ""
	}
	return l.CustomerID
}

func (l *ListSubscriptionResponse) GetMandateID() *string {
	if l == nil {
		return nil
	}
	return l.MandateID
}

func (l *ListSubscriptionResponse) GetCreatedAt() string {
	if l == nil {
		return ""
	}
	return l.CreatedAt
}

func (l *ListSubscriptionResponse) GetCanceledAt() *string {
	if l == nil {
		return nil
	}
	return l.CanceledAt
}

func (l *ListSubscriptionResponse) GetLinks() ListSubscriptionResponseLinks {
	if l == nil {
		return ListSubscriptionResponseLinks{}
	}
	return l.Links
}
